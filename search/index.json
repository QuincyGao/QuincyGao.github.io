[{"content":"b2b_logic模块介绍 b2b_logic 官方使用场景介绍:https://www.opensips.org/Documentation/Tutorials-B2BUA-3-2\n本次测试的opensips版本为：\nopensips 3.3.10 (x86_64/linux)\nb2b_logic 实战 配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 loadmodule \u0026#34;b2b_entities.so\u0026#34; loadmodule \u0026#34;rtp_relay.so\u0026#34; loadmodule \u0026#34;dialog.so\u0026#34; loadmodule \u0026#34;b2b_logic.so\u0026#34; modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;hash_size\u0026#34;, 10) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;script_req_route\u0026#34;, \u0026#34;b2b_logic_request\u0026#34;) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;script_reply_route\u0026#34;, \u0026#34;b2b_logic_reply\u0026#34;) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;cleanup_period\u0026#34;, 60) #modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;db_url\u0026#34;, \u0026#34;mysql://opensips:opensipsrw@172.16.4.111/opensips\u0026#34;) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;update_period\u0026#34;, 60) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;max_duration\u0026#34;, 7200) #modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;contact_user\u0026#34;, 1) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;server_address\u0026#34;, \u0026#34;sip:$fU@172.16.4.111:5360\u0026#34;) #modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;db_mode\u0026#34;, 1) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;b2bl_th_init_timeout\u0026#34;, 60) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;b2bl_early_update\u0026#34;, 1) 在 route主请求中添加：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 if(is_method(\u0026#34;INVITE\u0026#34;) \u0026amp;\u0026amp; !has_totag()) { xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---b2b-server_new--:$rm|$rs|$tu|$socket_in(port)|$var(contact)\\n\u0026#34;); b2b_server_new(\u0026#34;caller\u0026#34;); create_dialog(\u0026#34;B\u0026#34;); rtp_relay_engage(\u0026#34;rtpengine\u0026#34;,0); #$avp(route)=\u0026#34;Record-Route\u0026#34;; #$avp(route-content)=\u0026#34;\u0026lt;sip:172.16.4.111:5360;lr\u0026gt;\u0026#34;; #b2b_client_new(\u0026#34;callee\u0026#34;, \u0026#34;sip:$tU@172.16.4.114:5080\u0026#34;,,,$ct); b2b_client_new(\u0026#34;callee\u0026#34;, \u0026#34;sip:$tU@172.16.4.114:5080\u0026#34;); #record_route(); #b2b_client_new(\u0026#34;callee\u0026#34;, \u0026#34;sip:$tU@172.16.4.114:5080\u0026#34;,,,$ct,$avp(route),$avp(route-content)); # initialize B2B session b2b_init_request(\u0026#34;prepaid\u0026#34;); exit; } route[b2b_logic_reply] { xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;[$fU $tU $ci $rm] B2B_Reply Received from $si:$sp User-Agent:$ua\\n\u0026#34;); xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;[$fU $tU $ci $rm] B2B_Reply message $rs:$rr received \\n\u0026#34;); b2b_handle_reply(); exit; } route[b2b_logic_request] { xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;[$fU $tU $ci $rm] B2B_Request Received from $si:$sp User-Agent:$ua\\n\u0026#34;); xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;[$fU $tU $ci $rm] B2B_Request message $rs:$rr received \\n\u0026#34;); b2b_pass_request(); exit; } 需要注意的是， b2b_logic中媒体服务使用的是rtp_relay,通过rtp_relay来选择媒体代理。 通过b2b_logic 转发的INVITE的Call-ID是新生成的（例如:B2B.377.4269969.1739239153）和主叫的INVITE的Call-ID不同。\n目前发现，被叫挂断时b2b_logic会多发送一个Bye给自己，已提bug到opensips的issue.\n主叫挂断的sip流程图：\n被叫挂断的sip流程图：\n","date":"2025-02-11T08:49:22+08:00","image":"https://QuincyGao.github.io/p/b2b_logic%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/2_hu2473336972660618009.jpg","permalink":"https://QuincyGao.github.io/p/b2b_logic%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","title":"b2b_logic模块介绍"},{"content":"介绍 uac_registant模块是把自己作为uac注册到第三方sip服务，必须使用数据库来存储自己的注册信息。 使用的表为: registrant\n本次测试的opensips版本为:\nopensips 3.5.3 (x86_64/linux)\n配置添加 1 2 3 4 5 6 7 loadmodule \u0026#34;db_mysql.so\u0026#34; loadmodule \u0026#34;uac_auth.so\u0026#34; loadmodule \u0026#34;uac_registrant.so\u0026#34; modparam(\u0026#34;uac_registrant\u0026#34;, \u0026#34;hash_size\u0026#34;, 4) modparam(\u0026#34;uac_registrant\u0026#34;, \u0026#34;timer_interval\u0026#34;, 30) modparam(\u0026#34;uac_registrant\u0026#34;, \u0026#34;failure_retry_interval\u0026#34;, 60) modparam(\u0026#34;uac_registrant\u0026#34;, \u0026#34;db_url\u0026#34;, \u0026#34;mysql://opensips:opensipsrw@172.16.3.102/opensips\u0026#34;) 需要注意的是: timer_interval 要小于registrant表里的expiry字段时间，否则服务启动时报错：\nERROR:uac_registrant:load_reg_info_from_db: Please decrease timer_interval=[120] - requested expires=[100] to small for AOR=[sip:1001@172.16.4.114]\n添加数据库 1 insert into registrant (registrar, aor, username, password, binding_URI, expiry, forced_socket)values(\u0026#34;sip:172.16.4.114:5060\u0026#34;,\u0026#34;sip:1001@172.16.4.111\u0026#34;,\u0026#34;1001\u0026#34;,\u0026#34;1234\u0026#34;,\u0026#34;sip:1001@172.16.4.111\u0026#34;,300,\u0026#34;udp:172.16.4.111:5361\u0026#34;); registrar: 注册的sip服务地址\naor: From, to 字段的uri\nusername,password: 用户名密码\nbinding_URI: contact 字段\nexpiry: 过期时间\nforced_socket: opensips发送register请求的socket地址\n测试结果 opensips启动30s后,跟踪sip信令,能够看到以下信息 总结 该模块只是把opensips以配置的用户名密码注册到第三方sip，使用场景有限，能够使用的场景有：\n检测第三方sip服务是否正常 维持 NAT/防火墙穿透 ","date":"2025-02-08T09:56:29+08:00","image":"https://QuincyGao.github.io/p/uac_registant%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/2_hu11294429585031955147.jpg","permalink":"https://QuincyGao.github.io/p/uac_registant%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","title":"uac_registant模块介绍"},{"content":"背景介绍 自从使用opensips和rtpengine做sbc以来，一直对其所能支撑的并发数有所怀疑，正好最近项目不多，就申请了三台阿里云机器来做压测，共耗时一个月。\n本次压测的功能：把opensips用作注册代理转发，现对压测结果做个总结。\n压测模型 压测场景 坐席A和B使用udp通过opensips注册到uas，坐席A通过opensips拨打电话到坐席B, 坐席B接通电话后，坐席A和B通过opensips进行2分钟通话，然后坐席A挂断电话。\n版本信息 1 2 3 opensips: 3.3.10 rtpengine: 13.1.0.0+0~mr13.1.0.0 opensips和rtpengine 分别用host模式docker容器运行。 opensips和rtpengine使用docker部署的好处就是使用docker stats 能够获取容器是实际占用内存和cpu使用率\n监控指标 1 2 3 4 5 6 cpu使用率 负载 内存使用率 网络带宽 tcp 连接数 通话数 监控工具 1 2 3 阿里云的资源监控 opensips-cli docker stats 命令 压测注意问题 1. 压测的cps和通话时长要合适 压测目的是保持稳定并发数时的资源使用情况\n如果通话时长太短比如:1分钟以内，在高并发的情况下(1000往上)，无法稳定保持并发数。 如果cps太大，此时网络带宽会有比较大的波动，高并发数情况下，opensips和uas会出现丢包情况。 合理的cps计算方式为: 并发数/通话时长(s),如果是小数可以适当向上取整。 比如: 1000并发数，通话时长为2分钟，那么cps为1000/120=8.3约等于9。 对应的sipp 命令为: -r 9 -rp 1s\n2. 如何确定总压测时长 压测时长2小时，实际的sipp压测脚本参数并没有总通话时长，但sipp中有总压测数参数，那么应该如何确定压测时长呢？\n总压测数=并发数*压测时长(分钟)/通话时长(分钟)\n对于此压测场景，总压测数=1000*120/2=60000,对应的sipp命令为: -m 60000\n注意：实际压测中并不是并发数1000，sipp的-l 就是1000，可能会比1000多几个，按照实际压测来调整.\n3. 完整的uac sipp命令 以1000路为例:\n1 ./sipp -r 9 -rp 1s -i 172.16.4.115 -p 5667 -sf register.xml -inf $csvfile 172.20.231.4:5261 -l 1019 -m 61140 -aa -trace_err -error_file ./reg_error.log -bg 压测结果分析 opensips和rtpengine的内存未释放？ 在udp压测时，opensips的运行参数为: -m 2048 -M 100 意思为:共享内存为2048MB,pkg内存100MB, udp_workers=32 tcp_workers=8。 在实际压测过程中，阿里云的监控能够看到，内存使用率一直都是2G，变化较少。但是通过docker stats分别在压测开始和结束统计,能够看到opensips和rtpengine的实际占用内存是有变化的。以1000路为例:\nopensips:959.4MiB-\u0026gt;982MiB | rtpengine: 23.89MiB-\u0026gt;87.73MiB\n压测停止6小时之后，opensips和rtpengine的docker实际占用内存并没有减少，一开始我以为是内存泄露，调整opensips.cfg添加memdump=2开启内存打印。\n在压测结束后， 通过opensips-cli执行mi mem_shm_dump,参考：opensips内存泄漏排查，并没有发现有相似的dumping all alloc'ed. fragments。 而且压测结束后，查看rtpengine的端口占用情况，rtp端口都被释放了。\n值得注意的是：并发数减少，opensips和rtpengin的内存占用不会变，并发数增加，它们的内存会往上升。之后一直维持该内存大小不再增加。\n个人猜测： opensips和rtpengine的占用内存是动态扩展的，当并发数增加，内存会自动扩展，当并发数减少，占用的内存不会自动释放。\n压测极限 监测数据 本次使用的是opensips-cli\n1 2 3 mi get_statistics dialog active_dialogs 可以查看实时通话量 mi get_statistics dialog processed_dialogs 可以查看通话总数 mi get_statistics all 可以查看所有统计数据 实际压测数据 8C8G压测的极限是1700路，此极限是rtpengine的极限,cpu负载过大，导致rtpengine出流较慢，影响了通话质量。opensips其实并未到极限。\n压测结束后，通过opensips-cli执行mi get_statistics all 能够看到实际占用的内存很少，还有大量的内存空闲。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026#34;shmem:total_size\u0026#34;: 2147483648, \u0026#34;shmem:max_used_size\u0026#34;: 15768384, \u0026#34;shmem:free_size\u0026#34;: 2142524128, \u0026#34;shmem:used_size\u0026#34;: 4708928, \u0026#34;shmem:real_used_size\u0026#34;: 4959520, \u0026#34;shmem:fragments\u0026#34;: 3871, \u0026#34;rpmem:rpm_total_size\u0026#34;: 0, \u0026#34;rpmem:rpm_used_size\u0026#34;: 0, \u0026#34;rpmem:rpm_real_used_size\u0026#34;: 0, \u0026#34;rpmem:rpm_fragments\u0026#34;: 0, \u0026#34;rpmem:rpm_max_used_size\u0026#34;: 0, \u0026#34;rpmem:rpm_free_size\u0026#34;: 0, sip 使用tcp通信 场景：\nuac\u0026ndash;tcp\u0026mdash;-\u0026gt;opensips\u0026mdash;-tcp\u0026mdash;-\u0026gt;uas\nuac和opensips使用tcp通信，uac是多个tcp连接到opensips的同一个端口. 在opensips和uas使用tcp通信时，原本以为会是多个tcp和uas连接，结果只用了一个tcp连接，所有的请求都是复用这个tcp连接。 tcp的性能比udp性能要高，tcp连接方式并发能到1800路。 总结 opensips-cli只能获取实时数据，无法获取历史数据。可以考虑使用opensips-cp监控。 rtpengine在高并发情况下，为啥会出流慢，目前还未找到原因，rtpengine的日志也没有报错。 ","date":"2025-01-14T08:59:33+08:00","image":"https://QuincyGao.github.io/p/opensips-%E5%8E%8B%E6%B5%8B%E4%BB%8B%E7%BB%8D/backup_hu11264033365958483853.jpg","permalink":"https://QuincyGao.github.io/p/opensips-%E5%8E%8B%E6%B5%8B%E4%BB%8B%E7%BB%8D/","title":"opensips 压测介绍"}]