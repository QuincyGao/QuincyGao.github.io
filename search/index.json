[{"content":"背景 kamailio,opensips分别有dispatcher,load_balancer模块来实现sip信令负载均衡和分发功能。 那么作为全能型的freeswitch,也有mod_distributor模块来实现该功能。\nmod_distributor只支持invite不支持register请求的负载均衡和分发。官方文档\n本次测试的freeswitch版本为:\n1.10.7-release+git20211024T163933Z883d2cb662~64bit\n测试 编译 在freeswitch的源码编译目录下的文件modules.conf中取消注释:\n1 applications/mod_distributor 重新编译源码，这样就能编译mod_distributor模块。\n配置 在freeswitch运行路径下的conf/autoload_configs/modules.conf.xml中，加载mod_distributor模块: 1 \u0026lt;load module=\u0026#34;mod_distributor\u0026#34;/\u0026gt; 在conf/autoload_configs/distributor.conf.xml中，配置分发策略, 原始示例内容为: 1 2 3 4 5 6 7 8 9 10 \u0026lt;configuration name=\u0026#34;distributor.conf\u0026#34; description=\u0026#34;Distributor Configuration\u0026#34;\u0026gt; \u0026lt;lists\u0026gt; \u0026lt;!-- every 10 calls to test you will get foo1 once and foo2 9 times...yes NINE TIMES! --\u0026gt; \u0026lt;!-- this is not the same as 100 with 10 and 90 that would do foo1 10 times in a row then foo2 90 times in a row --\u0026gt; \u0026lt;list name=\u0026#34;test\u0026#34;\u0026gt; \u0026lt;node name=\u0026#34;foo1\u0026#34; weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;node name=\u0026#34;foo2\u0026#34; weight=\u0026#34;9\u0026#34;/\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/lists\u0026gt; \u0026lt;/configuration\u0026gt; 修改配置为:\n1 2 3 4 5 6 7 8 \u0026lt;configuration name=\u0026#34;distributor.conf\u0026#34; description=\u0026#34;Distributor\u0026#34;\u0026gt; \u0026lt;lists\u0026gt; \u0026lt;list name=\u0026#34;2gw\u0026#34; total-weight=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;node name=\u0026#34;gw1\u0026#34; value=\u0026#34;sofia/gateway/gw1\u0026#34; weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;node name=\u0026#34;gw2\u0026#34; value=\u0026#34;sofia/gateway/gw2\u0026#34; weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/lists\u0026gt; \u0026lt;/configuration\u0026gt; 可以通过调整weight值来改变分发策略，总数之和为total-weight。\n在conf/sip_profiles/external/中,参考example.xml,分别创建两个网关文件：gw1.xml,gw2.xml。 一个转到172.16.4.113上，一个转到172.16.4.114上。gw1.xml的示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;include\u0026gt; \u0026lt;gateway name=\u0026#34;gw1\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;realm\u0026#34; value=\u0026#34;172.16.4.113:5060\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;expire-seconds\u0026#34; value=\u0026#34;60\u0026#34;/\u0026gt; \u0026lt;!--/// do not register ///--\u0026gt; \u0026lt;param name=\u0026#34;register\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;!-- which transport to use for register --\u0026gt; \u0026lt;param name=\u0026#34;register-transport\u0026#34; value=\u0026#34;udp\u0026#34;/\u0026gt; \u0026lt;!--How many seconds before a retry when a failure or timeout occurs --\u0026gt; \u0026lt;param name=\u0026#34;retry-seconds\u0026#34; value=\u0026#34;30\u0026#34;/\u0026gt; \u0026lt;!--Use the callerid of an inbound call in the from field on outbound calls via this gateway --\u0026gt; \u0026lt;param name=\u0026#34;caller-id-in-from\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!--send an options ping every x seconds, failure will unregister and/or mark it down--\u0026gt; \u0026lt;param name=\u0026#34;ping\u0026#34; value=\u0026#34;25\u0026#34;/\u0026gt; \u0026lt;/gateway\u0026gt; \u0026lt;/include\u0026gt; 这里配置了ping功能，25秒检测一次网关是否可用,用于后面dead gateways功能测试。\n在conf/dialplan/default.xml中, 配置拨号计划, 示例内容为: 1 2 3 4 5 6 7 \u0026lt;extension name=\u0026#34;3-way gateway distributor\u0026#34;\u0026gt; \u0026lt;condition field=\u0026#34;destination_number\u0026#34; expression=\u0026#34;9980$\u0026#34;\u0026gt; \u0026lt;action application=\u0026#34;set\u0026#34; data=\u0026#34;continue_on_fail=true\u0026#34;/\u0026gt; \u0026lt;action application=\u0026#34;set\u0026#34; data=\u0026#34;hangup_after_bridge=true\u0026#34;/\u0026gt; \u0026lt;action application=\u0026#34;bridge\u0026#34; data=\u0026#34;sofia/gateway/${distributor(2gw)}/1004\u0026#34; loop=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;/condition\u0026gt; \u0026lt;/extension\u0026gt; 重启服务 运行 软电话A1003注册到上面设置的拨号计划的sip服务器172.16.4.111上, 软电话B和C用户1004分别注册到172.16.4.113(gw1)和172.16.4.114(gw2)sip服务器上。\n然后A软电话拨打9980号码, 此时会拨打gw1上，如果gw1有该坐席，不管是接通还是挂断， 都不会再拨打gw2上的1004用户。但是如果在gw1上INVITE返回了错误的信令, 则会拨打gw2上的1004用户。\n正常的信令图: gw1失败，gw2成功： 正常情况会按照轮询策略来分发invite请求。 可以看到，第一通电话转gw1，第二通电话转gw2,第三通电话转gw1，依次轮询。\n如果其中一个网关不通，能否不再往该网关发送invite请求呢？\n也是可以的，使用dead gateways，修改conf/dialplan/default.xml中， 配置拨号计划， 示例内容为:\n1 2 3 4 5 6 7 8 9 \u0026lt;extension name=\u0026#34;3-way gateway distributor\u0026#34;\u0026gt; \u0026lt;condition field=\u0026#34;destination_number\u0026#34; expression=\u0026#34;9980$\u0026#34;\u0026gt; \u0026lt;action application=\u0026#34;set\u0026#34; data=\u0026#34;continue_on_fail=true\u0026#34;/\u0026gt; \u0026lt;action application=\u0026#34;set\u0026#34; data=\u0026#34;hangup_after_bridge=true\u0026#34;/\u0026gt; \u0026lt;action application=\u0026#34;bridge\u0026#34; data=\u0026#34;sofia/gateway/${expand(distributor 2gw ${sofia(profile external gwlist down)})}/1004\u0026#34; loop=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;/condition\u0026gt; \u0026lt;/extension\u0026gt; 停掉gw1网关,当看到日志[WARNING] sofia.c:6503 Ping failed gw1 with code 503 - count 1/0/1, state DOWN, 然后A软电话拨打9980号码, 此时只会拨打gw2上的1004用户。\n可以看到信令交互上，确是如此。 总结 mod_distributor只能使用简单的轮询和权重策略来分发invite请求。 使用网关的功能，可以自动检测到下线的网关，然后不再往该网关发送invite请求。 ","date":"2025-11-25T09:13:08+08:00","image":"https://QuincyGao.github.io/p/freeswitch-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%88%86%E5%8F%91/backup_hu472715805359077136.jpg","permalink":"https://QuincyGao.github.io/p/freeswitch-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%88%86%E5%8F%91/","title":"freeswitch 负载均衡分发"},{"content":"背景 在智能呼叫系统中,转人工是一个重要的功能，有几个功能点需要注意:\n一般的场景是转一次人工, 后续的呼叫都由人工客服处理。 但是也会有转多次人工的场景，比如：当前的客服处理不了，需要转到级别高的客服处理。 转人工后的通话是否能录音？ 一般的处理方式是转人工成功之后，就认为智能呼叫系统处理结束， 后续客户和客服的通话不录音，他们之间的通话只会在freeswitch中转发。 接下来我们会对转人工的方式进行详细的说明。\n转人工方式 使用esl方式通过freeswitch转人工\n通过REFER信令转人工\nbridge bridge的用法为:\n1 bridge \u0026lt;target_endpoint\u0026gt; 其中\u0026lt;target_endpoint\u0026gt;是要转人工的客服的SIP地址, 可以为：\n1 2 3 user/1000 lcr/18005558355 sofia/external/18005558355@sip.tollfreegateway.com bridge会主动发送INVITE给客服，然后再把两通电话桥接起来。\nbridge user/1002, user/1003:这个会同时拨打两个坐席号1002,1003,哪个先接通哪个就先桥接哪个. 另外一个坐席会挂断。\nbridge user/1002|user/1003: 会先拨打1002,如果1002不接通, 才会拨打1003。\nbridge user/1002:_:user/1003 和上面的,功能一样，不过此方法是多线程方式。\nuuid_bridge uuid_bridge的用法为:\n1 uuid_bridge \u0026lt;uuid\u0026gt; \u0026lt;other_uuid\u0026gt; 其中\u0026lt;uuid\u0026gt;是要桥接的通话的UUID, \u0026lt;other_uuid\u0026gt;是转人工的UUID。\nuuid_bridge需要你先发送INVITE给客服，然后再用uuid_bridge桥接。\ndeflect 使用方法：\n1 deflect SIPURI deflect会在一个接通的会话中，会挂断当前的channel, 然后发送Refer信令和INVITE信令给转人工方。\nsip_refer_continue_after_reply如果为true, 就不会挂断当前的会话，然后发送REFER信令。Refer的详细协议\n交互流程 sequenceDiagram microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.111): INVITE Note over microSIP(A),fs(172.16.4.111): Session-Expires: 1800 fs(172.16.4.111)-\u0026gt;\u0026gt;microSIP(A): 200OK microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.111): ACK Note over fs(172.16.4.111),microSIP(A): 接通电话 fs(172.16.4.111)-\u0026gt;\u0026gt; microSIP(A): REFER Note over fs(172.16.4.111), microSIP(A): Refer-To:\u0026lt;sip:B@172.16.4.114:5060\u0026gt;\u0026lt;br/\u0026gt;Referred-By:\u0026lt;sip:172.16.4.111\u0026gt; microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.111): 202 Accepted microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.114): INVITE fs(172.16.4.114)--\u0026gt;\u0026gt;microSIP(A): 100 Trying fs(172.16.4.114)-\u0026gt;\u0026gt;microSIP(B): INVITE microSIP(B)--\u0026gt;\u0026gt;fs(172.16.4.114): 100 Trying microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.111): NOTIFY Note over microSIP(A),fs(172.16.4.111): Event: refer\u0026lt;br\u0026gt;SIP/2.0 100 Trying fs(172.16.4.111)-\u0026gt;\u0026gt; microSIP(A): 200OK microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.111): INVITE(SDP) Note over microSIP(A),fs(172.16.4.111): Session-Expires: 1800；refresher=uac microSIP(B)-\u0026gt;\u0026gt;fs(172.16.4.114): 180 Ringing fs(172.16.4.114)-\u0026gt;\u0026gt;microSIP(A): 183 Ringing microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.111): NOTIFY Note over microSIP(A),fs(172.16.4.111): Event: refer\u0026lt;br\u0026gt;SIP/2.0 183 Ringing fs(172.16.4.111)-\u0026gt;\u0026gt; microSIP(A): 200OK fs(172.16.4.111)--\u0026gt;\u0026gt; microSIP(A): 100 Trying fs(172.16.4.111)-\u0026gt;\u0026gt; microSIP(A): 200OK(SDP) microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.111): ACK microSIP(B)-\u0026gt;\u0026gt;fs(172.16.4.114): 200OK fs(172.16.4.114)-\u0026gt;\u0026gt;microSIP(A): 200OK microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.111): NOTIFY Note over microSIP(A),fs(172.16.4.111): Event: refer\u0026lt;br\u0026gt;SIP/2.0 200 OK fs(172.16.4.111)-\u0026gt;\u0026gt; microSIP(A): 200OK fs(172.16.4.111)-\u0026gt;\u0026gt;microSIP(A): BYE microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.111): 200OK microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.114): ACK fs(172.16.4.114)-\u0026gt;\u0026gt;microSIP(B): ACK Note over fs(172.16.4.114),microSIP(B): 通话接通 microSIP(B)-\u0026gt;\u0026gt;fs(172.16.4.114): BYE Note over microSIP(B),fs(172.16.4.114): 通话结束 fs(172.16.4.114)-\u0026gt;\u0026gt;microSIP(A): BYE microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.114): 200OK fs(172.16.4.114)-\u0026gt;\u0026gt;microSIP(B): 200OK refer的流程是：\nfs(172.16.4.111) 发送REFER信令给UAC,并带上Refer-To头域, UAC如果接受REFER信令,那么会给一个202 Accepted信令, UAC后面就会拨打REFER信令中的Refer-To头域中转人工的地址。 UAC和转人工的信令过程都会通过NOTIFY通知fs(172.16.4.111)。 当UAC和转人工的通话接通后, fs(172.16.4.111)会挂断和UAC的通话。 小结：\n转人工成功之后，转人工的语音流不会再经过fs(172.16.4.111),所以也就无法录音了。 转人工时,microSIP(A)也有往fs(172.16.4.111)发送INVITE,这个INVITE其实相当于UPDATE, 通知fs(172.16.4.111)媒体信息更新。 sip_refer_continue_after_reply我设置成了true,但是还是会挂断当前的会话，和描述的功能不一样。我的freeswitch版本就是1.10.7 uuid_deflect 使用方法:\n1 uuid_deflect \u0026lt;uuid\u0026gt; SIPURI 功能和deflect 一样, 只是uuid_deflect是通过UUID来转人工的。\nredirect 使用方法：\n1 redirect SIPURI,SIPURI 未接通时，想转人工，可以使用此功能。\n交互流程 sequenceDiagram microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.111): INVITE Note over microSIP(A),fs(172.16.4.111): Session-Expires: 1800 fs(172.16.4.111)--\u0026gt;\u0026gt;microSIP(A): 100 Trying fs(172.16.4.111)-\u0026gt;\u0026gt; microSIP(A): 302 Moved Temporarily Note over fs(172.16.4.111), microSIP(A): Contact: \u0026#34;unknown\u0026#34; \u0026lt;sip:1009@172.16.4.114:5060\u0026gt;\u0026lt;br/\u0026gt;Remote-Party-ID:\u0026#34;88990\u0026#34; \u0026lt;sip:88990@172.16.4.111\u0026gt;；party=calling microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.111): ACK microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.114): INVITE Note over microSIP(A),fs(172.16.4.114): To: \u0026#34;unknown\u0026#34; \u0026lt;sip:1009@172.16.4.114\u0026gt; fs(172.16.4.114)--\u0026gt;\u0026gt;microSIP(A): 100 Trying fs(172.16.4.114)-\u0026gt;\u0026gt;microSIP(B): INVITE microSIP(B)--\u0026gt;\u0026gt;fs(172.16.4.114): 100 Trying microSIP(B)-\u0026gt;\u0026gt;fs(172.16.4.114): 180 Ringing fs(172.16.4.114)-\u0026gt;\u0026gt; microSIP(A): 183 Ringing microSIP(B)--\u0026gt;\u0026gt;fs(172.16.4.114): 200OK(SDP) Note over microSIP(B),fs(172.16.4.114): 通话接通 fs(172.16.4.114)-\u0026gt;\u0026gt; microSIP(A): 200OK(SDP) microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.114): ACK fs(172.16.4.114)-\u0026gt;\u0026gt;microSIP(B): ACK 使用redirect时, fs(172.16.4.111)返回302 Moved Temporarily, 然后UAC会根据Contact头域, 重新发送INVITE信令。 后续的交互就和fs(172.16.4.111)没有任何关系了。\ntransfer 用法：\n1 transfer \u0026lt;destination_number\u0026gt; [\u0026lt;dialplan\u0026gt; [\u0026lt;context\u0026gt;]] 因为是转到线路上，所以使用的方式为：\n1 2 \u0026lt;action application=\u0026#34;transfer\u0026#34; data=\u0026#34;sip:1009@172.16.4.114:5060\u0026#34;/\u0026gt; \u0026lt;action application=\u0026#34;park\u0026#34;/\u0026gt; 交互流程 sequenceDiagram microSIP(A)-\u0026gt;\u0026gt; fs(172.16.4.111：5060): INVITE Note over microSIP(A),fs(172.16.4.111：5060): 拨打电话 fs(172.16.4.111：5060) --\u0026gt;\u0026gt; microSIP(A): 100 Trying fs(172.16.4.111：5080) -\u0026gt;\u0026gt; fs(172.16.4.114：5060): INVITE Note over fs(172.16.4.111：5080), fs(172.16.4.114：5060): To: \u0026lt;sip:1009@172.16.4.114：5060\u0026gt; fs(172.16.4.114：5060)--\u0026gt;\u0026gt; fs(172.16.4.111：5080): 100 Trying fs(172.16.4.114：5060)-\u0026gt;\u0026gt; microSIP(B): INVITE microSIP(B)--\u0026gt;\u0026gt;fs(172.16.4.114：5060): 100 Trying microSIP(B)-\u0026gt;\u0026gt;fs(172.16.4.114：5060): 180 Ringing fs(172.16.4.114：5060)-\u0026gt;\u0026gt;fs(172.16.4.111：5080): 183 Ringing fs(172.16.4.111：5060)-\u0026gt;\u0026gt;microSIP(A): 183 Ringing microSIP(B)-\u0026gt;\u0026gt;fs(172.16.4.114：5060): 200OK Note over microSIP(B),fs(172.16.4.114：5060): 通话接通 fs(172.16.4.114：5060)-\u0026gt;\u0026gt;fs(172.16.4.111：5080): 200OK fs(172.16.4.111：5060)-\u0026gt;\u0026gt; microSIP(A): 200OK microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.111：5060): ACK fs(172.16.4.111：5080)-\u0026gt;\u0026gt; fs(172.16.4.114：5060): ACK fs(172.16.4.114：5060)-\u0026gt;\u0026gt; microSIP(B): ACK microSIP(B)-\u0026gt;\u0026gt;fs(172.16.4.114：5060): BYE Note over microSIP(B),fs(172.16.4.114：5060): 通话结束 fs(172.16.4.114：5060)-\u0026gt;\u0026gt; fs(172.16.4.111：5080): BYE fs(172.16.4.111：5060)-\u0026gt;\u0026gt; microSIP(A): BYE microSIP(A)-\u0026gt;\u0026gt;fs(172.16.4.111：5060): ACK fs(172.16.4.111：5080)-\u0026gt;\u0026gt; fs(172.16.4.114：5060): ACK fs(172.16.4.114：5060)-\u0026gt;\u0026gt; microSIP(B): ACK 可以看到,transfer转人工时，不会挂断原来的通话。fs(172.16.4.111)上也能记录转人工录音。\n总结 未接通时, 可以使用redirect,transfer功能, 转人工。 接通时, 可以使用deflect,bridge, transfer功能, 转人工。 转人工可以录音的有：bridge, transfer，不能录音的有：deflect,redirect。 ","date":"2025-11-18T14:22:40+08:00","image":"https://QuincyGao.github.io/p/%E6%99%BA%E8%83%BD%E5%91%BC%E5%8F%AB%E7%B3%BB%E7%BB%9F-%E8%BD%AC%E4%BA%BA%E5%B7%A5/backup_hu9183126680795497223.jpg","permalink":"https://QuincyGao.github.io/p/%E6%99%BA%E8%83%BD%E5%91%BC%E5%8F%AB%E7%B3%BB%E7%BB%9F-%E8%BD%AC%E4%BA%BA%E5%B7%A5/","title":"智能呼叫系统-转人工"},{"content":"背景 最近在把服务改造成docker容器化，但是在压测中发现，使用docker stats查看容器情况，发现内存一直在增长， 但是使用ps -aux查看的RSS(实际物理内存)内存占用是固定的，没有增长。针对此问题，现记录一下排查过程。\n主机系统是CentOS 7.9.2009，docker版本是26.1.4。\n排查过程 基础知识 docker stats统计的是cgroup memory.usage_in_bytes,主要包括：\nRSS 程序未释放但是占用的虚拟内存(anonymous memory) Page Cache(文件缓存) Shmem(共享内存) tmpfs/overlayfs 缓冲区 Mapped文件 网络相关的buffer 内核为容器分配的内存 ps -aux查看的就是RSS(实际物理内存)。\n开始排查 查看容器的内存实际占用情况 1 cat /sys/fs/cgroup/memory/docker/\u0026lt;container_id\u0026gt;/memory.stat 需要注意的是container_id是完整的，不是缩写。 我们使用docker ps查看容器id时，默认显示的是缩写的id。\n第一次数据为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 cache 626470912 rss 32657408 rss_huge 20971520 mapped_file 0 swap 69632 pgpgin 232273 pgpgout 76463 pgfault 111370 pgmajfault 45 inactive_anon 26267648 active_anon 6389760 inactive_file 278405120 active_file 348065792 unevictable 0 hierarchical_memory_limit 9223372036854771712 hierarchical_memsw_limit 9223372036854771712 total_cache 626470912 total_rss 32657408 total_rss_huge 20971520 total_mapped_file 0 total_swap 69632 total_pgpgin 0 total_pgpgout 0 total_pgfault 0 total_pgmajfault 0 total_inactive_anon 26267648 total_active_anon 6389760 total_inactive_file 278405120 total_active_file 348065792 total_unevictable 0 第二次的数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 cache 667144192 rss 32940032 rss_huge 20971520 mapped_file 0 swap 69632 pgpgin 243250 pgpgout 77441 pgfault 113316 pgmajfault 45 inactive_anon 26267648 active_anon 6672384 inactive_file 291627008 active_file 375517184 unevictable 0 hierarchical_memory_limit 9223372036854771712 hierarchical_memsw_limit 9223372036854771712 total_cache 667144192 total_rss 32940032 total_rss_huge 20971520 total_mapped_file 0 total_swap 69632 total_pgpgin 0 total_pgpgout 0 total_pgfault 0 total_pgmajfault 0 total_inactive_anon 26267648 total_active_anon 6672384 total_inactive_file 291627008 total_active_file 375517184 total_unevictable 0 统计两次的差异为：\n字段 snapshot1 (MB) snapshot2 (MB) diff (MB) cache（缓存） 597.652 636.128 38.476 rss（常驻内存） 31.129 31.426 0.297 pgpgin（内存页读入次数） 0.222 0.232 0.010 pgpgout（内存页写出次数） 0.073 0.074 0.001 pgfault（缺页次数） 0.106 0.108 0.002 active_anon（匿名活跃页） 6.094 6.362 0.268 inactive_file（文件未活跃页） 265.583 278.000 12.417 active_file（文件活跃页） 331.942 358.000 26.058 total_cache（总缓存） 597.652 636.128 38.476 total_rss（总常驻内存） 31.129 31.426 0.297 total_active_anon（总匿名活跃） 6.094 6.362 0.268 total_inactive_file（总文件未活跃） 265.583 278.000 12.417 total_active_file（总文件活跃） 331.942 358.000 26.058 可以看到：\ncache/total_cache: 增长了38.476MB,\ninactive_file: 增长了12.417MB,\nactive_file: 增长了26.058MB,总共就38.476MB, 说明文件cache增多。\nrss/total_rss: 增长了0.297MB,可以忽略。\n这种 cache的增长原因是:容器内频繁访问文件,包括：\n日志文件 overlay2 文件层 配置文件 静态文件 访问volume 这个是正常情况，内核会在内存不足时,自动回收。\n但是内存一直增长不是正常现象，需要进一步排查原因。\n排查cache增长的原因 在主机上临时清除缓存:\n1 sync; echo 3 | sudo tee /proc/sys/vm/drop_caches 执行之后，可以发现docker stats会瞬间下降到RSS的大小。 因为我把日志挂载到了主机上, 基本可以确定是日志文件导致的cache增长。\n如何解决 原本是修改日志组件, 每次Write之后就Sync到磁盘, 但是改完之后效果不大，Page Cache还是会增长。\n采用的方案有两种:\n修改系统的内存回收机制： 1 2 3 4 5 /etc/sysctl.conf vm.dirty_ratio = 10 vm.dirty_background_ratio = 5 vm.dirty_expire_centisecs = 500 vm.dirty_writeback_centisecs = 100 sysctl -p 生效\n效果不太明显，增长的速度只是慢了一些，但是还是一直增长。\n是在docker-compose.yaml中添加mem_limit和mem_reservation参数, 限制容器内存占用: 1 2 3 4 5 6 deploy: resources: limits: memory: 40M reservations: memory: 20M 在测试中发现，设置的最大内存为40M,程序的RSS占用为37M, 当docker stats增长还没到40M时(大概35M)， 会主动回收Page Cache。导致docker stats的内存不会增长到40M。\n总结 当RSS的大小不增长时，可以认定服务是没有内存泄漏问题。 当Page Cache的大小增长时，这类就需要设置系统层面上的内存回收机制， 限制容器内存占用，让其自动回收。 ","date":"2025-11-14T09:40:38+08:00","image":"https://QuincyGao.github.io/p/docker%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E5%A2%9E%E9%95%BF%E6%8E%92%E6%9F%A5/backup_hu12812676196639185063.jpg","permalink":"https://QuincyGao.github.io/p/docker%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E5%A2%9E%E9%95%BF%E6%8E%92%E6%9F%A5/","title":"docker容器内存增长排查"},{"content":"freeswitch 旁路方案 目前旁路方案中，开源可用的有:mod_audio_stream, 这个模块是把用户语音流以ws的方式发送给服务端，服务端收到之后就可以进行ASR相关的识别。\nfreeswitch的版本为: 1.10.7,本次测试的mod_audio_stream版本是:\n1.0.3\n编译 下载mod_audio_stream模块 1 git clone https://github.com/amigniter/mod_audio_stream.git 编译mod_audio_stream模块 1 cd mod_audio_stream \u0026amp;\u0026amp; ./build-mod-audio-stream.sh 需要注意的是mod-audio-stream依赖libwsc,可以提前下载好。\n编译成功之后，会在mod-audio-stream/build目录下生成mod_audio_stream.so文件。\n安装mod_audio_stream模块 1 cp build/mod_audio_stream.so /usr/local/freeswitch/mod/ 只需要把mod_audio_stream.so文件复制到和freeswitch其他mod共同的路径下, 默认是:/usr/local/freeswitch/mod/。\n加载mod_audio_stream模块 在freeswitch的conf/autoload_configs/modules.conf.xml文件中添加如下内容:\n1 \u0026lt;load module=\u0026#34;mod_audio_stream\u0026#34;/\u0026gt; 这样就不用手动加载mod_audio_stream模块了。你如果想手动加载mod_audio_stream模块,可以使用如下命令:\n1 fs_cli -x \u0026#34;load mod_audio_stream\u0026#34; 测试 我使用的是esl,当呼入电话接通之后，执行:\n1 uuid_audio_stream \u0026lt;uuid\u0026gt; start ws://172.16.4.111:8080/ws mono 8k wsserver端代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gorilla/websocket\u0026#34; ) var upgrader = websocket.Upgrader{ CheckOrigin: func(r *http.Request) bool { return true // 允许所有跨域请求，生产环境应该更严格 }, } func handleWebSocket(w http.ResponseWriter, r *http.Request) { // 升级 HTTP 连接到 WebSocket conn, err := upgrader.Upgrade(w, r, nil) if err != nil { log.Printf(\u0026#34;升级 WebSocket 失败: %v\u0026#34;, err) return } defer conn.Close() log.Printf(\u0026#34;新的 WebSocket 连接已建立: %s\u0026#34;, r.RemoteAddr) // 设置读取超时 conn.SetReadDeadline(time.Now().Add(60 * time.Second)) conn.SetPongHandler(func(string) error { conn.SetReadDeadline(time.Now().Add(60 * time.Second)) return nil }) for { // 读取消息 messageType, message, err := conn.ReadMessage() if err != nil { if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) { log.Printf(\u0026#34;读取错误: %v\u0026#34;, err) } break } // 打印收到的内容 log.Printf(\u0026#34;收到来自 %s 的消息:\u0026#34;, r.RemoteAddr) log.Printf(\u0026#34; 消息类型: %d\u0026#34;, messageType) log.Printf(\u0026#34; 内容: %s\u0026#34;, string(message)) log.Printf(\u0026#34; 长度: %d 字节\u0026#34;, len(message)) log.Println(\u0026#34; ---\u0026#34;) } log.Printf(\u0026#34;WebSocket 连接已关闭: %s\u0026#34;, r.RemoteAddr) } func main() { http.HandleFunc(\u0026#34;/ws\u0026#34;, handleWebSocket) host := \u0026#34;172.16.4.111:8080\u0026#34; log.Printf(\u0026#34;WebSocket 服务器启动在 http://%s\u0026#34;, host) log.Printf(\u0026#34;WebSocket 端点: ws://%s/ws\u0026#34;, host) if err := http.ListenAndServe(host, nil); err != nil { log.Fatal(\u0026#34;服务器启动失败: \u0026#34;, err) } } 可以看到freeswitch的日志有报错connection error：\n1 2 3 4 5 6 2025-11-05 15:47:01.031389 54.17% [DEBUG] sofia.c:7499 Channel sofia/internal/1000@172.16.4.111 entering state [completed][200] 2025-11-05 15:47:01.031389 54.17% [DEBUG] mod_audio_stream.c:150 mod_audio_stream cmd: 622e69e4-cfcb-4a08-a9d7-fa45a9cefb88 start ws://172.16.4.111:8080/ws mono 8k 2025-11-05 15:47:01.031389 54.17% [DEBUG] mod_audio_stream.c:81 calling stream_session_init. 2025-11-05 15:47:01.051398 54.17% [INFO] audio_streamer_glue.cpp:170 connection error 2025-11-05 15:47:01.051398 54.17% [DEBUG] audio_streamer_glue.cpp:357 (622e69e4-cfcb-4a08-a9d7-fa45a9cefb88) no resampling needed for this call 2025-11-05 15:47:01.051398 54.17% [DEBUG] audio_streamer_glue.cpp:360 (622e69e4-cfcb-4a08-a9d7-fa45a9cefb88) stream_data_init 经过排查，问题是libwsc库的WebSocketClient.cpp的connect连接函数中，自动使用DNS解析。 我使用的是容器部署的，其容器内没有设置DNS解析，导致连接失败。解决方法有三种：\n在容器内执行echo \u0026quot;nameserver 8.8.8.8\u0026quot; \u0026gt;\u0026gt; /etc/resolv.conf。 修改libwsc库的WebSocketClient.cpp的connect连接函数，内evdns_base_new(base, 1);为evdns_base_new(base, 0);。 运行容器时, 添加--dns 8.8.8.8参数。 我使用的是--dns 8.8.8.8方法, 解决了问题。freeswitch的日志为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 2025-11-06 10:30:14.450220 53.23% [DEBUG] sofia.c:7499 Channel sofia/internal/1000@172.16.4.111 entering state [completed][200] EXECUTE [depth=0] sofia/internal/1000@172.16.4.111 park() 2025-11-06 10:30:14.470242 53.23% [DEBUG] mod_audio_stream.c:150 mod_audio_stream cmd: 174679ed-d156-4223-9940-81a92c93f3de start ws://172.16.4.111:8080/ws mono 8k 2025-11-06 10:30:14.470242 53.23% [DEBUG] mod_audio_stream.c:81 calling stream_session_init. 2025-11-06 10:30:14.470242 53.23% [DEBUG] audio_streamer_glue.cpp:357 (174679ed-d156-4223-9940-81a92c93f3de) no resampling needed for this call 2025-11-06 10:30:14.470242 53.23% [DEBUG] audio_streamer_glue.cpp:360 (174679ed-d156-4223-9940-81a92c93f3de) stream_data_init 2025-11-06 10:30:14.470242 53.23% [DEBUG] mod_audio_stream.c:87 adding bug. 2025-11-06 10:30:14.470242 53.23% [DEBUG] switch_core_media_bug.c:978 Attaching BUG to sofia/internal/1000@172.16.4.111 2025-11-06 10:30:14.470242 53.23% [DEBUG] mod_audio_stream.c:91 setting bug private data. 2025-11-06 10:30:14.470242 53.23% [DEBUG] mod_audio_stream.c:94 exiting start_capture. 2025-11-06 10:30:14.490223 53.23% [DEBUG] switch_rtp.c:7331 Correct audio RTCP ip/port confirmed. 2025-11-06 10:30:14.490223 53.23% [DEBUG] sofia.c:7499 Channel sofia/internal/1000@172.16.4.111 entering state [ready][200] 2025-11-06 10:30:14.510238 53.23% [DEBUG] switch_rtp.c:1982 rtcp_stats_init: audio ssrc[1139674539] base_seq[2624] 2025-11-06 10:30:14.550238 53.23% [DEBUG] switch_rtp.c:7934 Correct audio ip/port confirmed. 2025-11-06 10:30:14.550238 53.23% [DEBUG] switch_core_io.c:448 Setting BUG Codec PCMA:8 ws Server也收到了数据：\n1 2 3 4 5 6 7 8 025/11/06 10:30:22 收到来自 172.16.4.111:15173 的消息: 2025/11/06 10:30:22 消息类型: 2 �� ���� �� ���� �� ���� 2025/11/06 10:30:22 长度: 320 字节 2025/11/06 10:30:22 --- 2025/11/06 10:30:22 收到来自 172.16.4.111:15173 的消息: 2025/11/06 10:30:22 消息类型: 2 �� �� �� �� �� ����� �� 2025/11/06 10:30:22 长度: 320 字节 2025/11/06 10:30:22 --- 另外注意一点的是, mod_audio_stream也会产生EVENT事件,有以下几种:\n1 2 3 4 5 mod_audio_stream::json mod_audio_stream::connect mod_audio_stream::disconnect mod_audio_stream::error mod_audio_stream::play 这些事件是在EVENT:CUSTOM的body里, 示例：\nconnect(连接ws服务) 1 2 3 4 5 6 7 8 9 10 11 event: CUSTOM Event-Subclass: []string{\u0026#34;mod_audio_stream%3A%3Aconnect\u0026#34;} Core-Uuid: []string{\u0026#34;55191760-1543-4551-ae35-46c8579b88a3\u0026#34;} Unique-Id: []string{\u0026#34;310ec632-94a8-4985-915b-5126faeadc96\u0026#34;} Variable_number_alias: []string{\u0026#34;1000\u0026#34;} Variable_dtmf_type: []string{\u0026#34;rfc2833\u0026#34;} ... Event-Name: []string{\u0026#34;CUSTOM\u0026#34;} Content-Length: []string{\u0026#34;22\u0026#34;} Variable_event-Name: []string{\u0026#34;REQUEST_PARAMS\u0026#34;} {\u0026#34;status\u0026#34;:\u0026#34;connected\u0026#34;} disconnect(ws服务断开连接) 1 2 3 4 5 6 event: CUSTOM Variable_sip_network_port: []string{\u0026#34;62170\u0026#34;} Variable_local_media_port: []string{\u0026#34;26832\u0026#34;} Content-Length: []string{\u0026#34;84\u0026#34;} ... {\u0026#34;status\u0026#34;:\u0026#34;disconnected\u0026#34;,\u0026#34;message\u0026#34;:{\u0026#34;code\u0026#34;:1000,\u0026#34;reason\u0026#34;:\u0026#34;Connection closed (EOF)\u0026#34;}} error(ws服务连接断开之后产生此错误) 1 2 3 4 5 6 event: CUSTOM Event-Calling-File: []string{\u0026#34;mod_audio_stream.c\u0026#34;} Event-Name: []string{\u0026#34;CUSTOM\u0026#34;} Content-Length: []string{\u0026#34;68\u0026#34;} ... {\u0026#34;status\u0026#34;:\u0026#34;error\u0026#34;,\u0026#34;message\u0026#34;:{\u0026#34;code\u0026#34;:6,\u0026#34;error\u0026#34;:\u0026#34;Connection timeout\u0026#34;}} 总结 这种方案可以拿到用户的rtp数据，比较灵活对接asr,机器人语音流可以使用playbackor uuid_displace播放文件生成， 想要打断机器人话术直接就可以uuid_break uuid or uuid_displace uuid stop。\n按键(rfc2833/inbound)获取有两种方式：\nesl监听DTMF事件，这样就能获取按键。 解析用户rtp数据，根据rfc2833协议，按键数据在rtp的payload里，需要解析rtp数据，才能获取按键。 录音保存功能还是要freeswitch来做。\n","date":"2025-11-06T11:03:23+08:00","image":"https://QuincyGao.github.io/p/%E6%99%BA%E8%83%BD%E5%91%BC%E5%8F%AB%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88%E4%BA%8Cfreeswitch%E5%AA%92%E4%BD%93%E6%97%81%E8%B7%AF/backup_hu6964378442590903443.jpg","permalink":"https://QuincyGao.github.io/p/%E6%99%BA%E8%83%BD%E5%91%BC%E5%8F%AB%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88%E4%BA%8Cfreeswitch%E5%AA%92%E4%BD%93%E6%97%81%E8%B7%AF/","title":"智能呼叫系统方案二(freeswitch媒体旁路)"},{"content":"背景 freeswitch在做智能呼叫系统时，如何拿到用户的语音流是个难点，大体上会有三种方案：\nfreeswitch使用mrcp协议和unimrcp交互, unimrcp来集成对接asr/tts,esl还可用。 freeswitch使用media_bug把语音流旁路到业务服务,再把语音流发送到asr。 大部分公司使用的是这种方案, 只是具体的实现方式不太一样, esl还可用。 把freeswitch作为ua, 业务服务来实现uac(外呼)或者uas(呼入),这种需要自己实现sip交互, esl无法使用。这种更灵活，缺点是有点复杂，freeswitch的一些特性功能就没法用了。 智能呼叫系统一般都具有:打断(用户打断机器人或者机器人打断用户),按键,转人工等功能。\n本章介绍第一种方案, 使用esl方式查看这些功能的具体效果。freeswitch的官方文档\nfreeswitch版本为:\nVersion 1.10.7-release+git20211024T163933Z883d2cb662~64bit\n测试方法 freeswitch 呼入配置 1 2 3 4 5 6 7 conf/dialplan/default.xml \u0026lt;extension name=\u0026#34;88990\u0026#34;\u0026gt; \u0026lt;condition field=\u0026#34;destination_number\u0026#34; expression=\u0026#34;^88990$\u0026#34;\u0026gt; \u0026lt;action application=\u0026#34;answer\u0026#34;/\u0026gt; \u0026lt;action application=\u0026#34;park\u0026#34;/\u0026gt; \u0026lt;/condition\u0026gt; \u0026lt;/extension\u0026gt; 添加自己的mrcp服务conf/mrcp_profiles/sbc-asr.xml,sbc-tts.xml\n添加grammar文件grammar/ali.gram\n1 2 3 4 5 6 7 8 cat ali.gram #JSGF V1.0; grammar example; public \u0026lt;main\u0026gt; = [ \u0026lt;pre\u0026gt; ] ( \u0026lt;weather\u0026gt; {WEATHER} | \u0026lt;sports\u0026gt; {SPORTS} | \u0026lt;stocks\u0026gt; {STOCKS} ) ; \u0026lt;pre\u0026gt; = ( I would like [ to hear ] ) | ( hear ) | ( [ please ] get [ me ] ) | ( look up ); \u0026lt;weather\u0026gt; = [ the ] weather; \u0026lt;sports\u0026gt; = sports [ news ]; \u0026lt;stocks\u0026gt; = ( [ a ] stock ( quote | quotes ) ) | stocks; 使用esl方式连接freeswitch。\n软电话拨打88990。\ndetect_speech 用来识别用户的语音流, 并返回识别结果。使用方法主要有:\n1 2 3 4 5 6 7 8 9 10 11 detect_speech \u0026lt;mod_name\u0026gt; \u0026lt;gram_name\u0026gt; \u0026lt;gram_path\u0026gt; [\u0026lt;addr\u0026gt;] detect_speech grammar \u0026lt;gram_name\u0026gt; [\u0026lt;path\u0026gt;] detect_speech grammaron \u0026lt;gram_name\u0026gt; detect_speech grammaroff \u0026lt;gram_name\u0026gt; detect_speech grammarsalloff detect_speech nogrammar \u0026lt;gram_name\u0026gt; detect_speech param \u0026lt;name\u0026gt; \u0026lt;value\u0026gt; detect_speech pause detect_speech resume detect_speech start_input_timers detect_speech stop esl中的调用命令为detect_speech uuid unimrcp:sbc-asr {recognition-timeout=1000}ali default,uuid根据实际情况填写。\n可以看到相关的日志：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 EXECUTE [depth=1] sofia/internal/1000@172.16.4.111 detect_speech(unimrcp:sbc-asr {recognition-timeout=1000}ali default ) 2025-10-31 16:50:51.556688 59.43% [INFO] mod_unimrcp.c:3128 asr_handle: name = unimrcp, codec = (null), rate = 8000, grammar = (null), param = sbc-asr 2025-10-31 16:50:51.556688 59.43% [INFO] mod_unimrcp.c:3130 codec = L16, rate = 8000, dest = (null) 2025-10-31 16:50:51.556688 59.43% [NOTICE] mrcp_application.c:96 (ASR-26) Create MRCP Handle 0x7fac94029610 [sbc-asr] 2025-10-31 16:50:51.556688 59.43% [INFO] mrcp_client_session.c:133 (ASR-26) Create Channel ASR-26 \u0026lt;new\u0026gt; 2025-10-31 16:50:51.556688 59.43% [INFO] mrcp_client_session.c:387 (ASR-26) Receive App Request ASR-26 \u0026lt;new\u0026gt; [2] 2025-10-31 16:50:51.556688 59.43% [INFO] mrcp_client.c:700 (ASR-26) Add MRCP Handle ASR-26 \u0026lt;new\u0026gt; 2025-10-31 16:50:51.556688 59.43% [NOTICE] mrcp_client_session.c:719 (ASR-26) Add Control Channel ASR-26 \u0026lt;new@speechrecog\u0026gt; 2025-10-31 16:50:51.556688 59.43% [INFO] mrcp_client_session.c:411 (ASR-26) Send Offer ASR-26 \u0026lt;new\u0026gt; [c:1 a:1 v:0] to 172.16.7.240:8060 2025-10-31 16:50:51.556688 59.43% [INFO] mrcp_sofiasip_client_agent.c:354 (ASR-26) Local SDP ASR-26 \u0026lt;new\u0026gt; v=0 o=FreeSWITCH 0 0 IN IP4 172.16.4.111 s=- c=IN IP4 172.16.4.111 t=0 0 m=application 9 TCP/MRCPv2 1 a=setup:active a=connection:new a=resource:speechrecog a=cmid:1 m=audio 4004 RTP/AVP 0 8 96 a=rtpmap:0 PCMU/8000 a=rtpmap:8 PCMA/8000 a=rtpmap:96 L16/8000 a=sendonly a=ptime:20 a=mid:1 因为我在测试时asr有点问题，没有返回结果，正常情况下,读DETECTED_SPEECH事件，就可以看到识别结果。\ndetect_speech没法打断speak在播放的tts语音。\nspeak 调用mrcp把文本合成语音,并播发给用户。 esl的命令为:\n1 2 3 uuid_setvar uuid tts_engine unimrcp:sbc-tts (设置unimrcp) uuid_setvar uuid tts_voice EN (设置语言,非必须) speak uuid \u0026#34;welcome to unimrcp, thank you\u0026#34; (合成语音) 看到的日志为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 EXECUTE [depth=1] sofia/internal/1000@172.16.4.111 speak(welcome to unimrcp, thank you) 2025-10-31 17:07:22.516557 59.87% [INFO] mod_unimrcp.c:1625 speech_handle: name = unimrcp, rate = 8000, speed = 0, samples = 160, voice = , engine = unimrcp, param = sbc-tts 2025-10-31 17:07:22.516557 59.87% [INFO] mod_unimrcp.c:1628 voice = EN, rate = 8000 2025-10-31 17:07:22.516557 59.87% [NOTICE] mrcp_application.c:96 (TTS-27) Create MRCP Handle 0x7facec054130 [sbc-tts] 2025-10-31 17:07:22.516557 59.87% [INFO] mrcp_client_session.c:133 (TTS-27) Create Channel TTS-27 \u0026lt;new\u0026gt; 2025-10-31 17:07:22.516557 59.87% [INFO] mrcp_client_session.c:387 (TTS-27) Receive App Request TTS-27 \u0026lt;new\u0026gt; [2] 2025-10-31 17:07:22.516557 59.87% [INFO] mrcp_client.c:700 (TTS-27) Add MRCP Handle TTS-27 \u0026lt;new\u0026gt; 2025-10-31 17:07:22.516557 59.87% [NOTICE] mrcp_client_session.c:719 (TTS-27) Add Control Channel TTS-27 \u0026lt;new@speechsynth\u0026gt; 2025-10-31 17:07:22.536560 59.87% [INFO] mrcp_client_session.c:411 (TTS-27) Send Offer TTS-27 \u0026lt;new\u0026gt; [c:1 a:1 v:0] to 172.16.7.240:8060 2025-10-31 17:07:22.536560 59.87% [INFO] mrcp_sofiasip_client_agent.c:354 (TTS-27) Local SDP TTS-27 \u0026lt;new\u0026gt; v=0 o=FreeSWITCH 0 0 IN IP4 172.16.4.111 s=- c=IN IP4 172.16.4.111 t=0 0 m=application 9 TCP/MRCPv2 1 a=setup:active a=connection:new a=resource:speechsynth a=cmid:1 m=audio 4048 RTP/AVP 0 a=rtpmap:0 PCMU/8000 a=recvonly a=mid:1 2025-10-31 17:07:22.536560 59.87% [INFO] mrcp_sofiasip_client_agent.c:609 () Receive SIP Event [nua_i_state] Status 0 INVITE sent [sbc-tts] play_and_detect_speech 播放tts语音的同时，识别用户的语音流。可以打断tts的播放。\nlua的方法，可以参考这篇文章:用play_and_detect_speech实现人机语音交互的示例\nesl中的使用命令为：\n1 2 3 uuid_setvar uuid tts_engine unimrcp:sbc-tts (设置unimrcp) uuid_setvar uuid tts_voice EN (设置语言,非必须) play_and_detect_speech uuid say:welcome to unimrcp, thank you. detect:unimrcp:sbc-tts {start-input-timers=true,recognition-timeout=10000,no-input-timeout=30000,speech-complete-timeout=20000}ali 这种方法的打断机制有两种：\nunimrcp进行asr识别是返回了START-OF-INPUT事件，检测到用户说话。 unimrcp进行asr识别是返回了RECOGNIZE-COMPLETE事件,识别完成返回一句话。 经过测试发现，大部分都是START-OF-INPUT事件，太过敏感了，日志为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 2025-10-31 17:17:16.756586 57.40% [INFO] mrcp_client_session.c:500 (TTS-30) Raise App MRCP Response TTS-30 \u0026lt;a7f677acb63a11f0\u0026gt; 2025-10-31 17:17:18.916563 57.60% [INFO] mrcp_client_connection.c:635 () Receive MRCPv2 Data 172.16.4.111:43794 \u0026lt;-\u0026gt; 172.16.7.240:1544 [94 bytes] MRCP/2.0 94 START-OF-INPUT 2 IN-PROGRESS Channel-Identifier: a7d6756ab63a11f0@speechrecog 2025-10-31 17:17:18.916563 57.60% [INFO] mrcp_client_session.c:516 (ASR-29) Raise App MRCP Event ASR-29 \u0026lt;a7d6756ab63a11f0\u0026gt; 2025-10-31 17:17:18.956559 57.60% [INFO] switch_ivr_async.c:4834 (sofia/internal/1000@172.16.4.111) START OF SPEECH 2025-10-31 17:17:18.956559 57.60% [INFO] mrcp_client_session.c:392 (TTS-30) Receive App MRCP Request TTS-30 \u0026lt;a7f677acb63a11f0\u0026gt; 2025-10-31 17:17:18.956559 57.60% [INFO] mrcp_client_session.c:622 (TTS-30) Send MRCP Request TTS-30 \u0026lt;a7f677acb63a11f0@speechsynth\u0026gt; [2] 2025-10-31 17:17:18.956559 57.60% [INFO] mrcp_client_connection.c:530 (TTS-30) Send MRCPv2 Data 172.16.4.111:43794 \u0026lt;-\u0026gt; 172.16.7.240:1544 [72 bytes] MRCP/2.0 72 STOP 2 Channel-Identifier: a7f677acb63a11f0@speechsynth 2025-10-31 17:17:18.976561 57.60% [INFO] mrcp_client_connection.c:635 () Receive MRCPv2 Data 172.16.4.111:43794 \u0026lt;-\u0026gt; 172.16.7.240:1544 [108 bytes] MRCP/2.0 108 2 200 COMPLETE Channel-Identifier: a7f677acb63a11f0@speechsynth Active-Request-Id-List: 1 针对这种情况，有两种方法尝试：\n优化unimrcp中的语音检测的算法，我用了webrtc的噪声过滤，效果不太理想。 unimrcp去掉START-OF-INPUT,这样就只会在识别出用户的一句话之后才能打断。 也会有点问题，就是打断表现的会慢一些，因为要等用户说完一句话，才会返回识别结果。 方法可以参考：https://blog.csdn.net/qq1779062842/article/details/106471665 另外如果在此节点按键呢? 日志如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 2025-10-31 17:36:34.816860 58.40% [DEBUG] apt_consumer_task.c:141 () Wait for Messages [MRCP Client] 2025-10-31 17:36:34.816860 58.40% [DEBUG] switch_ivr_play_say.c:2817 Speaking text: Websocket server may return JSON object containing base64 encoded audio to be played by the user. 2025-10-31 17:36:34.856554 58.40% [DEBUG] switch_rtp.c:7934 Correct audio ip/port confirmed. 2025-10-31 17:36:34.856554 58.40% [DEBUG] switch_core_io.c:448 Setting BUG Codec PCMA:8 2025-10-31 17:36:34.876612 58.40% [DEBUG] switch_rtp.c:1982 rtcp_stats_init: audio ssrc[1321737180] base_seq[19527] 2025-10-31 17:36:38.056592 57.03% [DEBUG] switch_rtp.c:8179 RTP RECV DTMF 1:1600 2025-10-31 17:36:38.056592 57.03% [DEBUG] mod_unimrcp.c:3457 (ASR-33) Queued DTMF: 1 2025-10-31 17:36:38.056592 57.03% [INFO] switch_channel.c:527 RECV DTMF 1:1600 2025-10-31 17:36:38.056592 57.03% [DEBUG] switch_ivr_async.c:4862 (sofia/internal/1000@172.16.4.111) IGNORE NON-TERMINATOR DIGIT 1 2025-10-31 17:36:38.456573 57.00% [DEBUG] switch_rtp.c:8179 RTP RECV DTMF 2:1600 2025-10-31 17:36:38.456573 57.00% [DEBUG] mod_unimrcp.c:3457 (ASR-33) Queued DTMF: 2 2025-10-31 17:36:38.456573 57.00% [INFO] switch_channel.c:527 RECV DTMF 2:1600 2025-10-31 17:36:38.456573 57.00% [DEBUG] switch_ivr_async.c:4862 (sofia/internal/1000@172.16.4.111) IGNORE NON-TERMINATOR DIGIT 2 2025-10-31 17:36:38.956563 57.00% [DEBUG] switch_rtp.c:8179 RTP RECV DTMF 1:1600 2025-10-31 17:36:38.956563 57.00% [DEBUG] mod_unimrcp.c:3457 (ASR-33) Queued DTMF: 1 2025-10-31 17:36:38.956563 57.00% [INFO] switch_channel.c:527 RECV DTMF 1:1600 2025-10-31 17:36:38.956563 57.00% [DEBUG] switch_ivr_async.c:4862 (sofia/internal/1000@172.16.4.111) IGNORE NON-TERMINATOR DIGIT 1 2025-10-31 17:36:39.476560 57.13% [DEBUG] switch_rtp.c:8179 RTP RECV DTMF 2:1600 2025-10-31 17:36:39.476560 57.13% [DEBUG] mod_unimrcp.c:3457 (ASR-33) Queued DTMF: 2 2025-10-31 17:36:39.476560 57.13% [INFO] switch_channel.c:527 RECV DTMF 2:1600 2025-10-31 17:36:39.476560 57.13% [DEBUG] switch_ivr_async.c:4862 (sofia/internal/1000@172.16.4.111) IGNORE NON-TERMINATOR DIGIT 2 可以看到能收到按键，但是无法打断。有报：IGNORE NON-TERMINATOR DIGIT意思是没有设置终止符而忽略了按键,这样设置还是没解决此问题：\n1 play_and_detect_speech uuid say:welcome to unimrcp, thank you. detect:unimrcp:sbc-tts {start-input-timers=true,recognition-timeout=10000,no-input-timeout=30000,speech-complete-timeout=20000}builtin:dtmf/digits?length=4\u0026amp;terminators=#\u0026amp;interdigit-timeout=3000 play_and_get_digits 这个是专门用来收集按键的方法。用法参数：\n1 \u0026lt;min\u0026gt; \u0026lt;max\u0026gt; \u0026lt;tries\u0026gt; \u0026lt;timeout\u0026gt; \u0026lt;terminators\u0026gt; \u0026lt;file\u0026gt; \u0026lt;invalid_file\u0026gt; [\u0026lt;var_name\u0026gt; [\u0026lt;regexp\u0026gt; [\u0026lt;digit_timeout\u0026gt; [\u0026lt;transfer_on_failure\u0026gt;]]]] 该功能只能播放音频文件，不能调用mrcp来生成语音流。\n播放文件是使用示例为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;extension name=\u0026#34;collect_digits\u0026#34;\u0026gt; \u0026lt;condition field=\u0026#34;destination_number\u0026#34; expression=\u0026#34;^5000$\u0026#34;\u0026gt; \u0026lt;action application=\u0026#34;answer\u0026#34;/\u0026gt; \u0026lt;action application=\u0026#34;sleep\u0026#34; data=\u0026#34;1000\u0026#34;/\u0026gt; \u0026lt;action application=\u0026#34;play_and_get_digits\u0026#34; data=\u0026#34;1 4 3 5000 # ivr/8000/ivr-enter_source_telephone_number.wav ivr/8000/ivr-invalid_extension_try_again.wav user_input ^[0-9]+$ 3000\u0026#34;/\u0026gt; \u0026lt;action application=\u0026#34;log\u0026#34; data=\u0026#34;INFO User entered: ${user_input}\u0026#34;/\u0026gt; \u0026lt;!-- 跳转到下一个处理扩展 --\u0026gt; \u0026lt;action application=\u0026#34;transfer\u0026#34; data=\u0026#34;${user_input} XML default\u0026#34;/\u0026gt; \u0026lt;/conition\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;!-- 定义分支 --\u0026gt; \u0026lt;extension name=\u0026#34;ivr_option_1\u0026#34;\u0026gt; \u0026lt;condition field=\u0026#34;destination_number\u0026#34; expression=\u0026#34;^1$\u0026#34;\u0026gt; \u0026lt;action application=\u0026#34;transfer\u0026#34; data=\u0026#34;1002 XML default\u0026#34;/\u0026gt; \u0026lt;/condition\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension name=\u0026#34;ivr_option_2\u0026#34;\u0026gt; \u0026lt;condition field=\u0026#34;destination_number\u0026#34; expression=\u0026#34;^2$\u0026#34;\u0026gt; \u0026lt;action application=\u0026#34;playback\u0026#34; data=\u0026#34;ivr/8000/ivr-your_caller_id_information_is.wav\u0026#34;/\u0026gt; \u0026lt;/condition\u0026gt; \u0026lt;/extension\u0026gt; 该模块功能为按键1，拨打1002，按键2，播放语音ivr/8000/ivr-your_caller_id_information_is.wav。\n按1转1002坐席的实际测试的日志为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 EXECUTE [depth=0] sofia/internal/1000@172.16.4.111 play_and_get_digits(1 4 3 5000 # ivr/8000/ivr-enter_source_telephone_number.wav ivr/8000/ivr-invalid_extension_try_again.wav user_input ^[0-9]+$ 3000) 2025-11-04 14:35:35.867339 55.97% [INFO] switch_channel.c:527 RECV DTMF 1:1600 2025-11-04 14:35:36.947328 55.83% [INFO] switch_channel.c:527 RECV DTMF #:1600 EXECUTE [depth=0] sofia/internal/1000@172.16.4.111 log(INFO User entered: 1) 2025-11-04 14:35:36.947328 55.83% [INFO] mod_dptools.c:1879 User entered: 1 EXECUTE [depth=0] sofia/internal/1000@172.16.4.111 transfer(1 XML default) 2025-11-04 14:35:36.947328 55.83% [NOTICE] switch_ivr.c:2296 Transfer sofia/internal/1000@172.16.4.111 to XML[1@default] 2025-11-04 14:35:36.947328 55.83% [INFO] mod_dialplan_xml.c:639 Processing 1000 \u0026lt;1000\u0026gt;-\u0026gt;1 in context default EXECUTE [depth=0] sofia/internal/1000@172.16.4.111 set(open=true) EXECUTE [depth=0] sofia/internal/1000@172.16.4.111 transfer(1002 XML default) 2025-11-04 14:35:36.947328 55.83% [NOTICE] switch_ivr.c:2296 Transfer sofia/internal/1000@172.16.4.111 to XML[1002@default] 2025-11-04 14:35:36.947328 55.83% [INFO] mod_dialplan_xml.c:639 Processing 1000 \u0026lt;1000\u0026gt;-\u0026gt;1002 in context default EXECUTE [depth=0] sofia/internal/1000@172.16.4.111 set(open=true) EXECUTE [depth=0] sofia/internal/1000@172.16.4.111 export(dialed_extension=1002) 另外也可以接收多个按键，例如：123#,日志为:\n1 2 3 4 5 6 7 EXECUTE [depth=0] sofia/internal/1000@172.16.4.111 play_and_get_digits(1 4 3 5000 # ivr/8000/ivr-enter_source_telephone_number.wav ivr/8000/ivr-invalid_extension_try_again.wav user_input ^[0-9]+$ 3000) 2025-11-04 14:37:05.347863 56.50% [INFO] switch_channel.c:527 RECV DTMF 1:1600 2025-11-04 14:37:05.747320 56.50% [INFO] switch_channel.c:527 RECV DTMF 2:1600 2025-11-04 14:37:06.167313 56.53% [INFO] switch_channel.c:527 RECV DTMF 3:1600 2025-11-04 14:37:06.847320 56.27% [INFO] switch_channel.c:527 RECV DTMF 4:1600 EXECUTE [depth=0] sofia/internal/1000@172.16.4.111 log(INFO User entered: 1234) 2025-11-04 14:37:06.847320 56.27% [INFO] mod_dptools.c:1879 User entered: 1234 总结 本章我们介绍了使用mrcp场景下的打断和按键收集功能。 如果不对源码修改，实际体验上效果远远达不到实用需求。\n","date":"2025-10-31T09:42:30+08:00","image":"https://QuincyGao.github.io/p/%E6%99%BA%E8%83%BD%E5%91%BC%E5%8F%AB%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88%E4%B8%80mrcp%E4%BD%BF%E7%94%A8/backup_hu5314482234048211886.jpg","permalink":"https://QuincyGao.github.io/p/%E6%99%BA%E8%83%BD%E5%91%BC%E5%8F%AB%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88%E4%B8%80mrcp%E4%BD%BF%E7%94%A8/","title":"智能呼叫系统方案一(mrcp使用)"},{"content":"背景 上篇我们介绍了keepalived的配置，但是有一个问题,keepalived 默认是抢占模式, 当主宕机之后再重启，虚拟ip会切回主，此时会有波动，影响业务。是否有什么办法可以避免这种情况？\n我们可以配置成非抢占模式，当主宕机之后，虚拟ip不会切回主，而是保持在从节点上, 直到从节点宕机，才会切换到主节点。\n配置示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 ! Configuration File for keepalived global_defs { # notification_email { # acassen@firewall.loc # failover@firewall.loc # sysadmin@firewall.loc # } # notification_email_from Alexandre.Cassen@firewall.loc # smtp_server 192.168.200.1 # smtp_connect_timeout 30 router_id LVS_DEVEL vrrp_skip_check_adv_addr max_auto_priority 99 enable_script_security script_user root # vrrp_strict } vrrp_instance VI_1 { state BACKUP interface ens160 virtual_router_id 52 priority 100 advert_int 1 nopreempt authentication { auth_type PASS auth_pass testuser } virtual_ipaddress { 172.16.4.96 dev ens160 } notify_fault \u0026#34;/data/scripts/vip_down.sh\u0026#34; notify_stop \u0026#34;/data/scripts/vip_down.sh\u0026#34; # Allow packets addressed to the VIPs above to be received #accept } 只需要nopreempt添加到vrrp_instance 中，另外主备节点的状态都为BACKUP, 就可以实现非抢占模式。\n当两个节点都是BACKUP状态，哪个节点先启动(一般会选择priority高的节点)，虚拟ip就会分配给哪个节点。它就是主节点,另外一个是备节点。\n当主节点状态配置成MASTER,那么nopreempt参数就不会生效。日志中会有如下警告：\n1 (VI_1) Warning - nopreempt will not work with initial state MASTER - clearing nopreempt flag 测试 还是使用上一章节的测试环境，先启动172.16.4.111节点，然后再启动172.16.4.113节点, 可以看到虚拟ip172.16.4.96分配给了172.16.4.111节点。\n172.16.4.111节点的网卡 1 2 3 4 5 6 7 8 2: ens160: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:50:56:83:b9:d7 brd ff:ff:ff:ff:ff:ff inet 172.16.4.111/22 brd 172.16.7.255 scope global noprefixroute ens160 valid_lft forever preferred_lft forever inet 172.16.4.96/32 scope global ens160 valid_lft forever preferred_lft forever inet6 fe80::e194:8abe:9eb7:bb02/64 scope link noprefixroute valid_lft forever preferred_lft forever 172.16.4.113节点的网卡 1 2 3 4 5 6 2: ens160: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:50:56:83:0e:04 brd ff:ff:ff:ff:ff:ff inet 172.16.4.113/22 brd 172.16.7.255 scope global noprefixroute ens160 valid_lft forever preferred_lft forever inet6 fe80::45a0:3144:4cf8:fb8d/64 scope link noprefixroute valid_lft forever preferred_lft forever 172.16.4.111节点停止keepalived容器之后，虚拟ip172.16.4.96切到了172.16.4.113节点。\n172.16.4.113节点的网卡 1 2 3 4 5 6 7 8 2: ens160: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:50:56:83:0e:04 brd ff:ff:ff:ff:ff:ff inet 172.16.4.113/22 brd 172.16.7.255 scope global noprefixroute ens160 valid_lft forever preferred_lft forever inet 172.16.4.96/32 scope global ens160 valid_lft forever preferred_lft forever inet6 fe80::45a0:3144:4cf8:fb8d/64 scope link noprefixroute valid_lft forever preferred_lft forever 172.16.4.111节点的网卡 1 2 3 4 5 6 2: ens160: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:50:56:83:b9:d7 brd ff:ff:ff:ff:ff:ff inet 172.16.4.111/22 brd 172.16.7.255 scope global noprefixroute ens160 valid_lft forever preferred_lft forever inet6 fe80::e194:8abe:9eb7:bb02/64 scope link noprefixroute valid_lft forever preferred_lft forever 然后再启动172.16.4.111节点的keepalived，虚拟ip172.16.4.96还是在172.16.4.113节点。\n172.16.4.111节点的网卡 1 2 3 4 5 6 2: ens160: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:50:56:83:b9:d7 brd ff:ff:ff:ff:ff:ff inet 172.16.4.111/22 brd 172.16.7.255 scope global noprefixroute ens160 valid_lft forever preferred_lft forever inet6 fe80::e194:8abe:9eb7:bb02/64 scope link noprefixroute valid_lft forever preferred_lft forever 172.16.4.113节点的网卡 1 2 3 4 5 6 7 8 2: ens160: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:50:56:83:0e:04 brd ff:ff:ff:ff:ff:ff inet 172.16.4.113/22 brd 172.16.7.255 scope global noprefixroute ens160 valid_lft forever preferred_lft forever inet 172.16.4.96/32 scope global ens160 valid_lft forever preferred_lft forever inet6 fe80::45a0:3144:4cf8:fb8d/64 scope link noprefixroute valid_lft forever preferred_lft forever 可以看到，结果和预期一致。\n其他 当我们想看两个节点的交互情况时，可以抓包查看tcpdump -n -i ens160 vrrp。\n1 2 3 4 5 6 7 8 9 tcpdump -n -i ens160 vrrp tcpdump: verbose output suppressed, use -v or -vv for full protocol decode listening on ens160, link-type EN10MB (Ethernet), capture size 262144 bytes 16:40:43.218290 IP 172.16.7.138 \u0026gt; 224.0.0.18: VRRPv2, Advertisement, vrid 53, prio 91, authtype simple, intvl 1s, length 20 16:40:43.241397 IP 172.16.4.139 \u0026gt; 224.0.0.18: VRRPv2, Advertisement, vrid 77, prio 150, authtype simple, intvl 1s, length 20 16:40:43.399091 IP 172.16.7.82 \u0026gt; 224.0.0.18: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20 16:40:43.941014 IP 172.16.4.113 \u0026gt; 224.0.0.18: VRRPv2, Advertisement, vrid 52, prio 90, authtype simple, intvl 1s, length 20 16:40:44.218608 IP 172.16.7.138 \u0026gt; 224.0.0.18: VRRPv2, Advertisement, vrid 53, prio 91, authtype simple, intvl 1s, length 20 16:40:44.241604 IP 172.16.4.139 \u0026gt; 224.0.0.18: VRRPv2, Advertisement, vrid 77, prio 150, authtype simple, intvl 1s, length 20 可以看到在整个局域网内，有很多其他的节点也在发送VRRP广播包。想要不和其他的节点混淆，设置virtual_router_id要不一样。\n总结 两个节点都为BACKUP状态，并且添加nopreempt参数，可以实现非抢占模式。 virtual_router_id 要自己设置一下，避免使用默认的，以免和其他的节点混淆。 ","date":"2025-10-20T15:49:33+08:00","image":"https://QuincyGao.github.io/p/keepalived%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9Fip%E8%A1%A5%E5%85%85/backup_hu13337676285305420874.jpg","permalink":"https://QuincyGao.github.io/p/keepalived%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9Fip%E8%A1%A5%E5%85%85/","title":"keepalived配置虚拟ip补充"},{"content":"背景 不管是什么业务服务，当需要做主备方案时，一般都会采用keepalived的虚拟ip方式来切换。\n本章采用容器部署方式，不检查业务服务是否正常，主服务器宕机或者停止keepalived容器来切换虚拟ip到备用机器上。\nkeepalived的版本信息:\n2.3.1\n容器镜像制作 我使用centos7.9做基础镜像,源码编译keepalived, dockerfile如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 FROM centos:centos7 WORKDIR /data COPY . . # RUN yum makecache -y \u0026amp;\u0026amp; yum clean all -y RUN cp ./third-package/CentOS-Base-amd64.repo /etc/yum.repos.d/CentOS-Base.repo -f \u0026amp;\u0026amp; yum makecache -y \u0026amp;\u0026amp; yum clean all -y RUN yum install -y epel-release \u0026amp;\u0026amp; yum -y update \u0026amp;\u0026amp; yum install -y net-tools vim nginx gcc openssl-devel popt-devel rsyslog gettext nc libnl3 libnl3-devel autoconf libtool RUN cd third-package \u0026amp;\u0026amp; tar -zxvf automake-1.16.5.tar.gz \u0026amp;\u0026amp; cd automake-1.16.5 \u0026amp;\u0026amp; ./configure \\ \u0026amp;\u0026amp; make -j $(nproc) all \u0026amp;\u0026amp; make install -j $(nproc) \\ \u0026amp;\u0026amp; cd .. \u0026amp;\u0026amp; rm automake-1.16.5 automake-1.16.5.tar.gz -rf RUN cd keepalived-2.3.1 \u0026amp;\u0026amp; ./configure --prefix=/usr/local/keepalived \u0026amp;\u0026amp; make -j $(nproc) all \u0026amp;\u0026amp; make install -j $(nproc) RUN cp keepalived-2.3.1/keepalived/etc/init.d/keepalived /etc/init.d/ \u0026amp;\u0026amp;\\ cp /usr/local/keepalived/sbin/keepalived /usr/sbin/ \u0026amp;\u0026amp; \\ chmod +x /data/scripts/*.sh \u0026amp;\u0026amp; \\ find . -mindepth 1 ! -path \u0026#34;./scripts\u0026#34; ! -path \u0026#34;./scripts/*\u0026#34; ! -name \u0026#34;entrypoint.sh\u0026#34; ! -path \u0026#34;./conf\u0026#34; ! -path \u0026#34;./conf/*\u0026#34; -exec rm -rv {} + || true ENTRYPOINT [ \u0026#34;./entrypoint.sh\u0026#34; ] 可以看到，要下载CentOS-Base-amd64.repo(阿里云镜像源)和automake-1.16.5.tar.gz。\nscripts目录下有:vip_down.sh,vip_up.sh, vip_down.sh 1 2 3 4 #!/bin/bash LOG_OUT=\u0026#34;/proc/1/fd/1\u0026#34; ip addr del $VIP echo \u0026#34;$(date \u0026#39;+%F %T\u0026#39;) $VIP down............\u0026#34; \u0026gt;\u0026gt; \u0026#34;$LOG_OUT\u0026#34; vip_up.sh 1 2 3 4 #!/bin/bash LOG_OUT=\u0026#34;/proc/1/fd/1\u0026#34; ip addr add $VIP echo \u0026#34;$(date \u0026#39;+%F %T\u0026#39;) $VIP up.............\u0026#34; \u0026gt;\u0026gt; \u0026#34;$LOG_OUT\u0026#34; 这里要注意的是: \u0026gt;\u0026gt; $LOG_OUT 是将输出追加到/proc/1/fd/1文件中，这个文件是docker容器的标准输出文件。 如果没有这个，echo的输出内容在docker logs -f keepalived下是看不到的。\nentrypoint.sh 1 2 3 4 5 6 7 8 start_service(){ envsubst \u0026lt; ./conf/keepalived.conf.tpl \u0026gt; ./conf/keepalived.conf echo \u0026#34;run keepalived....\u0026#34; exec keepalived -f ./conf/keepalived.conf -n -l -D -S 0 echo \u0026#34;run done....\u0026#34; } start_service exec 很重要，这样能保证keepalived进程在容器内以pid为1的方式运行，后续docker-compose down时，会发送SIGTERM信号给keepalived进程， 而keepalived进程收到信号后，会先执行notify_stop脚本，然后再退出。\n如果没有exec,直接keepalived -f ./conf/keepalived.conf -n -l -D -S 0, keepalived的进程就不会捕获到 SIGTERM信号。\n./conf/keepalived.conf.tpl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ! Configuration File for keepalived global_defs { # notification_email { # acassen@firewall.loc # failover@firewall.loc # sysadmin@firewall.loc # } # notification_email_from Alexandre.Cassen@firewall.loc # smtp_server 192.168.200.1 # smtp_connect_timeout 30 router_id LVS_DEVEL vrrp_skip_check_adv_addr # vrrp_strict } vrrp_instance VI_1 { state $STATE interface $INTERFACE virtual_router_id $ROUTE_ID priority $PRIORITY advert_int 1 authentication { auth_type PASS auth_pass testuser } virtual_ipaddress { $VIP } notify_master \u0026#34;/data/scripts/vip_up.sh\u0026#34; notify_backup \u0026#34;/data/scripts/vip_down.sh\u0026#34; notify_fault \u0026#34;/data/scripts/vip_down.sh\u0026#34; notify_stop \u0026#34;/data/scripts/vip_down.sh\u0026#34; # Allow packets addressed to the VIPs above to be received #accept } 这里通过notify_master,notify_backup,notify_fault,notify_stop来调用vip_up.sh,vip_down.sh脚本主动添加/删除虚拟ip\ndocker-compose.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 x-defaults: \u0026amp;defaults restart: unless-stopped environment: - TZ=Asia/Shanghai # 主备:MASTER/BACKUP - STATE=MASTER # 网卡名 - INTERFACE=eth0 # 优先级: master必须比mackup大，两者差小于20 - PRIORITY=100 # 监听时间间隔 - INTERVAL=3 # route_id - ROUTE_ID=52 # 虚拟ip: 和实际ip在同一个网段内 - VIP=172.16.0.250 dev eth0 services: keepalived: image: keepalived:1.0.0 container_name: \u0026#34;keepalived\u0026#34; hostname: \u0026#34;keepalived\u0026#34; network_mode: \u0026#34;host\u0026#34; privileged: true cap_add: - NET_ADMIN stop_signal: SIGTERM \u0026lt;\u0026lt;: *defaults 这里注意的是:cap_add, stop_signal,这样在docker-compose down时，发送SIGTERM信号给keepalived进程。\n主备测试 1 2 3 主服务器ip: 172.16.4.111 备服务器ip: 172.16.4.113 虚拟ip: 172.16.4.96 此时主服务器的docker-compose.yaml的配置为:\n1 2 3 4 5 6 7 8 9 environment: - TZ=Asia/Shanghai - STATE=MASTER # 网卡名 - INTERFACE=ens160 - PRIORITY=100 - INTERVAL=6 - ROUTE_ID=52 - VIP=172.16.4.96 dev ens160 备服务器的docker-compose.yaml的配置为:\n1 2 3 4 5 6 7 8 9 environment: - TZ=Asia/Shanghai - STATE=BACKUP # 网卡名 - INTERFACE=ens160 - PRIORITY=90 - INTERVAL=6 - ROUTE_ID=52 - VIP=172.16.4.96 dev ens160 正常启动 主备服务器上keepalived容器运行之后, 可以看到主服务器上有172.16.4.96这个虚拟ip, 而备服务器上没有。\n主服务器网卡: ens160\n1 2 3 4 5 6 7 8 9 ip addr show ens160 2: ens160: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:50:56:83:b9:d7 brd ff:ff:ff:ff:ff:ff inet 172.16.4.111/22 brd 172.16.7.255 scope global noprefixroute ens160 valid_lft forever preferred_lft forever inet 172.16.4.96/32 scope global ens160 valid_lft forever preferred_lft forever inet6 fe80::e194:8abe:9eb7:bb02/64 scope link noprefixroute valid_lft forever preferred_lft forev 主服务器上的keepalived的docker logs -f keepalived日志为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ue Oct 14 16:00:22 2025: Assigned address 172.16.4.111 for interface ens160 Tue Oct 14 16:00:22 2025: Assigned address fe80::e194:8abe:9eb7:bb02 for interface ens160 Tue Oct 14 16:00:22 2025: Warning - script chk_web_service is not used Tue Oct 14 16:00:22 2025: Registering gratuitous ARP shared channel Tue Oct 14 16:00:22 2025: (VI_1) removing VIPs. Tue Oct 14 16:00:22 2025: Startup complete Tue Oct 14 16:00:22 2025: (VI_1) Entering BACKUP STATE (init) Tue Oct 14 16:00:22 2025: VRRP sockpool: [ifindex( 2), family(IPv4), proto(112), fd(11,12) multicast, address(224.0.0.18)] 2025-10-14 16:00:22 172.16.4.96 dev ens160 down............ Tue Oct 14 16:00:22 2025: (VI_1) received lower priority (90) advert from 172.16.4.113 - discarding Tue Oct 14 16:00:23 2025: (VI_1) received lower priority (90) advert from 172.16.4.113 - discarding Tue Oct 14 16:00:24 2025: (VI_1) received lower priority (90) advert from 172.16.4.113 - discarding Tue Oct 14 16:00:25 2025: (VI_1) received lower priority (90) advert from 172.16.4.113 - discarding Tue Oct 14 16:00:25 2025: (VI_1) Receive advertisement timeout Tue Oct 14 16:00:25 2025: (VI_1) Entering MASTER STATE Tue Oct 14 16:00:25 2025: (VI_1) setting VIPs. Tue Oct 14 16:00:25 2025: (VI_1) Sending/queueing gratuitous ARPs on ens160 for 172.16.4.96 Tue Oct 14 16:00:25 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:00:25 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:00:25 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:00:25 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:00:25 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 2025-10-14 16:00:25 172.16.4.96 dev ens160 up............. Tue Oct 14 16:00:30 2025: (VI_1) Sending/queueing gratuitous ARPs on ens160 for 172.16.4.96 Tue Oct 14 16:00:30 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:00:30 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:00:30 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:00:30 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:00:30 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 备服务器网卡: ens160\n1 2 3 4 5 6 7 ip addr show ens160 2: ens160: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:50:56:83:0e:04 brd ff:ff:ff:ff:ff:ff inet 172.16.4.113/22 brd 172.16.7.255 scope global noprefixroute ens160 valid_lft forever preferred_lft forever inet6 fe80::45a0:3144:4cf8:fb8d/64 scope link noprefixroute valid_lft forever preferred_lft forever 可以看到主服务器上有172.16.4.96这个虚拟ip, 而备服务器上没有,运行ok。\n主服务器上keepalived容器停止 docker-compose down手动停止主服务器上的keepalived容器,其日志为:\n1 2 3 4 5 6 7 ue Oct 14 16:14:09 2025: Stopping Tue Oct 14 16:14:09 2025: (VI_1) sent 0 priority Tue Oct 14 16:14:09 2025: (VI_1) removing VIPs. 2025-10-14 16:14:09 172.16.4.96 dev ens160 down............ Tue Oct 14 16:14:10 2025: Stopped - used (self/children) 0.047189/0.011739 user time, 0.151771/0.008893 system time Tue Oct 14 16:14:10 2025: CPU usage (self/children) user: 0.005198/0.069158 system: 0.022745/0.163343 Tue Oct 14 16:14:10 2025: Stopped Keepalived v2.3.1 (05/24,2024 可以看到 执行了vip_down.sh脚本,删除了虚拟ip, 主服务器网卡ens160上没有172.16.4.96这个ip了。\n1 2 3 4 5 6 7 ip addr show ens160 2: ens160: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:50:56:83:b9:d7 brd ff:ff:ff:ff:ff:ff inet 172.16.4.111/22 brd 172.16.7.255 scope global noprefixroute ens160 valid_lft forever preferred_lft forever inet6 fe80::e194:8abe:9eb7:bb02/64 scope link noprefixroute valid_lft forever preferred_lft forever 备服务器的keepalived日志为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Oct 14 16:08:56 2025: (VI_1) Receive advertisement timeout Tue Oct 14 16:08:56 2025: (VI_1) Entering MASTER STATE Tue Oct 14 16:08:56 2025: (VI_1) setting VIPs. Tue Oct 14 16:08:56 2025: (VI_1) Sending/queueing gratuitous ARPs on ens160 for 172.16.4.96 Tue Oct 14 16:08:56 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:08:56 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:08:56 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:08:56 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:08:56 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 2025-10-14 16:08:56 172.16.4.96 dev ens160 up............. Tue Oct 14 16:09:01 2025: (VI_1) Sending/queueing gratuitous ARPs on ens160 for 172.16.4.96 Tue Oct 14 16:09:01 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:09:01 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:09:01 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:09:01 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 Tue Oct 14 16:09:01 2025: Sending gratuitous ARP on ens160 for 172.16.4.96 查看备服务器网卡ens160上是否有172.16.4.96这个ip\n1 2 3 4 5 6 7 8 9 ip addr show ens160 2: ens160: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:50:56:83:0e:04 brd ff:ff:ff:ff:ff:ff inet 172.16.4.113/22 brd 172.16.7.255 scope global noprefixroute ens160 valid_lft forever preferred_lft forever inet 172.16.4.96/32 scope global ens160 valid_lft forever preferred_lft forever inet6 fe80::45a0:3144:4cf8:fb8d/64 scope link noprefixroute valid_lft forever preferred_lft forever 备服务器上有172.16.4.96这个虚拟ip, 主服务器上没有此ip, 说明虚拟ip切换ok。\n总结 当keepalived使用容器部署时，如果想要监听业务服务，通过业务服务的异常来切换主备服务器， 需要在keepalived的配置文件中添加track_script项，指定监听的业务服务。 因为容器是独立运行的，所以不能使用ps -aux|grep xxx来判断业务服务是否异常,可以检查tcp/udp/http端口来判断。\n不想监听业务服务时，就可以采用上述方式。\n如果keepalived的配置中不使用notify_stop这样的钩子，当主服务器keepalived容器停止时，网卡不会删除虚拟ip, 备服务器网卡也有虚拟ip，请求还是会到主服务器上。 但是如果主服务器宕机, 那么就不会有这样的问题。\nlinux的内核参数配置/etc/sysctl.conf里net.ipv4.ip_nonlocal_bind=1。\n","date":"2025-10-14T09:01:49+08:00","image":"https://QuincyGao.github.io/p/keepalived-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9Fip/backup_hu1572684056159187416.jpg","permalink":"https://QuincyGao.github.io/p/keepalived-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9Fip/","title":"keepalived 配置虚拟ip"},{"content":"背景 前面我们介绍了stun,turn相关的协议， 本章节来介绍实现了这两个协议的coturn服务。\ncoturn是一个开源的turn服务器， 支持stun和turn协议。代码地址\n本次测试coturn的版本为: 4.7.0\n部署 使用docker来部署coturn服务, 因为还有管理平台，所以需要:\n数据库: mysql 域名,nginx证书: 因为使用tls来访问, 所以需要有一个域名, 并配置好证书。 拉取coturn的镜像\n1 docker pull coturn/coturn:4.7.0 运行coturn容器\n因为会修改turnserver.conf, 所以需要挂载turnserver.conf到容器中。\n1 docker run -d -v /home/data/coturn-docker/log/:/var/tmp/ -v /home/data/coturn-docker/turnserver.conf:/etc/coturn/turnserver.conf -v /home/data/coturn-docker/tls:/etc/ssl/tls --network=host --user=root --privileged=true --restart=always --name coturn coturn/coturn:4.7.0 验证coturn服务是否运行\n1 docker logs coturn 可以看到类似如下的日志:\n1 2 3 4 5 6 7 8 0: (1): INFO: System cpu num is 8 0: (1): INFO: System cpu num is 8 0: (1): INFO: System enable num is 8 0: (1): INFO: Listener address to use: 172.16.4.113 0: (1): INFO: Coturn Version Coturn-4.7.0 \u0026#39;Gorst\u0026#39; 0: (1): INFO: Max number of open files/sockets allowed for this process: 4096 0: (1): INFO: Due to the open files/sockets limitation, max supported number of TURN Sessions possible is: 2000 (approximately) 0: (1): INFO: 测试 web管理平台 取消turnserver.conf中的注释:\n1 2 3 4 5 mysql-userdb=\u0026#34;host=172.16.4.113 dbname=coturn user=root password=123456 port=3306 connect_timeout=15 read_timeout=10\u0026#34; web-admin web-admin-ip=172.16.4.113 web-admin-port=8080 因为要使用数据库, 所以需要先创建数据库coturn和相关的表,表在源码的位置:docker/mysql/schema.sql。\n主要有以下几个表:\nadmin_user表是用来登录管理平台的用户表, 有name,realm,password三个字段。 其中name是用户名, realm是域名, password是密码。 可以使用turnadmin工具来添加用户, 工具在docker镜像中, 可以进入容器执行。\n1 turnadmin -A -M \u0026#34;host=172.16.4.113 dbname=coturn user=root password=123456\u0026#34; -u test -p 123456 -r example.com -r域名一定要有, 就能在数据表中看到生成的用户信息。\n然后浏览器访问https://exmaple.com:8080, 输入用户名密码登录。\n存在的问题\n密码如果是:123456, 登录填123456,登录不了，但是填1234或者其他的，只要比123456短, 就可以登录。已提issue。\n登录后, 可以看到如下的界面:\n通过查看TURN session可以看到当前的turn会话信息。\n因为这块数据没写入数据库，所以只能显示当时的会话信息。\nturn测试 条件说明:\n测试页面使用的是webrtc.github.io 提供的页面。 由于设备有限,coturn部署的服务上只有内网ip:172.16.4.113, 域名也是绑在此ip上的,以turn.example.com代替。 turnserver.conf 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 listening-port=3478 tls-listening-port=5349 listening-ip=172.16.4.113 external-ip=172.16.4.113 min-port=49152 max-port=65535 fingerprint lt-cred-mech user=1758880920:v7SRsGuqqovL1clY/ydY78zCdOA= mysql-userdb=\u0026#34;host=172.16.4.113 dbname=coturn user=root password=123456 port=3306 connect_timeout=15 read_timeout=10\u0026#34; realm=turn.example.com cert=/etc/ssl/tls/turn.example.com.pem pkey=/etc/ssl/tls/turn.example.com.key no-cli web-admin web-admin-ip=172.16.4.113 web-admin-port=8080 log-file=/var/log/turnserver.log new-log-timestamp new-log-timestamp-format \u0026#34;%FT%T%z\u0026#34; 关于user配置，有两种方式:\nusername:key\n这种方式要使用turnadmin来生成key,key是以0x开头的字符串,例如:\n1 turnadmin -k -u 1758880920 -r turn.example.com -p 123456 生成的key为:0xaa6a346a717d5152bab065c41fe0264d。\n然后在turnserver.conf中添加:\n1 user=1758880920:0xaa6a346a717d5152bab065c41fe0264d 但是在测试时,填写123456作为password:\n所以如果使用`key`方式, 你忘记了密码(配置中没写密码),那么就没办法了，只能重新生成`key`。 username:password\n如果用的是lt-cred-mech, 密码就是登录时填写的密码。\n如果用的是use-auth-secret, 密码就是HMAC-SHA1算法计算的结果, 密钥是static-auth-secret的值。 password是使用HMAC-SHA1算法来计算的, 可以使用此地址: hmac计算\n然后在`turnserver.conf`中添加: `user=1758880920:wLvieDRiCi7eCE0MwDr/+YTCNtk=` 但是在测试时,填写`wLvieDRiCi7eCE0MwDr/+YTCNtk=`作为`password`: turn测试结果 turn地址为:turn:turn.example.com:5349?transport=tcp, 测试的结果: 可以看到relay即是turnserver分配的转发的ip和port。\n抓包结果:\n目前的请求发送了两次,抓包和测试结果都印证了此情况。 通过抓包可以看到请求的逻辑:\nsequenceDiagram stun client -\u0026gt;\u0026gt;stun server: Allocate Request stun server -\u0026gt;\u0026gt;stun client: Allocate Error Response 401 stun client -\u0026gt;\u0026gt;stun server: Allocate Request with user stun server -\u0026gt;\u0026gt;stun client: Allocat Success Response Note over stun server,stun client: XOR-RELAYED-ADDRESS,XOR-MAPPED-ADDRESS,lifetime stun client -\u0026gt;\u0026gt;stun server: Refresh Request Note over stun server,stun client: lifetime,user,realm stun server -\u0026gt;\u0026gt;stun client: Refresh Success Response 详细的信令如下:\nAllocate Request Allocate Error Response Allocate Request with user Allocate Success Response XOR-RELAYED-ADDRESS: 是turnserver分配的转发的ip和port。\nXOR-MAPPED-ADDRESS: 是turn client的NAT后地址,因为是内网访问，所以显示的是内网ip。\nRefresh Request Refresh Success Response turn地址为:turn:turn.example.com:5349, 不带transport,默认是udp, 测试的结果: 可以看到有报错:STUN binding request timed out.。\n但是抓的包返回都是成功的,相对于tcp测试, 多了Binding Request信令。\n抓包结果:\n总结 现在的4.7.0版本，请求成功没有任何日志，只有报错日志，这块不太友好。 turn测试,不管是用域名还是ip, tcp请求ok, udp请求会报错，暂时还未找到原因。 ","date":"2025-09-30T13:47:33+08:00","image":"https://QuincyGao.github.io/p/coturn-%E5%88%9D%E4%BD%93%E9%AA%8C/backup_hu2610222803309840882.jpg","permalink":"https://QuincyGao.github.io/p/coturn-%E5%88%9D%E4%BD%93%E9%AA%8C/","title":"coturn 初体验"},{"content":"背景介绍 最近因为docker不让商用，需付费的操作，导致项目上为了合规，急需替换docker。 普遍采用的是containerd + nerdctl的组合。\ncontainerd: 是一个容器运行时，负责容器的创建、运行、暂停、恢复、删除等操作。 k8s的底层使用的就是containerd,所以稳定性是可以满足的，containerd代码地址。\nnerdctl: 是一个containerd的命令行工具，用于管理containerd中的容器，nerdctl代码地址。\n本次nerdctl的安装版本为：v2.1.4。\n安装部署 nerdctl依赖另外两个软件runc和cni。可以单独安装，这里不采用此种方式， 直接下载nerdctl完全包，里面会自带containerd,runc,cni等二进制程序,直接运行即可。\n下载nerdctl完全包：\nwget https://github.com/containerd/nerdctl/releases/download/v2.1.4/nerdctl-full-2.1.4-linux-amd64.tar.gz\n解压：\ntar Cxzvvf /usr/local nerdctl-full-2.1.4-linux-amd64.tar.gz 生成containerd的默认配置:\ncontainerd config default \u0026gt; /etc/containerd/config.toml\n修改containerd的运行目录:\nvim /etc/containerd/config.toml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 version = 3 root = \u0026#39;/var/lib/containerd\u0026#39; state = \u0026#39;/run/containerd\u0026#39; temp = \u0026#39;\u0026#39; disabled_plugins = [] required_plugins = [] oom_score = 0 imports = [] [grpc] address = \u0026#39;/run/containerd/containerd.sock\u0026#39; tcp_address = \u0026#39;\u0026#39; tcp_tls_ca = \u0026#39;\u0026#39; tcp_tls_cert = \u0026#39;\u0026#39; tcp_tls_key = \u0026#39;\u0026#39; uid = 0 gid = 0 max_recv_message_size = 16777216 max_send_message_size = 16777216 修改root和state的目录到磁盘空间大的目录，其他/run/containerd/相关的目录一起修改。\n启动containerd服务:\nsystemctl enable containerd \u0026amp;\u0026amp; systemctl start containerd\n创建nerdctl的配置文件:\nmkdir -p /etc/nerdctl \u0026amp;\u0026amp; touch /etc/nerdctl/nerdctl.toml 新增配置data_root,更改containerd的日志产生的目录到磁盘较大的空间:\n1 2 data_root=\u0026#34;/home/nerdctl\u0026#34; cni_path=\u0026#34;/usr/local/libexec/cni\u0026#34; 其他的参数可参考: nerdctl的配置说明\n使用以上的步骤， containerd正常运行，nerdctl也可以使用了。\n使用改造 说明:\ncontainerd可以直接使用docker生成的image,为了尽可能少改动，所以就不使用nerdctl重新build镜像了。 之前的容器使用docker-compose管理的, 现在也延用之前的docker-compose.yaml。 创建命名空间\nnerdctl namespace create sbc\n导入docker的image\nnerdctl -n sbc load -i opensips.tar\n运行容器\nnerdctl -n sbc compose -f docker-compose.yaml up -d\n验证容器是否运行:\nnerdctl -n sbc ps\n查看容器的日志:\nnerdctl -n sbc logs sbc\n其他说明 因为nerdctl并不像docker那样可以通过配置/etc/docker/daemon.json来统一设置log的日志输出参数。 所以需要单个服务的docker-compose.yaml中, 配置logging参数。如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 services: opensips: image: opensips:3.4.5 container_name: \u0026#34;ops\u0026#34; hostname: \u0026#34;ops\u0026#34; network_mode: \u0026#34;host\u0026#34; privileged: true \u0026lt;\u0026lt;: *defaults logging: driver: json-file options: max-size: \u0026#34;10m\u0026#34; max-file: \u0026#34;10\u0026#34; ","date":"2025-09-23T10:17:39+08:00","image":"https://QuincyGao.github.io/p/containerd--nerdctl-%E5%88%9D%E4%BD%93%E9%AA%8C/backup_hu12652548772946387960.jpg","permalink":"https://QuincyGao.github.io/p/containerd--nerdctl-%E5%88%9D%E4%BD%93%E9%AA%8C/","title":"containerd + nerdctl 初体验"},{"content":"ICE协议介绍 ICE协议是WebRTC的一个重要组成部分, 全称为:Interactive Connectivity Establishment, 要用到stun和turn协议, 用于NAT穿越, 建立P2P连接。\n最新版本为：RFC 8445\nICE协议要点 使用场景 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 +---------+ +--------+ |Signaling| +--------+ | STUN | |Server | | STUN | | Server | +---------+ | Server | +--------+ / \\ +--------+ / \\ / \\ / \u0026lt;- Signaling -\u0026gt; \\ / \\ +--------+ +--------+ | NAT | | NAT | +--------+ +--------+ / \\ / \\ +-------+ +-------+ | Agent | | Agent | | L | | R | +-------+ +-------+ Agent L要和Agent R通信，因为分别在NAT后面, 所以要先通过STUN协议交换Agent L和Agent R的NAT映射后的地址。\n在ICE中，这样的地址可以称为candidate transport addresses(候选地址)。 候选地址可以有以下三种:\npublic地址: 直接暴露在公网的地址, 即NAT映射后的地址。 private地址: 隐藏在NAT后面的地址, 只能被NAT后面的设备访问到。 relay地址: 经过TURN服务器转发的地址, 可以被公网访问到, 但只能被NAT后面的设备访问到。 candidate host Candidates 本地网卡ip和port, 不能包括： 回环地址(127.0.0.1)\nServer-Reflexive and Relayed Candidates nat映射的地址和turn转发的地址\nKeeping Candidates Alive 一旦分配了server-reflexive或relay地址, 就需要定时发送keep-alive包, 以保持连接的有效性。\nRole 在每个会话中，每个ICE agent必须有一个角色(controlling或controlled)。具体是哪个角色根据以下情况分析：\n两个坐席都是full\n发起ICE处理的agent是controlling,另外一个agent就是controlled。 会有连接检查。\n一个坐席是full, 另一个坐席是lite\nfull agent是controlling, 另一个lite agent就是controlled。\n都是lite\n发起ICE处理的agent是controlling,另外一个agent就是controlled。 没有连接检查.\n一旦会话建立, 双方ICE agent的控制状态就不能再变了，但是fullorlite这个状态在重启的时候可以改变。\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 +-------+ |STUN | |Server | +-------+ | +---------------------+ | | | Internet | | | +---------------------+ | | | | +---------+ | | NAT | | +---------+ | | | | | +-----+ +-----+ | L | | R | +-----+ +-----+ 详细的地址示例:\nENTITY IP Address Mnemonic name ICE Agent L 10.0.1.1 L-PRIV-1 ICE Agent R 192.0.2.1 R-PUB-1 STUN Server 192.0.2.2 STUN-PUB-1 NAT (Public) 192.0.2.3 NAT-PUB-1 交互流程为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 L NAT STUN R |STUN alloc. | | | |(1) STUN Req | | | |S=$L-PRIV-1 | | | |D=$STUN-PUB-1 | | | |-------------\u0026gt;| | | | |(2) STUN Req | | | |S=$NAT-PUB-1 | | | |D=$STUN-PUB-1 | | | |-------------\u0026gt;| | | |(3) STUN Res | | | |S=$STUN-PUB-1 | | | |D=$NAT-PUB-1 | | | |MA=$NAT-PUB-1 | | | |\u0026lt;-------------| | |(4) STUN Res | | | |S=$STUN-PUB-1 | | | |D=$L-PRIV-1 | | | |MA=$NAT-PUB-1 | | | |\u0026lt;-------------| | | |(5) L\u0026#39;s Candidate Information| | |-------------------------------------------\u0026gt;| | | | | STUN | | | | alloc. | | |(6) STUN Req | | | |S=$R-PUB-1 | | | |D=$STUN-PUB-1 | | | |\u0026lt;-------------| | | |(7) STUN Res | | | |S=$STUN-PUB-1 | | | |D=$R-PUB-1 | | | |MA=$R-PUB-1 | | | |-------------\u0026gt;| |(8) R\u0026#39;s Candidate Information| | |\u0026lt;-------------------------------------------| | | (9) Bind Req |Begin | | S=$R-PUB-1 |Connectivity | | D=$L-PRIV-1 |Checks | | \u0026lt;-------------------| | | Dropped | |(10) Bind Req | | | |S=$L-PRIV-1 | | | |D=$R-PUB-1 | | | |-------------\u0026gt;| | | | |(11) Bind Req | | | |S=$NAT-PUB-1 | | | |D=$R-PUB-1 | | | |----------------------------\u0026gt;| | |(12) Bind Res | | | |S=$R-PUB-1 | | | |D=$NAT-PUB-1 | | | |MA=$NAT-PUB-1 | | | |\u0026lt;----------------------------| |(13) Bind Res | | | |S=$R-PUB-1 | | | |D=$L-PRIV-1 | | | |MA=$NAT-PUB-1 | | | |\u0026lt;-------------| | | |Data | | | |===========================================\u0026gt;| | | | | | |(14) Bind Req | | | |S=$R-PUB-1 | | | |D=$NAT-PUB-1 | | | |\u0026lt;----------------------------| |(15) Bind Req | | | |S=$R-PUB-1 | | | |D=$L-PRIV-1 | | | |\u0026lt;-------------| | | |(16) Bind Res | | | |S=$L-PRIV-1 | | | |D=$R-PUB-1 | | | |MA=$R-PUB-1 | | | |-------------\u0026gt;| | | | |(17) Bind Res | | | |S=$NAT-PUB-1 | | | |D=$R-PUB-1 | | | |MA=$R-PUB-1 | | | |----------------------------\u0026gt;| |Data | | | |\u0026lt;===========================================| | | | | ....... | | | | |(18) Bind Req | | | |S=$L-PRIV-1 | | | |D=$R-PUB-1 | | | |USE-CAND | | | |-------------\u0026gt;| | | | |(19) Bind Req | | | |S=$NAT-PUB-1 | | | |D=$R-PUB-1 | | | |USE-CAND | | | |----------------------------\u0026gt;| | |(20) Bind Res | | | |S=$R-PUB-1 | | | |D=$NAT-PUB-1 | | | |MA=$NAT-PUB-1 | | | |\u0026lt;----------------------------| |(21) Bind Res | | | |S=$R-PUB-1 | | | |D=$L-PRIV-1 | | | |MA=$NAT-PUB-1 | | | |\u0026lt;-------------| | | | | | | ","date":"2025-09-22T16:23:39+08:00","image":"https://QuincyGao.github.io/p/ice%E5%8D%8F%E8%AE%AE%E8%A6%81%E7%82%B9%E7%BA%AA%E8%A6%81/backup_hu10917109530021006738.jpg","permalink":"https://QuincyGao.github.io/p/ice%E5%8D%8F%E8%AE%AE%E8%A6%81%E7%82%B9%E7%BA%AA%E8%A6%81/","title":"ICE协议要点纪要"},{"content":"turn协议介绍 当主机ip在NAT后面，某些情况下，它不可能直接和其他的主机通信，此时就需要一个中继服务来连接两个节点。\nturn协议提供了这样的功能，虽然可以单独使用，但是它常常作为ICE的一部分。\n最新的协议地址:RFC 8656, 过时的协议:RFC 6156\nturn协议要点 传输协议 TURN client to TURN server TURN server to peer UDP UDP TCP UDP TLS-over-TCP UDP DTLS-over-UDP UDP 因为turn server和其他的peer使用udp通信，所以推荐turn client和turn server也用udp方式， 除非有其他原因，比如：防火墙拦截udp等。\nAllocations 客户端发送请求到服务端获取到中继地址之后，客户端要保持此地址活跃，默认的生命周期是10分钟, 客户端要在此时间内刷新请求，如果不想使用了，就发送生命周期为0的请求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 TURN TURN Peer Peer client server A B |-- Allocate request ---------------\u0026gt;| | | | (invalid or missing credentials) | | | | | | | |\u0026lt;--------------- Allocate failure --| | | | (401 Unauthenticated) | | | | | | | |-- Allocate request ---------------\u0026gt;| | | | (valid credentials) | | | | | | | |\u0026lt;---------- Allocate success resp --| | | | (192.0.2.15:50000) | | | // // // // | | | | |-- Refresh request ----------------\u0026gt;| | | | | | | |\u0026lt;----------- Refresh success resp --| | | | | | | URI Scheme turns必须是TLS-over-TCPorDTLS-over-UDP,端口默认: 5349 turn必须是UDPorTCP,host为turn serverip。 端口默认:3478 turn是stun的扩展，所有的turn消息除了ChannelData之外，都是stun格式的消息。\n权限 turn server存在权限列表，包括ip和分配的过期时间, 如果有权限，所有的peer可以使用该ip来发送数据到client。\n客户端可以通过CreatePermissionorCHannelBind请求来申请或者刷新给定ip的服务端权限。 权限的生命周期为:5分钟。当udp数据到达turn server时，会检查数据的src ip是否在权限列表中，port不检查。 如果不匹配，udp数据丢弃。\nCreatePermission 这个请求必须包括:XOR-PEER-ADDRESS(需要赋权限的ip),此字段可以有多个,但是ip不能重复。\nChannel bindings Channel bindings和一个allocation绑定，如果某个allocation过期，那么Channel bindings也一起失效。\n一个channel binding包括:\nchannel number transport address 过期时间 一个channel binding 以 channel number或者transport address为唯一标识。 因此, 相同的channel不能绑定到两个不同的transport address, 相同的transport address也不能绑定到两个不同的channel\nchannel binding持续10分钟, 一旦channel binding过期，客户端必须等5分钟之后,才能把这channel number绑定到不同的transport address, 或者这个transport address绑定到不同的channel number。\nChannelData 1 2 3 4 5 6 7 8 9 10 11 12 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Channel Number | Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | / Application Data / / / | | | +-------------------------------+ | | +-------------------------------+ 如果使用TCPorTLS-over-TCP传输, 为了保持对齐，ChannelData的长度必须是4字节的倍数。 这个填充不反映在Length字段中。UDP没有这样的要求。\nSTUN methods address Method Description 0x003 Allocate (only request/response semantics defined) 0x004 Refresh (only request/response semantics defined) 0x006 Send (only indication semantics defined) 0x007 Data (only indication semantics defined) 0x008 CreatePermission (only request/response semantics defined) 0x009 ChannelBind (only request/response semantics defined) STUN attributes attribute Description 0x000C CHANNEL-NUMBER 0x000D LIFETIME 0x0010 Reserved (was BANDWIDTH) 0x0012 XOR-PEER-ADDRESS 0x0013 DATA 0x0016 XOR-RELAYED-ADDRESS 0x0017 REQUESTED-ADDRESS-FAMILY 0x0018 EVEN-PORT 0x0019 REQUESTED-TRANSPORT 0x001A DONT-FRAGMENT 0x0021 Reserved (was TIMER-VAL) 0x0022 RESERVATION-TOKEN 0x8000 ADDITIONAL-ADDRESS-FAMILY 0x8001 ADDRESS-ERROR-CODE 0x8004 ICMP ","date":"2025-09-19T16:14:45+08:00","image":"https://QuincyGao.github.io/p/turn%E5%8D%8F%E8%AE%AE%E8%A6%81%E7%82%B9%E7%BA%AA%E8%A6%81/backup_hu17566926881496773539.jpg","permalink":"https://QuincyGao.github.io/p/turn%E5%8D%8F%E8%AE%AE%E8%A6%81%E7%82%B9%E7%BA%AA%E8%A6%81/","title":"turn协议要点纪要"},{"content":"stun协议介绍 stun协议提供了一种机制, 用于发现和定位客户端在NAT后的IP地址和端口号。 可以检查两个节点的连接并保活NAT的绑定。它不提供NAT穿透功能, 只能用于发现和定位NAT后的IP地址和端口号。\n最新的stun协议版本是RFC 8489,已经过时: RFC 5389。\nstun配合使用的场景有两个：\nICE\nsip oubound\n要点 stun是客户端-服务端协议, 支持两种事务：\n客户端发送请求，服务端响应 客户端发送不需要服务端响应的消息 STUN消息结构 stun Message采用网络字节序编码, 即大端字节序。\n1 2 3 4 5 6 7 8 9 10 11 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 0| STUN Message Type | Message Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Magic Cookie | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | | Transaction ID (96 bits) | | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 最高的两位字节必须为0,当stun和其他协议在同一个端口上复用时，可以使用这两位来区分协议。\nMessage Type: 用来定义message class和message method。message method为Binding(0b000000000001), message class主要分为:\nrequest 客户端发送请求, 服务端响应 response 服务端发送响应, 客户端接收 error response 服务端发送错误响应, 客户端接收 indication 客户端发送通知, 服务端不响应 Magic Cookie: 必须包括0x2112A442,它是Transaction ID的一部分.\n对于通过UDP或者DTLS-over-UDP发送的stun消息,大小必须小于MTU。 如果不知道MTU, 使用udp发送, ipv4情况下,stun的udp包必须小于548。\nrequest/response这样的事务, 发送中如果丢包，会间隔初始值RTO(500ms)时间重传, indication这样的事务, 发送中如果丢包, 不会重传。 默认最大重传次数为7次。\nSTUN URL 当客户端希望使用TLS/DTLS加密，那么stun server的URI的scheme为:stuns,否则为:stun。\nstunURI的host为ip, stunsURI的host必须为域名,ip会报错。\n默认的stun端口为3478, stuns端口为5349。\n当使用TLS-over-TCP或者DTLS-over-UDP时, TLS_DHE_RSA_WITH_AES_128_GCM_SHA256和TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256必须有。\nrequest/response关于未知attributes的处理 如果request中包含未知的attributes, 服务端报错420(Unkown Attribute)。 对于错误的response,错误码必须有，错误信息要和错误码匹配。 如果indication请求包括未知的attributes, 服务端会丢弃此命令,处理停止。 如果成功的response中带有未知的attributes, 客户端会丢弃此response,并认为事务处理失败。 如果错误的response中包含未知的attributes或者未带错误码，客户端初步认为事务处理失败。需要再结合错误码来判断: 300-499: 客户端认为事务处理失败。 500-599: 客户端可能会重新发送请求,重试的次数应该被限制到4。 FINGERPRINT 机制 FINGERPRINT机制是为了和其他的消息进行区分，stun Header头有时候不够用，所以需要添加FINGERPRINT属性。\n认证机制主要有两种: 短期凭证机制和长期凭证机制。\n短期凭证机制\n在进行事务之前，客户端和服务端已使用其他协议交换了用户名和密码形式的凭证,此凭证是有时效的, 此凭证主要用在每个请求和多个响应中形成消息完整性检查。\n对于request或者indication消息，必须有USERNAME, MESSAGE-INTERGITY-SHA256,MESSAGE-INTERGRITY。 除非双方已通过其他方式知道了对方支持的完整性算法，这种情况下,MESSAGE-INTERGITY-SHA256和MESSAGE-INTERGRITY必须有一个。 密码一定不能在消息中。\n服务端收到request或者indication消息, 必须验证USERNAME和MESSAGE-INTERGITY-SHA256或者MESSAGE-INTERGRITY。\n消息中不包括USERNAME或者MESSAGE-INTERGITY-SHA256和MESSAGE-INTERGRITY中的一个, 服务端必须返回400(Bad Request)错误响应。 如果USERNAME或者MESSAGE-INTERGITY-SHA256和MESSAGE-INTERGRITY中的一个验证失败, 服务端必须返回401(Unauthorized)错误响应。 客户端收到response之后，检查参数MESSAGE-INTEGRITY或者MESSAGE-INTEGRITY-SHA256, 如果不匹配，response丢弃。 然后，客户端使用和请求相同的密码，根据MESSAGE-INTEGRITY或者MESSAGE-INTEGRITY-SHA256对response的消息完整性计算, 如果结果和MESSAGE-INTEGRITY或者MESSAGE-INTEGRITY-SHA256的内容一致，就认为匹配.\n后续的其他的请求都要带MESSAGE-INTEGRITY-SHA256或者MESSAGE-INTEGRITY属性.\n长期凭证机制 客户端和服务端共享用户名和密码，长期有效，直到用户不再是系统订阅者或者凭证改变。 它的认证过程为:\n客户端发送不带任何凭证的request或者indication消息到服务端 服务端拒绝请求并带上realm(引导用户选择用户名和密码)和nonce(服务端cookie) 客户端会重新发送请求带上username,realm和nonce 服务端验证nonce和消息完整性. 之后的其他请求客户端都要带上username,realm和nonce,直到服务端的nonce失效。 第一个请求必须包括: USERNAME, USERHASH,MESSAGE-INTEGRITY, MESSAGE-INTEGRITY-SHA256, REALM, NONCE, PASSWORD-ALGORITHMS, PASSWORD-ALGORITHM 一旦服务端验证了nonce和消息完整性, 后续的请求都必须包括USERNAMEorUSERHASH,REALM,NONCE, PASSWORD-ALGORITHM,MESSAGE-INTEGRITYorMESSAGE-INTEGRITY-SHA256\n备用服务器 机制 服务端返回错误码300(Try Alternate)并带ALTERNATE-SERVER属性。\nstun的部分参数 MAPPED-ADDRESS 1 2 3 4 5 6 7 8 9 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 0 0 0 0 0 0 0| Family | Port | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | | Address (32 bits or 128 bits) | | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 客户端nat的地址, 包括8位family和16位port, 32位ipv4或者128位ipv6。\nXOR-MAPPED-ADDRESS 1 2 3 4 5 6 7 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 0 0 0 0 0 0 0| Family | X-Port | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | X-Address (Variable) +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 反传输的地址,和MAPPED-ADDRESS差别在于传输地址的编码, XOR-MAPPED-ADDRESS通过和magic cookie按位异或来编码地址, MAPPED-ADDRESS直接以二进制形式编码地址.\nUSERNAME 用于标识消息完整性检查使用用户名和密码的方式. 必须是utf-8并且少于509个字节。\nUSERHASH 当支持用户名匿名时，使用此字段替换USERNAME,32个字节。\nFINGERPRINT 如果有该字段，那么此字段必须在MESSAGE-INTEGRITYandMESSAGE-INTEGRITY-SHA256后面.\nPASSWORD-ALGORITHMS 包括服务端可以使用的算法列表。\n1 2 3 4 5 6 7 8 9 10 11 12 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Algorithm 1 | Algorithm 1 Parameters Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Algorithm 1 Parameters (variable) +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Algorithm 2 | Algorithm 2 Parameters Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Algorithm 2 Parameters (variable) +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | ... PASSWORD-ALGORITHM 服务端要用的算法\n1 2 3 4 5 6 7 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Algorithm | Algorithm Parameters Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Algorithm Parameters (variable) +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ","date":"2025-09-17T09:55:53+08:00","image":"https://QuincyGao.github.io/p/stun%E5%8D%8F%E8%AE%AE%E8%A6%81%E7%82%B9%E7%BA%AA%E8%A6%81/backup_hu3101636661913927812.jpg","permalink":"https://QuincyGao.github.io/p/stun%E5%8D%8F%E8%AE%AE%E8%A6%81%E7%82%B9%E7%BA%AA%E8%A6%81/","title":"stun协议要点纪要"},{"content":"背景 最近想升级freeswitch的版本, 需要制作freeswitch1.10.7的镜像，记录一下制作过程。\nfreeswitch的官方安装文档为: linux安装\n使用的基础镜像为:debian:bullseye。\n特殊要求 lua5.3 使用openh264编码 说明: freeswitch1.10.7版本默认使用的是lua5.2,所以在编译mod_lua时需要指定lua5.3的路径。\n制作准备 因为要使用依赖安装, 所以需要使用token\n注册账号: signalwire 生成token, 方法为: how-to-create-a-FSA-API-Key-access-token Dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 # =============================== # 1. Builder 阶段：编译 freeswitch # =============================== FROM debian:bullseye AS builder WORKDIR /build # 使用阿里云 Debian 源 RUN echo \u0026#39;deb http://mirrors.aliyun.com/debian/ bullseye main non-free contrib\\n\\ deb-src http://mirrors.aliyun.com/debian/ bullseye main non-free contrib\\n\\ deb http://mirrors.aliyun.com/debian-security/ bullseye-security main\\n\\ deb-src http://mirrors.aliyun.com/debian-security/ bullseye-security main\\n\\ deb http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib\\n\\ deb-src http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib\u0026#39; \\ \u0026gt; /etc/apt/sources.list # 基础工具 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y \\ wget curl zip gnupg lsb-release build-essential \\ pkg-config libtool automake autoconf nasm apt-utils git cmake \\ \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* # 拷贝源码 COPY . . # 添加 FreeSWITCH SignalWire 官方源（需要账号密码,pat_xxxxxxxxxxxxxx为token） RUN wget --http-user=signalwire --http-password=pat_xxxxxxxxxxxxxx -O /usr/share/keyrings/signalwire-freeswitch-repo.gpg https://freeswitch.signalwire.com/repo/deb/debian-release/signalwire-freeswitch-repo.gpg \\ \u0026amp;\u0026amp; echo \u0026#34;machine freeswitch.signalwire.com login signalwire password pat_xxxxxxxxxxxxxx\u0026#34; \u0026gt; /etc/apt/auth.conf \\ \u0026amp;\u0026amp; echo \u0026#34;deb [signed-by=/usr/share/keyrings/signalwire-freeswitch-repo.gpg] https://freeswitch.signalwire.com/repo/deb/debian-release $(lsb_release -sc) main\u0026#34; \\ \u0026gt; /etc/apt/sources.list.d/freeswitch.list \\ \u0026amp;\u0026amp; echo \u0026#34;deb-src [signed-by=/usr/share/keyrings/signalwire-freeswitch-repo.gpg] https://freeswitch.signalwire.com/repo/deb/debian-release $(lsb_release -sc) main\u0026#34; \\ \u0026gt;\u0026gt; /etc/apt/sources.list.d/freeswitch.list # 安装 freeswitch 构建依赖 RUN apt-get update \u0026amp;\u0026amp; apt-get build-dep -y freeswitch \\ \u0026amp;\u0026amp; apt-get remove --purge liblua5.2-dev liblua5.2-0 -y \\ \u0026amp;\u0026amp; apt-get install -y liblua5.3-0 liblua5.3-dev lua5.3 libks \\ \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* # 编译第三方依赖 (openh264 / luasocket) RUN git clone https://github.com/cisco/openh264.git \u0026amp;\u0026amp; cd openh264-2.6.0 \u0026amp;\u0026amp; make ENABLE64BIT=Yes -j$(nproc) \u0026amp;\u0026amp; make install \\ \u0026amp;\u0026amp; cd .. \u0026amp;\u0026amp; git clone https://github.com/lunarmodules/luasocket.git \\ \u0026amp;\u0026amp; cd luasocket \u0026amp;\u0026amp; make linux -j$(nproc) \u0026amp;\u0026amp; make install \\ \u0026amp;\u0026amp; cd .. \u0026amp;\u0026amp; git clone https://github.com/lunarmodules/lua-iconv.git \u0026amp;\u0026amp; cd lua-iconv \\ \u0026amp;\u0026amp; make LUA_INCLUDE=/usr/include/lua5.3 \u0026amp;\u0026amp; make install LUA_LIBDIR=/usr/local/lib/lua/5.3 \\ \u0026amp;\u0026amp; ldconfig ENV CPPFLAGS=\u0026#34;-I/usr/include/lua5.3\u0026#34; RUN ln -s /usr/lib/x86_64-linux-gnu/liblua5.3.so /usr/lib/x86_64-linux-gnu/liblua.so # 编译 freeswitch RUN cd freeswitch \\ \u0026amp;\u0026amp; ./bootstrap.sh \\ \u0026amp;\u0026amp; cp /build/modules.conf . \\ \u0026amp;\u0026amp; ./configure --disable-signalwire \\ \u0026amp;\u0026amp; make -j$(nproc) \u0026amp;\u0026amp; make install # 精简二进制文件（去掉调试符号） RUN strip /usr/local/freeswitch/bin/* || true \\ \u0026amp;\u0026amp; strip /usr/local/freeswitch/mod/*.so || true # =============================== # 2. Library-check 阶段：检测依赖 # =============================== FROM builder AS libcheck COPY check-libs.sh /check-libs.sh RUN chmod +x /check-libs.sh \u0026amp;\u0026amp; /check-libs.sh # =============================== # 3. Runtime 阶段：运行 freeswitch # =============================== FROM debian:bullseye-slim AS runtime # 使用阿里云 Debian 源 RUN echo \u0026#39;deb http://mirrors.aliyun.com/debian/ bullseye main non-free contrib\\n\\ deb-src http://mirrors.aliyun.com/debian/ bullseye main non-free contrib\\n\\ deb http://mirrors.aliyun.com/debian-security/ bullseye-security main\\n\\ deb-src http://mirrors.aliyun.com/debian-security/ bullseye-security main\\n\\ deb http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib\\n\\ deb-src http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib\u0026#39; \\ \u0026gt; /etc/apt/sources.list RUN apt-get update \u0026amp;\u0026amp; apt-get install -y \\ liblua5.3-0 lua5.3 libsqlite3-0 vim curl wget \\ \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* # 拷贝运行需要的库 COPY --from=libcheck /libs/ /usr/local/lib/ RUN mv /usr/local/lib/share/lua /usr/local/share/ ENV LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH # 拷贝 freeswitch COPY --from=builder /usr/local/freeswitch /usr/local/freeswitch COPY --from=builder /build/conf conf # 修改配置和删除安装包 RUN cp conf/vars.xml /usr/local/freeswitch/conf/ \\ \u0026amp;\u0026amp; mv /usr/local/freeswitch/conf/sip_profiles/internal-ipv6.xml /usr/local/freeswitch/conf/sip_profiles/internal-ipv6.xml.noload \\ \u0026amp;\u0026amp; mv /usr/local/freeswitch/conf/sip_profiles/external-ipv6.xml /usr/local/freeswitch/conf/sip_profiles/external-ipv6.xml.noload WORKDIR /usr/local/freeswitch # 运行 CMD [\u0026#34;/usr/local/freeswitch/bin/freeswitch\u0026#34;, \u0026#34;-nonat\u0026#34;] 说明: lua-iconv是lua的一个扩展库, 如果你不需要可以删掉。 如果需要,下载到源码之后还要改它的Makefile里的LUAPKG = lua5.2为LUAPKG = lua5.3。\ncheck-libs.sh的脚本为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #!/bin/bash set -e OUT_DIR=\u0026#34;/libs\u0026#34; mkdir -p \u0026#34;$OUT_DIR/share/lua/5.3\u0026#34; # 要检查依赖的二进制/模块 TARGETS=\u0026#34; /usr/local/freeswitch/bin/freeswitch /usr/local/freeswitch/bin/fs_cli /usr/local/freeswitch/mod/*.so \u0026#34; for f in $TARGETS; do if [ -f \u0026#34;$f\u0026#34; ]; then echo \u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt; ldd $f\u0026#34; for so in $(ldd \u0026#34;$f\u0026#34; | awk \u0026#39;{print $3}\u0026#39; | grep \u0026#34;^/\u0026#34;); do cp -v \u0026#34;$so\u0026#34; \u0026#34;$OUT_DIR\u0026#34; || true done fi done # 额外拷贝自编译库（openh264） if [ -d /usr/local/lib ]; then cp -rv /usr/local/lib/* \u0026#34;$OUT_DIR\u0026#34; || true fi # 额外拷贝 luasocket 脚本模块 if [ -d /usr/local/share/lua/5.3 ]; then cp -rv /usr/local/share/lua/5.3/* \u0026#34;$OUT_DIR/share/lua/5.3/\u0026#34; || true fi 在freeswitch执行./configure之前，修改modules.conf:\n1 2 3 4 5 6 #applications/mod_signalwire formats/mod_shout formats/mod_vlc asr_tts/mod_unimrcp codecs/mod_openh264 #codecs/mod_h26x 另外把freeswitch配置中需要修改的文件统一放在了conf目录下了， 所以会有COPY --from=builder /build/conf conf,以及RUN cp conf/vars.xml /usr/local/freeswitch/conf/\n这里我主要改了vars.xml和autoload_configs/modules.conf.xml:\nvars.xml: 1 2 \u0026lt;X-PRE-PROCESS cmd=\u0026#34;stun-set\u0026#34; data=\u0026#34;external_rtp_ip=$${local_ip_v4}\u0026#34;/\u0026gt; \u0026lt;X-PRE-PROCESS cmd=\u0026#34;stun-set\u0026#34; data=\u0026#34;external_sip_ip=$${local_ip_v4}\u0026#34;/\u0026gt; autoload_configs/modules.conf.xml: 1 2 \u0026lt;!-- \u0026lt;load module=\u0026#34;mod_signalwire\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;load module=\u0026#34;mod_openh264\u0026#34;/\u0026gt; 总结 目前最终生成出来的镜像大小为:365MB, 如果直接使用编译时Builder的镜像,大小为:3.3G。 使用此方法可以极大缩小镜像包大小。\n","date":"2025-09-12T09:44:01+08:00","image":"https://QuincyGao.github.io/p/freeswitch1.10.7%E7%BC%A9%E5%87%8F%E9%95%9C%E5%83%8F%E5%8C%85%E5%A4%A7%E5%B0%8F/backup_hu16353767103970380812.jpg","permalink":"https://QuincyGao.github.io/p/freeswitch1.10.7%E7%BC%A9%E5%87%8F%E9%95%9C%E5%83%8F%E5%8C%85%E5%A4%A7%E5%B0%8F/","title":"freeswitch1.10.7缩减镜像包大小"},{"content":"背景 rtpengine提供媒体代理功能, 和sip代理(opensips或者kamailio)一起组成完整的代理服务。\n针对rtpengine的使用，记录几个常用方法。 rtpengine的官方文档: rtpengine\n当前测试的rtpegnine版本:\nVersion: 13.3.1.7+0~mr13.3.1.7 git-HEAD-c2223681\nrtpengine 是否支持视频? 一直对rtpengine的视频支持不是很清楚，官方文档也没有明确说明。 rtpengine支持的编码有:\n从支持的编码上看，都是音频编码，没有视频编码，所以我也认为是不支持视频的。 最近有空,就使用mircoSIP测试了视频功能，发现rtpengine支持视频。\n完整的一通视频sip图:\n媒体相关的信令:\n可以看到音频用的是g711u,视频用的是h264\n以下这通电话的详细sdp信令:\nmicroSIP发出INVITE信令: 可以看到既有audio又有video\nopensips转发INVITE信令: opensips收到183ring信令: opensips转发183ring信令: 接通之后,microSIP发出媒体控制信令INFO: opensips转发INFO信令: 目前视频流传输这块发现rtpengine有报错, 从效果来看，并没有卡顿情况:\n综上所述， rtpengine支持视频，因为没有相应的编码，所以视频流透传。\nrtpengine 的几个codec设置 在做媒体代理转发时,需要对sdp中的codec做调整, 而sdp是rtpengine生成的, 所以opensips或者kamailio调用rtpengine_manager时,设置codec参数可以调整sdp中的codec。\nrtpengine提供的参数文档为: ng_control_protocol\ncodec-transcode 介绍 transcode 官方的解释是：\nSimilar to offer but allows codecs to be added to the list of offered codecs even if they were not present in the original list of codecs. In this case, the transcoding engine will be engaged. Only codecs that are supported for both decoding and encoding can be added in this manner. This also has the side effect of automatically stripping all unsupported codecs from the list of offered codecs, as rtpengine must expect to receive or even send in any codec that is present in the list.\n意思就是： 可以添加原编码列表中没有的新编码，这个新的编码必须是rtpengine支持的fully supported的codecs. 此时会启用转码功能。另外也可以通过opus/48000/2/32000这样，设置采样率，声道数。\n验证 codec-transcode-PCMU(源sdp含有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMU,PCMA,telephone-event uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: PCMA,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMA,telephone-event 可以看到，codec-transcode-PCMU其实不起作用.\ncodec-transcode-G722(源sdp没有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMU,PCMA,G722,telephone-event uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: PCMA,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMA,telephone-event 当和codec-strip-all codec-mask-all一起使用时,codec-transcode-PCMU不会启用转码,codec-transcode-G722会启用转码.\ncodec-strip 介绍 strip 官方的解释是：\nContains a list of strings. Each string is the name of a codec or RTP payload type that should be removed from the SDP. Codec names are case sensitive, and can be either from the list of codecs explicitly defined by the SDP through an a=rtpmap attribute, or can be from the list of RFC-defined codecs. Examples are PCMU, opus, or telephone-event. Codecs stripped using this option are only removed from the outgoing rewritten SDP and don\u0026rsquo;t affect the list of codecs that was offered by the source SDP. See the ignore option above for a similar mechanism that affects the offer codecs.\n意思就是： 从sdp中移除指定的编码. 可以是具体的某个编码,也可以是allorfull移除所有编码.\n验证 codec-strip-PCMU(源sdp含有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMA,telephone-event uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: PCMA,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMA,telephone-event codec-strip-PCMA codec-transcode-G722(uas使用G722) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMU,G722,telephone-event uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: G722,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMU,telephone-event codec-strip-G722(源sdp没有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMU,PCMA,telephone-event uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: PCMA,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMA,telephone-event 这种方式下,codec-accept-G722不起作用.\ncodec-strip-all(删除所有)\nopensips转发INVITE时的sdp信息:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 v=0 o=- 3959939030 3959939030 IN IP4 172.16.4.111 s=pjmedia b=AS:84 t=0 0 a=X-nat:0 m=audio 32560 RTP/AVP 0 8 101 c=IN IP4 172.16.4.111 b=TIAS:64000 a=rtpmap:0 PCMU/8000 a=rtpmap:8 PCMA/8000 a=rtpmap:101 telephone-event/8000 a=fmtp:101 0-16 a=ssrc:1854882148 cname:0baf6e5578824b50 a=sendrecv a=rtcp:32561 可以看到好像并没有变化,查看rtpengine的日志，有Warning:\n1 2 3 4 [1750921364.090656] DEBUG: [0349a2eed9304f22ac7cb87970e1d5f7]: [codec] Stripping codec PCMU/8000/ (0) due to strip=all or strip=full [1750921364.090663] DEBUG: [0349a2eed9304f22ac7cb87970e1d5f7]: [codec] Stripping codec PCMA/8000/ (8) due to strip=all or strip=full [1750921364.090666] DEBUG: [0349a2eed9304f22ac7cb87970e1d5f7]: [codec] Stripping codec telephone-event/8000/0-16 (101) due to strip=all or strip=full [1750921364.090669] WARNING: [0349a2eed9304f22ac7cb87970e1d5f7]: [core] Usage error: List of codecs empty. Restoring original list of codecs. Results may be unexpected. rtpengine触发了保护机制,不允许删除所有的codecs.\n如果想查看效果，可以这样用codec-strip-all codec-transcode-G722删除所有,新增G722\n1 2 3 4 5 6 7 8 9 10 11 12 13 v=0 o=- 3959939604 3959939604 IN IP4 172.16.4.111 s=pjmedia b=AS:84 t=0 0 a=X-nat:0 m=audio 32710 RTP/AVP 9 c=IN IP4 172.16.4.111 b=TIAS:64000 a=rtpmap:9 G722/8000 a=ssrc:607722213 cname:2664202b2fde465f a=sendrecv a=rtcp:32711 codec-mask 介绍 mask 官方的解释是：\nSimilar to strip except that codecs listed here will still be accepted and used for transcoding on the offering side. Useful only in combination with transcode. For example, if an offer advertises Opus and the options mask=opus, transcode=G723 are given, then the rewritten outgoing offer will contain only G.723 as offered codec, and transcoding will happen between Opus and G.723. In contrast, if only transcode=G723 were given, then the rewritten outgoing offer would contain both Opus and G.723. On the other hand, if strip=opus, transcode=G723 were given, then Opus would be unavailable for transcoding.\n意思就是: 功能和strip类似,如果和transcode一起使用, 会设置A-leg方向的编码,也可以设置allorfull。 正常情况下, A---- opensips ----B, B返回200OK的编码,opensips会透传给A, 但是如果想改变opensips---A的200OK编码，就需要设置mask。\n目前实际测试情况不太一样，并没有达到官方描述的效果，不知道是否是使用方法问题。\n验证 codec-mask-PCMA(源sdp含有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMU,telephone-event uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: PCMU,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMU,telephone-event 可以看到PCMA被删除了。\ncodec-mask-PCMA codec-transcode-G722(uas使用G722) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMU,G722,telephone-event uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: G722,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMU,telephone-event codec-mask-G722(源sdp没有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMU,PCMA,telephone-event uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: PCMA,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMA,telephone-event 这种方式下,codec-accept-G722不起作用.\ncodec-accept 介绍 accept 官方的解释是：\nSimilar to mask and consume but doesn\u0026rsquo;t remove the codec from the list of offered codecs. This means that a codec listed under accept will still be offered to the remote peer, but if the remote peer rejects it, it will still be accepted towards the original offerer and then used for transcoding. It is a more selective version of what the always transcode flag does.\n意思是： 和mask功能一样,但是不会删除codec, 当双向不一致会转码.\n验证 codec-accept-PCMA(源sdp含有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,\u0026lt;br/\u0026gt;telephone-event opensips-\u0026gt;\u0026gt;+uas: INVITE Note over opensips,uas: PCMU, PCMA,\u0026lt;br/\u0026gt;telephone-event uas--\u0026gt;\u0026gt;-opensips: 200OK Note over uas,opensips: PCMU,\u0026lt;br/\u0026gt;telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMA,\u0026lt;br/\u0026gt;telephone-event 可以看到，这种方式设置了A-leg的编码, A-leg和B-leg之间实现转码.\ncodec-accept-PCMA codec-transcode-G722(uas使用G722) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,\u0026lt;br/\u0026gt;telephone-event opensips-\u0026gt;\u0026gt;+uas: INVITE Note over opensips,uas: PCMU, PCMA,\u0026lt;br/\u0026gt;telephone-event uas--\u0026gt;\u0026gt;-opensips: 200OK Note over uas,opensips: G722,\u0026lt;br/\u0026gt;telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMA,\u0026lt;br/\u0026gt;telephone-event codec-accept-G722(源sdp没有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,\u0026lt;br/\u0026gt;telephone-event opensips-\u0026gt;\u0026gt;+uas: INVITE Note over opensips,uas: PCMU, PCMA,\u0026lt;br/\u0026gt;telephone-event uas--\u0026gt;\u0026gt;-opensips: 200OK Note over uas,opensips: PCMU,\u0026lt;br/\u0026gt;telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMU,\u0026lt;br/\u0026gt;telephone-event 这种方式下,codec-accept-G722不起作用.\ncodec-consume 介绍 consume 官方的解释是：\nIdentical to mask but enables the transcoding engine even if no other transcoding related options are given.\n意思是: 和mask功能一样，但是会开启转码引擎，即使没有其他转码相关的选项。\n验证 codec-consume-PCMA(源sdp含有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMU,telephone-event uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: PCMU,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMA,telephone-event 可以看到,consume-PCMA设置后, 转发到B-leg的INVITE删除了PCMA,但是转发到A-leg的200OK,选择了PCMA, A-leg和B-leg实现转码。\ncodec-consume-PCMA codec-transcode-G722(uas使用G722) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMU,G722,telephone-event uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: G722,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMA,telephone-event codec-consume-G722(源sdp没有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMU,PCMA,telephone-event uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: PCMU,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMU, telephone-event 这种方式下,codec-accept-G722不起作用.\ncodec-except 介绍 except 官方的解释是：\nContains a list of strings. Each string is the name of a codec that should be included in the list of codecs offered. This is primarily useful to block all codecs (strip -\u0026gt; all or mask -\u0026gt; all) except the ones given in the except whitelist. Codecs that were not present in the original list of codecs offered by the client will be ignored.\n意思就是: 白名单，和codec-strip-allorcodec-mask-all一起使用才有效。\n验证 codec-strip-all codec-except-PCMA(源sdp含有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMA uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: PCMA,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMA codec-strip-all codec-except-G722(源sdp没有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMU,PCMA,telephone-event uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: PCMU,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMU,telephone-event 这种方式下,codec-accept-G722不起作用.\ncodec-offer 介绍 offer 官方的解释是：\nThis is identical to except but additionally allows the codec order to be changed. So the first codec listed in offer will be the primary (preferred) codec in the output SDP, even if it wasn\u0026rsquo;t originally so.\n意思就是：和except一样，但是会改变编码顺序.\n验证 codec-strip-all codec-offer-PCMA codec-offer-PCMU(源sdp含有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMA,PCMU uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: PCMA,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMA 可以看到,转发B-leg的INVITE时，编码顺序改变了。 codec-strip-all codec-except-PCMA codec-except-PCMU在转发B-leg的INVITE时, PCMU PCMA编码顺序不会变.\ncodec-strip-all codec-offer-G722(源sdp没有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMU,PCMA,telephone-event uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: PCMU,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMU,telephone-event 这种方式下,codec-accept-G722不起作用.\ncodec-ignore 介绍 ignore 官方的解释是：\nSimilar to the strip option below, but affects only codecs listed in the incoming received SDP. Codecs listed here are treated as if they were never offered, and so will not be used for media towards the offerer. Note that codecs listed here would still be used in the outgoing rewritten offer SDP, unless the same codecs are also listed under strip. This means that if a codec is only ignored but not stripped, and if that codec is then accepted by the answerer, transcoding will necessarily be enabled.\n验证 codec-ignore-PCMA(源sdp含有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMU,PCMA,telephone-event uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: PCMU,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips,microSIP: PCMA,telephone-event 可以看到，转发A-leg的200OK,使用了PCMA,实现转码. 其效果和accept一样\ncodec-ignore-G722(源sdp没有的codecs) sequenceDiagram microSIP-\u0026gt;\u0026gt;opensips: INVITE Note over microSIP,opensips: PCMU,PCMA,telephone-event opensips-\u0026gt;\u0026gt;uas: INVITE Note over opensips,uas: PCMU,PCMA,telephone-event uas--\u0026gt;\u0026gt;opensips: 200OK Note over uas,opensips: PCMU,telephone-event opensips--\u0026gt;\u0026gt; microSIP: 200OK Note over opensips, microSIP: PCMU,telephone-event 这种方式下,codec-accept-G722不起作用.\nrtpengine interface设置 当我们使用 opensips或者kamailio+rtpengine做sbc网关时, 需要根据内外网环境自动切换媒体ip, 此时rtpengine的监听interface设置就至关重要。下面是rtpengine.conf的设置介绍:\n1 2 3 4 5 6 7 8 ### legacy interface config syntax: # interface = any ### a single interface: # interface = 123.234.345.456 ### separate multiple interfaces with semicolons: # interface = internal/12.23.34.45;external/23.34.45.54 ### for different advertised address: # interface = 12.23.34.45!23.34.45.56 当有多个网卡时, 可以使用interface = internal/192.168.2.234;external/23.34.45.54设置。 当有多个外网ip时,可以使用interface = 23.34.45.54!23.34.45.55设置。 但是实际在使用过程中， sbc都是在内网部署，网关或者路由器做nat转换, 转发请求到sbc上。 此时rtpengine是单网卡，监听的ip是内网ip, 如何设置外网ip呢, 主要有两种方式:\ninterface = LOCAL_IP!PUBLIC_IP 这种方式设置,默认生成的SDP信息中的c=,o=会是PUBLIC_IP, 但是当我们想要c=,o=换成LOCAL_IP, 可以在rtpengine_manager(\u0026quot;media-address=LOCAL_IP\u0026quot;)强转成LOCAL_IP。\n但是这种只会改变c=为LOCAL_IP, o=还是PUBLIC_IP。实际也不会有什么影响。毕竟真正使用的是c=\ninterface=pub/LOCAL_IP!PUBLIC_IP;priv/LOCAL_IP 这种是最佳方式,pub,priv这两个名字你可以随便起，但是当你使用rtpengine_manager()时，一定要和这两个名字一致。\n在rtpengine的ng_control中，用的参数是direction=[\u0026quot;priv\u0026quot;,\u0026quot;pub\u0026quot;]。\n需要注意的是当我们使用opensips时,要用in-iface=priv out-iface=pub,这样往rtpengine发送的offer才会转成direction=[\u0026quot;priv\u0026quot;,\u0026quot;pub\u0026quot;]。\nopensips的官方文档rtpengine模块中介绍用的是in-iface=internal out-iface=external, 我们在rtpengine.conf中设置的是pub/LOCAL_IP!PUBLIC_IP;priv/LOCAL_IP, 要灵活变通，改成in-iface=priv out-iface=pub。\nin-iface=priv out-iface=pub的含义是: 进来请求的sdp用的是priv的ip, 转发请求的sdp用的是pub的ip,这种是外呼的情况。\n我们只需要在转发INVITE时,设置此参数即可, 收到183或者200OK时，不需要再设置。\ninterface = internal/LOCAL_IP;external/PUBLIC_IP 这种只能在双网卡的环境下才能使用, 单网卡的环境下，这样使用会报错。\n1 2 3 4 5 [1756439280.576834] ERR: [ccb5793a-ff2d-123e-8d9c-000c29684ffd]: [core] Failure while trying to bind a port to the socket [1756439280.576856] ERR: [ccb5793a-ff2d-123e-8d9c-000c29684ffd]: [core] Failed to get 2 consecutive ports on interface 10.64.65.46 for media relay (last error: Cannot assign requested address) [1756439280.576868] ERR: [ccb5793a-ff2d-123e-8d9c-000c29684ffd]: [core] Failed to get 2 consecutive ports on all locals of logical \u0026#39;external\u0026#39; [1756439280.576872] ERR: [ccb5793a-ff2d-123e-8d9c-000c29684ffd]: [core] Error allocating media ports [1756439280.576885] ERR: [ccb5793a-ff2d-123e-8d9c-000c29684ffd]: [core] Destroying call 即使在/etc/sysctl.conf中添加net.ipv4.ip_nonlocal_bind=1,能解决报错问题, 因为没有PUBLIC_IP网卡,还是会出现没有声音情况。\n","date":"2025-09-05T09:31:00+08:00","image":"https://QuincyGao.github.io/p/%E5%85%B3%E4%BA%8Ertpengine%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E7%9F%A5%E8%AF%86/backup_hu7820738755410375165.jpg","permalink":"https://QuincyGao.github.io/p/%E5%85%B3%E4%BA%8Ertpengine%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E7%9F%A5%E8%AF%86/","title":"关于rtpengine的几个小知识"},{"content":"背景 kemix模块是kamailio提供另外一种可不通过.cfg文件来写主路由的方式,可以使用脚本语言来写主路由, 目前支持的脚本语言有JavaScript,Lua,Python2,Python3,Ruby,Squirrel。\n此模块不同于APP_相关的其他模块，APP_相关的模块是在.cfg的路由中调用相关脚本来执行命令, 而kemix模块是在.cfg中加载模块，然后在脚本中写主路由。\n官方文档地址: kemi, 官方基础脚本示例: base-kemi\n本次测试的脚本语言是:JavaScript。\n本次测试的版本为:\nkamailio 5.8.5\n编译安装 因为本次测试的是JavaScript, 所以在编译kamailio时，把modules.lst里exclude_modules去掉app_jsdt.so。\napp_jsdt依赖外部库为libm, 请提前安装。\n脚本示例 kamailio-basic-kemi.cfg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 #!KAMAILIO # # Kamailio SIP Server v5.0 - default configuration script # - web: https://www.kamailio.org # - git: http://sip-router.org # # Direct your questions about this file to: \u0026lt;sr-users@lists.kamailio.org\u0026gt; # # Refer to the Core CookBook at https://www.kamailio.org/wikidocs/ # for an explanation of possible statements, functions and parameters. # # Several features can be enabled using \u0026#39;#!define WITH_FEATURE\u0026#39; directives: # # *** To run in debug mode: # - define WITH_DEBUG # # *** To enable mysql: # - define WITH_MYSQL # # *** To enable authentication execute: # - enable mysql # - define WITH_AUTH # - add users using \u0026#39;kamctl\u0026#39; # # *** To enable IP authentication execute: # - enable mysql # - enable authentication # - define WITH_IPAUTH # - add IP addresses with group id \u0026#39;1\u0026#39; to \u0026#39;address\u0026#39; table # # *** To enable persistent user location execute: # - enable mysql # - define WITH_USRLOCDB # # *** To enable nat traversal execute: # - define WITH_NAT # - install RTPProxy: http://www.rtpproxy.org # - start RTPProxy: # rtpproxy -l _your_public_ip_ -s udp:localhost:7722 # - option for NAT SIP OPTIONS keepalives: WITH_NATSIPPING # # *** To use RTPEngine (instead of RTPProxy) for nat traversal execute: #!define WITH_RTPENGINE # - install RTPEngine: https://github.com/sipwise/rtpengine # - start RTPEngine: # rtpengine --listen-ng=127.0.0.1:2223 ... # # *** To enable TLS support execute: # - adjust CFGDIR/tls.cfg as needed # - define WITH_TLS # # *** To enhance accounting execute: # - enable mysql # - define WITH_ACCDB # - add following columns to database #!ifdef ACCDB_COMMENT ALTER TABLE acc ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE acc ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE acc ADD COLUMN src_ip varchar(64) NOT NULL default \u0026#39;\u0026#39;; ALTER TABLE acc ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE acc ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE acc ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE missed_calls ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE missed_calls ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE missed_calls ADD COLUMN src_ip varchar(64) NOT NULL default \u0026#39;\u0026#39;; ALTER TABLE missed_calls ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE missed_calls ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE missed_calls ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT \u0026#39;\u0026#39;; #!endif #!define WITH_MYSQL #!define WITH_USRLOCDB #!define WITH_NAT #!define WITH_ANTIFLOOD #!define WITH_ACCDB #!define WITH_CFGJSDT ####### Include Local Config If Exists ######### import_file \u0026#34;kamailio-local.cfg\u0026#34; ####### Defined Values ######### # *** Value defines - IDs used later in config #!ifdef WITH_MYSQL # - database URL - used to connect to database server by modules such # as: auth_db, acc, usrloc, a.s.o. #!ifndef DBURL #!define DBURL \u0026#34;mysql://kamauser:kamailiorw@172.16.4.111:3306/kamailio_5_8_5\u0026#34; #!endif #!endif #!define MULTIDOMAIN 0 # - flags # FLT_ - per transaction (message) flags #\tFLB_ - per branch flags #!define FLT_ACC 1 #!define FLT_ACCMISSED 2 #!define FLT_ACCFAILED 3 #!define FLT_NATS 5 #!define FLB_NATB 6 #!define FLB_NATSIPPING 7 ####### Global Parameters ######### ### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR #!ifdef WITH_DEBUG debug=4 log_stderror=yes #!else debug=2 log_stderror=no #!endif memdbg=5 memlog=5 #!ifdef WITH_CFGLUA log_prefix=\u0026#34;LUA {$rm}: \u0026#34; #!define KEMIENGINE \u0026#34;lua\u0026#34; #!define KEMIMODULE \u0026#34;app_lua\u0026#34; #!define KEMILOAD \u0026#34;/usr/local/etc/kamailio/kamailio-basic-kemi-lua.lua\u0026#34; #!endif #!ifdef WITH_CFGPYTHON log_prefix=\u0026#34;PY2 {$rm}: \u0026#34; #!define KEMIENGINE \u0026#34;python\u0026#34; #!define KEMIMODULE \u0026#34;app_python\u0026#34; #!define KEMILOAD \u0026#34;/usr/local/etc/kamailio/kamailio-basic-kemi-python.py\u0026#34; #!endif #!ifdef WITH_CFGPYTHON3 log_prefix=\u0026#34;PY3 {$rm}: \u0026#34; #!define KEMIENGINE \u0026#34;python\u0026#34; #!define KEMIMODULE \u0026#34;app_python3\u0026#34; #!define KEMILOAD \u0026#34;/usr/local/etc/kamailio/kamailio-basic-kemi-python.py\u0026#34; #!endif #!ifdef WITH_CFGPYTHON3S log_prefix=\u0026#34;PY8 {$rm}: \u0026#34; #!define KEMIENGINE \u0026#34;python\u0026#34; #!define KEMIMODULE \u0026#34;app_python3s\u0026#34; #!define KEMILOAD \u0026#34;/usr/local/etc/kamailio/kamailio-basic-kemi-python3s.py\u0026#34; #!endif #!ifdef WITH_CFGJSDT log_prefix=\u0026#34;JSC {$rm}: \u0026#34; #!define KEMIENGINE \u0026#34;jsdt\u0026#34; #!define KEMIMODULE \u0026#34;app_jsdt\u0026#34; #!define KEMILOAD \u0026#34;/usr/local/etc/kamailio/kamailio-basic-kemi-jsdt.js\u0026#34; #!endif #!ifdef WITH_CFGSQLANG log_prefix=\u0026#34;SQL {$rm}: \u0026#34; #!define KEMIENGINE \u0026#34;sqlang\u0026#34; #!define KEMIMODULE \u0026#34;app_sqlang\u0026#34; #!define KEMILOAD \u0026#34;/usr/local/etc/kamailio/kamailio-basic-kemi-sqlang.sq\u0026#34; #!endif #!ifdef WITH_CFGRUBY log_prefix=\u0026#34;RUB {$rm}: \u0026#34; #!define KEMIENGINE \u0026#34;ruby\u0026#34; #!define KEMIMODULE \u0026#34;app_ruby\u0026#34; #!define KEMILOAD \u0026#34;/usr/local/etc/kamailio/kamailio-basic-kemi-ruby.rb\u0026#34; #!endif #!ifndef KEMIENGINE log_prefix=\u0026#34;NAT {$rm}: \u0026#34; #!endif latency_cfg_log=2 latency_log=2 latency_limit_action=100000 latency_limit_db=200000 log_facility=LOG_LOCAL0 fork=yes children=2 /* uncomment the next line to disable TCP (default on) */ #disable_tcp=yes /* uncomment the next line to disable the auto discovery of local aliases * based on reverse DNS on IPs (default on) */ #auto_aliases=no /* add local domain aliases */ #alias=\u0026#34;sip.mydomain.com\u0026#34; /* uncomment and configure the following line if you want Kamailio to * bind on a specific interface/port/proto (default bind on all available) */ #listen=udp:10.0.0.10:5060 listen=udp:172.16.4.111:5461 listen=tcp:172.16.4.111:5461 listen=udp:172.16.4.111:5464 listen=udp:172.16.4.111:5465 /* port to listen to * - can be specified more than once if needed to listen on many ports */ #port=5060 #!ifdef WITH_TLS enable_tls=yes #!endif # life time of TCP connection when there is no traffic # - a bit higher than registration expires to cope with UA behind NAT tcp_connection_lifetime=3605 ####### Modules Section ######## /* set paths to location of modules (to sources or installation folders) */ # mpath=\u0026#34;/usr/local/lib/kamailio/modules/\u0026#34; #!ifdef WITH_MYSQL loadmodule \u0026#34;db_mysql.so\u0026#34; #!endif loadmodule \u0026#34;jsonrpcs.so\u0026#34; loadmodule \u0026#34;kex.so\u0026#34; loadmodule \u0026#34;corex.so\u0026#34; loadmodule \u0026#34;tm.so\u0026#34; loadmodule \u0026#34;tmx.so\u0026#34; loadmodule \u0026#34;sl.so\u0026#34; loadmodule \u0026#34;rr.so\u0026#34; loadmodule \u0026#34;pv.so\u0026#34; loadmodule \u0026#34;maxfwd.so\u0026#34; loadmodule \u0026#34;usrloc.so\u0026#34; loadmodule \u0026#34;registrar.so\u0026#34; loadmodule \u0026#34;textops.so\u0026#34; loadmodule \u0026#34;siputils.so\u0026#34; loadmodule \u0026#34;xlog.so\u0026#34; loadmodule \u0026#34;sanity.so\u0026#34; loadmodule \u0026#34;ctl.so\u0026#34; loadmodule \u0026#34;cfg_rpc.so\u0026#34; loadmodule \u0026#34;acc.so\u0026#34; loadmodule \u0026#34;kemix.so\u0026#34; #!ifdef WITH_AUTH loadmodule \u0026#34;auth.so\u0026#34; loadmodule \u0026#34;auth_db.so\u0026#34; #!ifdef WITH_IPAUTH loadmodule \u0026#34;permissions.so\u0026#34; #!endif #!endif #!ifdef WITH_NAT loadmodule \u0026#34;nathelper.so\u0026#34; #!ifdef WITH_RTPENGINE loadmodule \u0026#34;rtpengine.so\u0026#34; #!else loadmodule \u0026#34;rtpproxy.so\u0026#34; #!endif #!endif #!ifdef WITH_TLS loadmodule \u0026#34;tls.so\u0026#34; #!endif #!ifdef WITH_DEBUG loadmodule \u0026#34;debugger.so\u0026#34; #!endif #!ifdef WITH_ANTIFLOOD loadmodule \u0026#34;htable.so\u0026#34; loadmodule \u0026#34;pike.so\u0026#34; #!endif #!ifdef KEMIENGINE loadmodule KEMIMODULE #!endif # ----------------- setting module-specific parameters --------------- # ----- jsonrpcs params ----- modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;pretty_format\u0026#34;, 1) /* set the path to RPC fifo control file */ # modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;fifo_name\u0026#34;, \u0026#34;/run/kamailio/kamailio_rpc.fifo\u0026#34;) /* set the path to RPC unix socket control file */ # modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;dgram_socket\u0026#34;, \u0026#34;/run/kamailio/kamailio_rpc.sock\u0026#34;) # ----- ctl params ----- #modparam(\u0026#34;ctl\u0026#34;, \u0026#34;binrpc\u0026#34;, \u0026#34;unix:/run/kamailio/kamailio_ctl\u0026#34;) # ----- tm params ----- # auto-discard branches from previous serial forking leg modparam(\u0026#34;tm\u0026#34;, \u0026#34;failure_reply_mode\u0026#34;, 3) # default retransmission timeout: 30sec modparam(\u0026#34;tm\u0026#34;, \u0026#34;fr_timer\u0026#34;, 30000) # default invite retransmission timeout after 1xx: 120sec modparam(\u0026#34;tm\u0026#34;, \u0026#34;fr_inv_timer\u0026#34;, 120000) # ----- rr params ----- # add value to ;lr param to cope with most of the UAs modparam(\u0026#34;rr\u0026#34;, \u0026#34;enable_full_lr\u0026#34;, 1) # do not append from tag to the RR (no need for this script) modparam(\u0026#34;rr\u0026#34;, \u0026#34;append_fromtag\u0026#34;, 0) # ----- registrar params ----- modparam(\u0026#34;registrar\u0026#34;, \u0026#34;method_filtering\u0026#34;, 1) /* uncomment the next line to disable parallel forking via location */ # modparam(\u0026#34;registrar\u0026#34;, \u0026#34;append_branches\u0026#34;, 0) /* uncomment the next line not to allow more than 10 contacts per AOR */ #modparam(\u0026#34;registrar\u0026#34;, \u0026#34;max_contacts\u0026#34;, 10) # max value for expires of registrations modparam(\u0026#34;registrar\u0026#34;, \u0026#34;max_expires\u0026#34;, 3600) # set it to 1 to enable GRUU modparam(\u0026#34;registrar\u0026#34;, \u0026#34;gruu_enabled\u0026#34;, 0) # ----- acc params ----- /* what special events should be accounted ? */ modparam(\u0026#34;acc\u0026#34;, \u0026#34;early_media\u0026#34;, 0) modparam(\u0026#34;acc\u0026#34;, \u0026#34;report_ack\u0026#34;, 0) modparam(\u0026#34;acc\u0026#34;, \u0026#34;report_cancels\u0026#34;, 0) /* by default we do not adjust the direct of the sequential requests. * if you enable this parameter, be sure the enable \u0026#34;append_fromtag\u0026#34; * in \u0026#34;rr\u0026#34; module */ modparam(\u0026#34;acc\u0026#34;, \u0026#34;detect_direction\u0026#34;, 0) /* account triggers (flags) */ modparam(\u0026#34;acc\u0026#34;, \u0026#34;log_flag\u0026#34;, FLT_ACC) modparam(\u0026#34;acc\u0026#34;, \u0026#34;log_missed_flag\u0026#34;, FLT_ACCMISSED) modparam(\u0026#34;acc\u0026#34;, \u0026#34;log_extra\u0026#34;, \u0026#34;src_user=$fU;src_domain=$fd;src_ip=$si;\u0026#34; \u0026#34;dst_ouser=$tU;dst_user=$rU;dst_domain=$rd\u0026#34;) modparam(\u0026#34;acc\u0026#34;, \u0026#34;failed_transaction_flag\u0026#34;, FLT_ACCFAILED) /* enhanced DB accounting */ #!ifdef WITH_ACCDB modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_flag\u0026#34;, FLT_ACC) modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_missed_flag\u0026#34;, FLT_ACCMISSED) modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_extra\u0026#34;, \u0026#34;src_user=$fU;src_domain=$fd;src_ip=$si;\u0026#34; \u0026#34;dst_ouser=$tU;dst_user=$rU;dst_domain=$rd\u0026#34;) #!endif # ----- usrloc params ----- /* enable DB persistency for location entries */ modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;preload\u0026#34;, \u0026#34;location\u0026#34;) #!ifdef WITH_USRLOCDB modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;db_mode\u0026#34;, 2) modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;use_domain\u0026#34;, MULTIDOMAIN) #!endif # ----- auth_db params ----- #!ifdef WITH_AUTH modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;calculate_ha1\u0026#34;, yes) modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;password_column\u0026#34;, \u0026#34;password\u0026#34;) modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;load_credentials\u0026#34;, \u0026#34;\u0026#34;) modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;use_domain\u0026#34;, MULTIDOMAIN) # ----- permissions params ----- #!ifdef WITH_IPAUTH modparam(\u0026#34;permissions\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;permissions\u0026#34;, \u0026#34;db_mode\u0026#34;, 1) #!endif #!endif #!ifdef WITH_NAT #!ifdef WITH_RTPENGINE # ----- rtpengine params ----- modparam(\u0026#34;rtpengine\u0026#34;, \u0026#34;rtpengine_sock\u0026#34;, \u0026#34;udp:172.16.4.111:2222\u0026#34;) #!else # ----- rtpproxy params ----- modparam(\u0026#34;rtpproxy\u0026#34;, \u0026#34;rtpproxy_sock\u0026#34;, \u0026#34;udp:127.0.0.1:7722\u0026#34;) #!endif # ----- nathelper params ----- modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;natping_interval\u0026#34;, 30) modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;ping_nated_only\u0026#34;, 1) modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;sipping_bflag\u0026#34;, FLB_NATSIPPING) modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;sipping_from\u0026#34;, \u0026#34;sip:pinger@kamailio.org\u0026#34;) # params needed for NAT traversal in other modules modparam(\u0026#34;nathelper|registrar\u0026#34;, \u0026#34;received_avp\u0026#34;, \u0026#34;$avp(RECEIVED)\u0026#34;) modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;nat_bflag\u0026#34;, FLB_NATB) #!endif #!ifdef WITH_TLS # ----- tls params ----- modparam(\u0026#34;tls\u0026#34;, \u0026#34;config\u0026#34;, \u0026#34;/usr/local/etc/kamailio/tls.cfg\u0026#34;) #!endif #!ifdef WITH_DEBUG # ----- debugger params ----- modparam(\u0026#34;debugger\u0026#34;, \u0026#34;cfgtrace\u0026#34;, 1) #!endif #!ifdef WITH_ANTIFLOOD # ----- pike params ----- modparam(\u0026#34;pike\u0026#34;, \u0026#34;sampling_time_unit\u0026#34;, 2) modparam(\u0026#34;pike\u0026#34;, \u0026#34;reqs_density_per_unit\u0026#34;, 16) modparam(\u0026#34;pike\u0026#34;, \u0026#34;remove_latency\u0026#34;, 4) # ----- htable params ----- # ip ban htable with autoexpire after 5 minutes modparam(\u0026#34;htable\u0026#34;, \u0026#34;htable\u0026#34;, \u0026#34;ipban=\u0026gt;size=8;autoexpire=300;\u0026#34;) #!endif #!ifdef KEMIENGINE modparam(KEMIMODULE, \u0026#34;load\u0026#34;, KEMILOAD) cfgengine KEMIENGINE #!else cfgengine \u0026#34;native\u0026#34; include_file \u0026#34;/usr/local/etc/kamailio/kamailio-basic-kemi-native.cfg\u0026#34; #!endif kamailio-basic-kemi-jsdt.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 // Kamailio - equivalent of routing blocks in JavaScript // // KSR - the new dynamic object exporting Kamailio functions // sr - the old static object exporting Kamailio functions // // global variables corresponding to defined values (e.g., flags) in kamailio.cfg var FLT_ACC=1 var FLT_ACCMISSED=2 var FLT_ACCFAILED=3 var FLT_NATS=5 var FLB_NATB=6 var FLB_NATSIPPING=7 // SIP request routing // equivalent of request_route{} function ksr_request_route() { // KSR.sl.sl_send_reply(100, \u0026#34;Intelligent trying\u0026#34;); // KSR.info(\u0026#34;===== request - from kamailio javascript script\\n\u0026#34;); // per request initial checks ksr_route_reqinit(); // NAT detection ksr_route_natdetect(); // CANCEL processing if (KSR.is_CANCEL()) { if(KSR.tm.t_check_trans()\u0026gt;0) { ksr_route_relay(); } return; } // handle retransmissions if (!KSR.is_ACK()) { if (KSR.tmx.t_precheck_trans()\u0026gt;0) { KSR.tm.t_check_trans(); return; } if (KSR.tm.t_check_trans()==0) { return; } } // handle requests within SIP dialogs ksr_route_withindlg(); // -- only initial requests (no To tag) // authentication // ksr_route_auth(); // record routing for dialog forming requests (in case they are routed) // - remove preloaded route headers KSR.hdr.remove(\u0026#34;Route\u0026#34;); if (KSR.is_method_in(\u0026#34;IS\u0026#34;)) { KSR.rr.record_route(); } // account only INVITEs if (KSR.is_INVITE()) { KSR.setflag(FLT_ACC); // do accounting } // dispatch requests to foreign domains ksr_route_sipout(); // -- requests for my local domains // handle registrations ksr_route_registrar(); if (KSR.corex.has_ruri_user() \u0026lt; 0) { // request with no Username in RURI KSR.sl.sl_send_reply(484, \u0026#34;Address Incomplete\u0026#34;); return; } // user location service ksr_route_location(); return; } // wrapper around tm relay function function ksr_route_relay() { // enable additional event routes for forwarded requests // - serial forking, RTP relaying handling, a.s.o. if (KSR.is_method_in(\u0026#34;IBSU\u0026#34;)) { if (KSR.tm.t_is_set(\u0026#34;branch_route\u0026#34;)\u0026lt;0) { KSR.tm.t_on_branch(\u0026#34;ksr_branch_manage\u0026#34;); } } if (KSR.is_method_in(\u0026#34;ISU\u0026#34;)) { if (KSR.tm.t_is_set(\u0026#34;onreply_route\u0026#34;)\u0026lt;0) { KSR.tm.t_on_reply(\u0026#34;ksr_onreply_manage\u0026#34;); } } if (KSR.is_INVITE()) { if (KSR.tm.t_is_set(\u0026#34;failure_route\u0026#34;)\u0026lt;0) { KSR.tm.t_on_failure(\u0026#34;ksr_failure_manage\u0026#34;); } } if (KSR.tm.t_relay()\u0026lt;0) { KSR.sl.sl_reply_error(); } KSR.x.exit(); } // Per SIP request initial checks function ksr_route_reqinit() { if (!KSR.is_myself_srcip()) { var srcip = KSR.kx.get_srcip(); if (KSR.htable.sht_match_name(\u0026#34;ipban\u0026#34;, \u0026#34;eq\u0026#34;, srcip) \u0026gt; 0) { // ip is already blocked KSR.dbg(\u0026#34;request from blocked IP - \u0026#34; + KSR.kx.get_method() + \u0026#34; from \u0026#34; + KSR.kx.get_furi() + \u0026#34; (IP:\u0026#34; + srcip + \u0026#34;:\u0026#34; + KSR.kx.get_srcport() + \u0026#34;)\\n\u0026#34;); KSR.x.exit(); } if (KSR.pike.pike_check_req()\u0026lt;0) { KSR.err(\u0026#34;ALERT: pike blocking \u0026#34; + KSR.kx.get_method() + \u0026#34; from \u0026#34; + KSR.kx.get_furi() + \u0026#34; (IP:\u0026#34; + srcip + \u0026#34;:\u0026#34; + KSR.kx.get_srcport() + \u0026#34;)\\n\u0026#34;); KSR.htable.sht_seti(\u0026#34;ipban\u0026#34;, srcip, 1); KSR.x.exit(); } } if (KSR.corex.has_user_agent()\u0026gt;0) { var UA = KSR.kx.gete_ua(); if (UA.indexOf(\u0026#34;friendly\u0026#34;)\u0026gt;=0 || UA.indexOf(\u0026#34;scanner\u0026#34;)\u0026gt;=0 || UA.indexOf(\u0026#34;sipcli\u0026#34;)\u0026gt;=0 || UA.indexOf(\u0026#34;sipvicious\u0026#34;)\u0026gt;=0 || UA.indexOf(\u0026#34;VaxSIPUserAgent\u0026#34;)\u0026gt;=0 || UA.indexOf(\u0026#34;pplsip\u0026#34;)\u0026gt;= 0) { KSR.sl.sl_send_reply(200, \u0026#34;OK\u0026#34;); KSR.x.exit(); } } if (KSR.maxfwd.process_maxfwd(10) \u0026lt; 0) { KSR.sl.sl_send_reply(483, \u0026#34;Too Many Hops\u0026#34;); KSR.x.exit(); } if (KSR.is_OPTIONS() \u0026amp;\u0026amp; KSR.is_myself_ruri() \u0026amp;\u0026amp; KSR.corex.has_ruri_user() \u0026lt; 0) { KSR.sl.sl_send_reply(200, \u0026#34;Keepalive\u0026#34;); KSR.x.exit(); } if (KSR.sanity.sanity_check(17895, 7)\u0026lt;0) { KSR.err(\u0026#34;Malformed SIP message from \u0026#34; + KSR.kx.get_srcip() + \u0026#34;:\u0026#34; + KSR.kx.get_srcport() + \u0026#34;\\n\u0026#34;); KSR.x.exit(); } } // Handle requests within SIP dialogs function ksr_route_withindlg() { if (KSR.siputils.has_totag()\u0026lt;0) { return; } // sequential request within a dialog should // take the path determined by record-routing if (KSR.rr.loose_route()\u0026gt;0) { ksr_route_dlguri(); if (KSR.is_BYE()) { KSR.setflag(FLT_ACC); // do accounting ... KSR.setflag(FLT_ACCFAILED); // ... even if the transaction fails } else if (KSR.is_ACK()) { // ACK is forwarded statelessly ksr_route_natmanage(); } else if (KSR.is_NOTIFY()) { // Add Record-Route for in-dialog NOTIFY as per RFC 6665. KSR.rr.record_route(); } ksr_route_relay(); KSR.x.exit(); } if (KSR.is_ACK()) { if (KSR.tm.t_check_trans() \u0026gt;0) { // no loose-route, but stateful ACK; // must be an ACK after a 487 // or e.g. 404 from upstream server ksr_route_relay(); KSR.x.exit(); } else { // ACK without matching transaction ... ignore and discard KSR.x.exit(); } } KSR.sl.sl_send_reply(404, \u0026#34;Not here\u0026#34;); KSR.x.exit(); } // Handle SIP registrations function ksr_route_registrar() { if (!KSR.is_REGISTER()) { return; } if (KSR.isflagset(FLT_NATS)) { KSR.setbflag(FLB_NATB); // do SIP NAT pinging KSR.setbflag(FLB_NATSIPPING); } if (KSR.registrar.save(\u0026#34;location\u0026#34;, 0)\u0026lt;0) { KSR.sl.sl_reply_error(); } KSR.x.exit(); } // User location service function ksr_route_location() { var rc = KSR.registrar.lookup(\u0026#34;location\u0026#34;); if (rc\u0026lt;0) { KSR.tm.t_newtran(); if (rc==-1 || rc==-3) { KSR.sl.send_reply(404, \u0026#34;Not Found\u0026#34;); KSR.x.exit(); } else if (rc==-2) { KSR.sl.send_reply(405, \u0026#34;Method Not Allowed\u0026#34;); KSR.x.exit(); } } // when routing via usrloc, log the missed calls also if (KSR.is_INVITE()) { KSR.setflag(FLT_ACCMISSED); } ksr_route_relay(); KSR.x.exit(); } // IP authorization and user authentication function ksr_route_auth() { if (!KSR.is_REGISTER()) { if (KSR.permissions.allow_source_address(1)\u0026gt;0) { // source IP allowed return; } } if (KSR.is_REGISTER() || KSR.is_myself_furi()) { // authenticate requests if (KSR.auth_db.auth_check(KSR.kx.gete_fhost(), \u0026#34;subscriber\u0026#34;, 1)\u0026lt;0) { KSR.auth.auth_challenge(KSR.kx.gete_fhost(), 0); KSR.x.exit(); } // user authenticated - remove auth header if (!KSR.is_method_in(\u0026#34;RP\u0026#34;)) { KSR.auth.consume_credentials(); } } // if caller is not local subscriber, then check if it calls // a local destination, otherwise deny, not an open relay here if ((!KSR.is_myself_furi()) \u0026amp;\u0026amp; (!KSR.is_myself_ruri())) { KSR.sl.sl_send_reply(403, \u0026#34;Not relaying\u0026#34;); KSR.x.exit(); } return; } // Caller NAT detection function ksr_route_natdetect() { KSR.force_rport(); if (KSR.nathelper.nat_uac_test(19)\u0026gt;0) { if (KSR.is_REGISTER()) { KSR.nathelper.fix_nated_register(); } else if (KSR.siputils.is_first_hop()\u0026gt;0) { KSR.nathelper.set_contact_alias(); } KSR.setflag(FLT_NATS); } return; } // RTPProxy control function ksr_route_natmanage() { if (KSR.siputils.is_request()\u0026gt;0) { if (KSR.siputils.has_totag()\u0026gt;0) { if (KSR.rr.check_route_param(\u0026#34;nat=yes\u0026#34;)\u0026gt;0) { KSR.setbflag(FLB_NATB); } } } if (! (KSR.isflagset(FLT_NATS) || KSR.isbflagset(FLB_NATB))) { return; } KSR.rtpproxy.rtpproxy_manage(\u0026#34;co\u0026#34;); if (KSR.siputils.is_request()\u0026gt;0) { if (! KSR.siputils.has_totag()) { if (KSR.tmx.t_is_branch_route()\u0026gt;0) { KSR.rr.add_rr_param(\u0026#34;;nat=yes\u0026#34;); } } } if (KSR.siputils.is_reply()\u0026gt;0) { if (KSR.isbflagset(FLB_NATB)) { KSR.nathelper.set_contact_alias(); } } return; } // URI update for dialog requests function ksr_route_dlguri() { if (! KSR.isdsturiset()) { KSR.nathelper.handle_ruri_alias(); } return; } // Routing to foreign domains function ksr_route_sipout() { if (KSR.is_myself_ruri()) { return; } KSR.hdr.append_hf(\u0026#34;P-Hint: outbound\\r\\n\u0026#34;); ksr_route_relay(); KSR.x.exit(); } // Manage outgoing branches // equivalent of branch_route[...]{} function ksr_branch_manage() { KSR.dbg(\u0026#34;new branch [\u0026#34; + KSR.tm.t_get_branch_index() + \u0026#34;] to \u0026#34; + KSR.kx.get_ruri() + \u0026#34;\\n\u0026#34;); ksr_route_natmanage(); return; } // Manage incoming replies // equivalent of onreply_route[...]{} function ksr_onreply_manage() { KSR.dbg(\u0026#34;incoming reply\\n\u0026#34;); var scode = KSR.kx.gets_status(); if (scode\u0026gt;100 \u0026amp;\u0026amp; scode\u0026lt;=299) { ksr_route_natmanage(); } return; } // Manage failure routing cases // equivalent of failure_route[...]{} function ksr_failure_manage() { ksr_route_natmanage(); if (KSR.tm.t_is_canceled()\u0026gt;0) { return; } return; } // SIP response handling // equivalent of reply_route{} function ksr_reply_route() { KSR.info(\u0026#34;===== response - from kamailio JS script\\n\u0026#34;); return; } 测试 运行kamailio 1 kamailio -f /usr/local/etc/kamailio/kamailio-basic-kemi.cfg -m 216 -M 128 -DD -E -e 软电话注册 使用MicroSIP注册, 注册地址为172.16.4.111, 端口为5461, 用户名和密码为1003/1234。\n可以看到注册成功:\n1 2 3 1(1574) INFO: JSC {REGISTER}: \u0026lt;core\u0026gt; [core/receive.c:532]: receive_msg(): request-route executed in: 488 usec 2(1575) INFO: JSC {REGISTER}: \u0026lt;core\u0026gt; [core/receive.c:532]: receive_msg(): request-route executed in: 493 usec 1(1574) INFO: JSC {OPTIONS}: \u0026lt;core\u0026gt; [core/kemi.c:107]: sr_kemi_core_info(): ===== response - from kamailio JS script 总结 .js相对原生的.cfg脚本，#!ifdef xxx不再起作用，在.js内不想执行某个模块,只能把该函数注释掉。 .js内大部分功能都是通过KSR对象来调用kamailio模块。 kemi模式相对于原生的.cfg, 功能更加强大, 但是也更复杂。 这是官方测试的结果: kemi-Performances, 官方对比了原生.cfg,lua,python, 可以看到性能上有些差别,但是不太大。 ","date":"2025-08-27T09:51:31+08:00","image":"https://QuincyGao.github.io/p/kamailio-kemix-%E6%A8%A1%E5%9D%97/backup_hu11296238987054036200.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-kemix-%E6%A8%A1%E5%9D%97/","title":"kamailio kemix 模块"},{"content":"背景 homer是一个开源的SIP分析工具, 它可以帮助我们分析SIP协议的数据包,从而了解SIP协议的工作原理。 其官方代码地址为: homer, 目前最新版本为homer10。\n安装 官方安装文档为: homer10安装文档, 安装命令如下:\n1 2 3 git clone https://github.com/sipcapture/homer-docker.git cd all-in-one docker-compose up -d 查看docker-compose.yaml,可以看到需要的组件有:\n组件名称 组件介绍 必要性 alertmanager 告警组件 非必要 clickhouse 面向列的数据库组件 必要 grafana web管理页面 必要 docker-hepgen hep数据生成组件 非必要 heplify-server hep数据收集组件 必要 mailhog 邮件组件 非必要 node-exporter 节点监控组件 必要 qryn qryn组件 必要 vector 数据采集组件 必要 这些镜像直接从dockerhub拉取，然后运行docker-compose up -d 即可。\n关于grafana组件, 我做了两点修改：\n避免容器内下载qxip-flow-pannel插件,提前本地下载。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 services: grafana: build: context: ./grafana dockerfile: Dockerfile container_name: grafana volumes: - grafana_data:/var/lib/grafana - ./grafana/provisioning/:/etc/grafana/provisioning/ - ./grafana/plugins/k8spacket-nodegraphplugin-datasource:/var/lib/grafana/plugins/k8spacket-nodegraphplugin-datasource environment: - GF_SECURITY_ADMIN_USER=${ADMIN_USER:-admin} - GF_SECURITY_ADMIN_PASSWORD=${ADMIN_PASSWORD:-admin} - GF_USERS_ALLOW_SIGN_UP=false - GF_USERS_DEFAULT_THEME=light - GF_EXPLORE_ENABLED=true - GF_ALERTING_ENABLED=false - GF_UNIFIED_ALERTING_ENABLED=true - GF_PLUGINS_ALLOW_LOADING_UNSIGNED_PLUGINS=qxip-flow-panel restart: unless-stopped ports: - 3000:3000 depends_on: - clickhouse-server logging: options: max-size: \u0026#34;10m\u0026#34; grafana文件夹下的文件:\n1 2 ls defaults.ini Dockerfile plugins provisioning qxip-flow-panel-10.2.0.zip qxip-flow-panel的下载地址: qxip-flow-pannel-10.2.0\nDockerfile内容为:\n1 2 3 4 5 6 7 8 FROM grafana/grafana-oss:10.4.3 # 将提前下载好的插件 zip 包拷贝进镜像并解压 COPY qxip-flow-panel-10.2.0.zip /tmp/qxip-flow-panel.zip COPY defaults.ini /usr/share/grafana/conf/ RUN mkdir -p /var/lib/grafana/plugins \\ \u0026amp;\u0026amp; unzip /tmp/qxip-flow-panel.zip -d /var/lib/grafana/plugins/ 因为grafana的10+版本不再支持Angular, 为避免web页面出现this panel requires Angular (deprecated), 添加default.ini配置. 1 2 [feature_toggles] autoMigrateOldPanels = true 该default.ini文件的位置在grafana容器内/usr/share/grafana/conf/defaults.ini, 可以从容器内copy出来该文件,修改之后， 在Dockerfile里COPY defaults.ini /usr/share/grafana/conf/ 。\n之后, docker-compose build grafana重新编译grafana镜像包, docker-compose up -d grafana。\n服务正常的状态： 可以看到hepgen-bad和hepgen两个容器会多次重启,这个是正常的, 不断重启生成hep数据。\n体验 打开http://localhost:3000, 登录账号admin, 密码admin, 即可打开grafana管理页面。 可以看到的dashboard页面如下: 选择callflow查看调用流程: 选择hep flow中的一个sip信令, 即可查看该信令的详细信息: 在查看SIP Calls \u0026amp; Registers的dashboard页面, 可以看到调用流程: 实战 因为默认的docker-compose.yaml中使用hepgen和hepgen-bad不断生成hep数据, 不想随机生成sip, 停下这两个服务，然后使用opensips 3.5.5对接heplify-server。\n停止hepgen和hepgen-bad服务 1 docker-compose down hepgen hepgen-bad opensips 对接 heplify-server 可以参考opensips trace 模块文档, 配置opensips的trace模块, 将trace数据发送到heplify-server。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 socket=hep_udp:172.16.4.111:6000 ... loadmodule \u0026#34;dialog.so\u0026#34; loadmodule \u0026#34;tracer.so\u0026#34; loadmodule \u0026#34;proto_hep.so\u0026#34; modparam(\u0026#34;proto_hep\u0026#34;, \u0026#34;hep_id\u0026#34;,\u0026#34;[hid] 172.16.4.111:9060;transport=udp;version=3\u0026#34;) modparam(\u0026#34;tracer\u0026#34;, \u0026#34;trace_id\u0026#34;,\u0026#34;[tid]uri=hep:hid\u0026#34;) route { ... if (is_method(\u0026#34;REGISTER\u0026#34;)) { trace(\u0026#34;tid\u0026#34;, \u0026#34;t\u0026#34;,\u0026#34;sip\u0026#34;); } if (is_method(\u0026#34;INVITE\u0026#34;) \u0026amp;\u0026amp; !has_totag()) { trace(\u0026#34;tid\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;sip\u0026#34;); } } 使用软电话注册到opensips上,然后拨打电话，查看Call Flow: 这些信息正是opensips产生的数据。\n","date":"2025-08-19T14:43:27+08:00","image":"https://QuincyGao.github.io/p/homer10%E5%88%9D%E4%BD%93%E9%AA%8C/backup_hu18011304369406943653.jpg","permalink":"https://QuincyGao.github.io/p/homer10%E5%88%9D%E4%BD%93%E9%AA%8C/","title":"Homer10初体验"},{"content":"背景 compression模块用于对 SIP 消息进行压缩，以减少网络传输量。 相比于上一章kamailio, opensips不仅可以压缩body,还能压缩header和调整压缩率,使用上更灵活。 依赖外部模块:zlib。 官方文档地址: compression模块\n本次测试的opensips版本信息为:\nversion: opensips 3.5.5 (x86_64/linux)\n重要参数解析 1 2 # 压缩等级1-9, 默认是6,等级越高，压缩耗时越长. modparam(\u0026#34;compression\u0026#34;, \u0026#34;compression_level\u0026#34;, 6) 官方文档写的是: modparam(\u0026quot;mc\u0026quot;, \u0026quot;mc_level\u0026quot;, \u0026quot;3\u0026quot;),这个是错的，已提issue修正。\n重要函数 mc_compress([algo], flags, [whitelist]) 压缩当前的SIP消息\nalgo 压缩算法, 可选值为0(deflate), 1(gzip) flags 压缩参数,设置压缩的范围 b 压缩body,如果没有body,则不压缩 h 压缩所有header,除了白名单中的 s header和body可以分开压缩,将创建新的Comp-Hdrs头存储压缩后的header e 指定base64编码 whitelist 不压缩的白名单, 头可以使用\u0026quot;|\u0026ldquo;分隔。 mc_compact([whitelist], flags) flags: \u0026rsquo;n\u0026rsquo;不使用缩短名, 此函数有四种功能:\n没有在白名单中的header会被移除 相同类型的header会合并,使用\u0026rdquo;,\u0026ldquo;分隔 有短名的header会变成缩短名 sdp中小于96的rtpmap会被移除。 mc_decompress() 进行base64解码和gzip/deflate解压, 只能被用在REQUEST_ROUTE,LOCAL_ROUTE,FAILURE_ROUTE上.\n实战 配置示例 整体配置使用opensips-基础代理设置章节的配置, 并添加如下配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 loadmodule \u0026#34;compression.so\u0026#34; ... route { ... if ($si != \u0026#34;172.16.4.114\u0026#34;) { $du = \u0026#34;sip:172.16.4.114:5060\u0026#34;; $socket_out=\u0026#34;udp:172.16.4.111:5260\u0026#34;; } if (!mc_compress(0, \u0026#34;b\u0026#34;)) { xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---main--: compress failed.\\n\u0026#34;); } # # do lookup with method filtering # if (!lookup(\u0026#34;location\u0026#34;,\u0026#34;method-filtering\u0026#34;)) { # t_newtran(); # t_reply(404, \u0026#34;Not Found\u0026#34;); # exit; # } route(relay); } 在发送INVITE时, 设置mc_compress(0, \u0026quot;b\u0026quot;)。\n测试 测试的sip信令图为: mc_compress 关于flags参数,\ns只有和bh一起使用,才有效果,即:bhs。 此时消息体为： 新增了Comp-Hdrs,Headers-Encoding。\nh,e: 单独用没有任何效果. b: 压缩body,此时消息体为: 目前发送给freeswitch报错400 Bad Session Description: 已提交issue, 和kamailio对比了一下源码，虽然都是zlib库，但是kamailio用的是compress函数\n1 2 3 4 5 6 ret = compress( (unsigned char *)nbody.s, \u0026amp;nlen, (unsigned char *)obody.s, olen); if(ret != Z_OK) { LM_ERR(\u0026#34;error compressing body (%d)\\n\u0026#34;, ret); goto done; } opensips用的是compress2函数:\n1 2 3 4 5 rc = compress2((unsigned char*)bufcompressed.s, \u0026amp;temp, (unsigned char*)buf2compress.s, (unsigned long)buf2compress.len, mc_level); be: 以base64展示压缩后的body, 此时消息体为: 发送给freeswitch报错415 Unsupported Media Type: 说明freeswitch不支持这样的压缩方式。\nmc_compact 把上面的mc_compress(0,\u0026quot;b\u0026quot;)换成mc_compact()。\n原始的INVITE的数据为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 2025/08/13 13:53:16.834540 172.16.4.111:5260 -\u0026gt; 172.16.4.114:5060 INVITE sip:1008@172.16.4.111:5261 SIP/2.0 Record-Route: \u0026lt;sip:172.16.4.111:5260;lr\u0026gt; Via: SIP/2.0/UDP 172.16.4.111:5260;branch=z9hG4bK072a.b15e8867.0 Via: SIP/2.0/UDP 172.16.80.13:58807;received=172.16.80.13;rport=58807;branch=z9hG4bKPjf13de5761ca54d1895886f961b23ff64 Max-Forwards: 69 From: \u0026lt;sip:1005@172.16.4.111\u0026gt;;tag=9769c9c2b927412aaecd915eec7b1fb1 To: \u0026lt;sip:1008@172.16.4.111\u0026gt; Contact: \u0026lt;sip:1005@172.16.80.13:58807;ob\u0026gt; Call-ID: 970d5f96986b4b2aa5fa069dba9e2948 CSeq: 3216 INVITE Allow: PRACK, INVITE, ACK, BYE, CANCEL, UPDATE, INFO, SUBSCRIBE, NOTIFY, REFER, MESSAGE, OPTIONS Supported: replaces, 100rel, norefersub User-Agent: MicroSIP/3.21.6 Content-Type: application/sdp Content-Length: 321 v=0 o=- 3964082099 3964082099 IN IP4 172.16.4.111 s=pjmedia b=AS:84 t=0 0 a=X-nat:0 m=audio 30988 RTP/AVP 8 0 101 c=IN IP4 172.16.4.111 b=TIAS:64000 a=rtpmap:8 PCMA/8000 a=rtpmap:0 PCMU/8000 a=rtpmap:101 telephone-event/8000 a=fmtp:101 0-16 a=ssrc:580466598 cname:31a747bc699122c1 a=sendrecv a=rtcp:30989 使用mc_compact()后的INVITE数据为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 2025/08/13 13:46:24.616445 172.16.4.111:5260 -\u0026gt; 172.16.4.114:5060 INVITE sip:1008@172.16.4.111:5261 SIP/2.0 v: SIP/2.0/UDP 172.16.4.111:5260;branch=z9hG4bKf914.0b281385.0, SIP/2.0/UDP 172.16.80.13:58807;received=172.16.80.13;rport=58807; anch=z9hG4bKPj07898ec3e16c4350843b1a4de4a89ceb t: \u0026lt;sip:1008@172.16.4.111\u0026gt; f: \u0026lt;sip:1005@172.16.4.111\u0026gt;;tag=2b204cd2db594ce0bca55e8e525a1c14 CSeq: 6255 INVITE i: 9a37bdb33bb7418d9b6e5c088c8312af m: \u0026lt;sip:1005@172.16.80.13:58807;ob\u0026gt; Record-Route: \u0026lt;sip:172.16.4.111:5260;lr\u0026gt; c: application/sdp l: 278 v=0 o=- 3964081686 3964081686 IN IP4 172.16.4.111 s=pjmedia b=AS:84 t=0 0 a=X-nat:0 m=audio 31614 RTP/AVP 8 0 101 c=IN IP4 172.16.4.111 b=TIAS:64000 a=rtpmap:101 telephone-event/8000 a=fmtp:101 0-16 a=ssrc:1957038347 cname:2c067dcd05730c02 a=sendrecv a=rtcp:31615 可以看到在opensips转发INVITE时，Via,From,To,Call-id,Contact等都被换成了缩略参数, 并且sdp中的rtpmap:PCMU/PCMA删除了.\n在freeswitch往opensips发送183,200OK时，也带了缩略参数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 2025/08/13 13:46:25.451770 172.16.4.114:5060 -\u0026gt; 172.16.4.111:5260 SIP/2.0 183 Session Progress v: SIP/2.0/UDP 172.16.4.111:5260;branch=z9hG4bKf914.0b281385.0, SIP/2.0/UDP 172.16.80.13:58807;received=172.16.80.13;rport=58807; anch=z9hG4bKPj07898ec3e16c4350843b1a4de4a89ceb Record-Route: \u0026lt;sip:172.16.4.111:5260;lr\u0026gt; f: \u0026lt;sip:1005@172.16.4.111\u0026gt;;tag=2b204cd2db594ce0bca55e8e525a1c14 To: \u0026lt;sip:1008@172.16.4.111\u0026gt;;tag=tZ2epK6U1Dtae i: 9a37bdb33bb7418d9b6e5c088c8312af CSeq: 6255 INVITE Contact: \u0026lt;sip:1008@172.16.4.114:5060;transport=udp\u0026gt; User-Agent: FreeSWITCH-mod_sofia/1.10.2-release+git~20230615T110520Z~4ce1b74880~64bit Accept: application/sdp Allow: INVITE, ACK, BYE, CANCEL, OPTIONS, MESSAGE, INFO, UPDATE, REGISTER, REFER, NOTIFY, PUBLISH, SUBSCRIBE Supported: timer, path, replaces Allow-Events: talk, hold, conference, presence, as-feature-event, dialog, line-seize, call-info, sla, include-session-description presence.winfo, message-summary, refer Content-Type: application/sdp Content-Disposition: session Content-Length: 254 Remote-Party-ID: \u0026#34;1008\u0026#34; \u0026lt;sip:1008@172.16.4.111\u0026gt;;party=calling;privacy=off;screen=no v=0 o=FreeSWITCH 1755033712 1755033713 IN IP4 172.16.4.114 s=FreeSWITCH c=IN IP4 172.16.4.114 t=0 0 m=audio 30016 RTP/AVP 8 101 a=rtpmap:8 PCMA/8000 a=rtpmap:101 telephone-event/8000 a=fmtp:101 0-16 a=ptime:20 a=rtcp:30017 IN IP4 172.16.4.114 可以看到From,To, Via还是之前的缩略参数,其他的header参数被恢复了.\n总结 虽然opensips说可以压缩Header,但是实际测试过程中，并未生效此功能，但是缩略Header参数功能Ok. opensips的压缩body, 确实是压缩了，但是压缩后的body,freeswitch并不能解析.应该是有问题的。 分别对比kamailio和opensips的压缩body功能抓包，发现kamailio的消息体能够被tcpdump正确解析， 但是opensips的消息体被tcpdump解析失败. kamailio的压缩body功能抓包: opensips的压缩body功能抓包: ","date":"2025-08-13T10:50:15+08:00","image":"https://QuincyGao.github.io/p/opensips-compression%E6%A8%A1%E5%9D%97/backup_hu4907972523502702147.jpg","permalink":"https://QuincyGao.github.io/p/opensips-compression%E6%A8%A1%E5%9D%97/","title":"opensips compression模块"},{"content":"背景 gzcompress模块用于压缩和解压缩消息体,不仅可以用在SIP消息上，还能用在HTTP消息上。\n通过Content-Encoding头来决定是否要压缩和解压缩的。 当udp数据超过MTU时, 使用该功能比较有效果。压缩的大小为原来的50%~67%左右, 依赖zlib库。\n官方文档地址: gzcompress\n本次测试的版本为\nkamailio 5.8.5\n重要参数解析 1 2 3 4 5 6 # 表示要进行压缩和解压缩的头名称,默认: Content-Encoding modparam(\u0026#34;gzcompress\u0026#34;, \u0026#34;header_name\u0026#34;, \u0026#34;Encoded\u0026#34;) # 表示要进行压缩和解压缩的头的值,默认: deflate modparam(\u0026#34;gzcompress\u0026#34;, \u0026#34;header_value\u0026#34;, \u0026#34;gzip\u0026#34;) # 是否和sanity模块绑定,默认: 0 modparam(\u0026#34;gzcompress\u0026#34;, \u0026#34;sanity_checks\u0026#34;, 1) 实战 官方测试示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #!KAMAILIO debug=3 memdbg=5 memlog=5 children=2 log_stderror=yes listen=udp:172.16.4.111:5461 listen=tcp:172.16.4.111:5461 tcp_accept_no_cl=yes http_reply_parse=yes mpath=\u0026#34;modules/\u0026#34; loadmodule \u0026#34;sl.so\u0026#34; loadmodule \u0026#34;pv.so\u0026#34; loadmodule \u0026#34;xlog.so\u0026#34; loadmodule \u0026#34;corex.so\u0026#34; loadmodule \u0026#34;textops.so\u0026#34; loadmodule \u0026#34;xhttp.so\u0026#34; loadmodule \u0026#34;gzcompress.so\u0026#34; modparam(\u0026#34;gzcompress\u0026#34;, \u0026#34;header_value\u0026#34;, \u0026#34;deflate\u0026#34;) request_route { xlog(\u0026#34;received sip request from $si:$sp\\r\\n\u0026#34;); if(src_port==5060) { remove_hf(\u0026#34;Content-Encoding\u0026#34;); $du = \u0026#34;sip:127.0.0.1:9\u0026#34;; } else { append_hf(\u0026#34;Content-Encoding: deflate\\r\\n\u0026#34;); $du = \u0026#34;sip:127.0.0.1:5060\u0026#34;; } forward(); exit; } event_route[xhttp:request] { xlog(\u0026#34;received http request from $si:$sp,$rb,$hdr(Content-Encoding)\\n\u0026#34;); append_to_reply(\u0026#34;Content-Encoding: deflate\\r\\n\u0026#34;); xhttp_reply(\u0026#34;200\u0026#34;, \u0026#34;OK\u0026#34;, \u0026#34;application/json\u0026#34;, \u0026#34;{\\\u0026#34;status\\\u0026#34;:\\\u0026#34;ok\\\u0026#34;,\\\u0026#34;data\\\u0026#34;:\\\u0026#34;hello\\\u0026#34;}\u0026#34;); } 在event_route[xhttp:request]中, 获取请求，然后在返回的请求头中添加Content-Encoding字段, xhttp_reply会自动把body压缩。\n测试HTTP请求 使用golang编写http客户端,发送的body使用zlib压缩，示例为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;compress/zlib\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { data := map[string]interface{}{ \u0026#34;name\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;Taipei\u0026#34;, } // 1. 转成 JSON jsonBytes, err := json.Marshal(data) if err != nil { panic(err) } // 2. zlib 压缩 var buf bytes.Buffer zw := zlib.NewWriter(\u0026amp;buf) _, err = zw.Write(jsonBytes) if err != nil { panic(err) } zw.Close() // 必须关闭，否则数据不完整 // 3. 创建 HTTP 请求 req, err := http.NewRequest(\u0026#34;POST\u0026#34;, \u0026#34;http://172.16.4.111:5461/\u0026#34;, \u0026amp;buf) if err != nil { panic(err) } // 设置头部 req.Header.Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) req.Header.Set(\u0026#34;Content-Encoding\u0026#34;, \u0026#34;deflate\u0026#34;) // 4. 发送 client := \u0026amp;http.Client{} resp, err := client.Do(req) if err != nil { panic(err) } defer resp.Body.Close() // 5. 打印响应 body, _ := io.ReadAll(resp.Body) fmt.Println(\u0026#34;Status:\u0026#34;, resp.Status) fmt.Println(\u0026#34;Response:\u0026#34;, string(body)) } 使用go run main.go运行客户端, 可以看到kamailio的日志为:\n1 39(1152) INFO: \u0026lt;script\u0026gt;: received http request from 172.16.1.136:55992,{\u0026#34;city\u0026#34;:\u0026#34;Taipei\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;test\u0026#34;},deflate kamailio会自动把zlib压缩的body解压, 所以可以直接使用$rb来获取请求体。\n如果发送的body没有压缩，则kamailio会报错,但是还是能获取到body的内容:\n1 2 3 4 41(1154) ERROR: gzcompress [gzcompress_mod.c:276]: gzc_msg_received(): error decompressing body (-3) 41(1154) INFO: \u0026lt;script\u0026gt;: received http request from 172.16.80.13:21776, {\u0026#34;city\u0026#34;:\u0026#34;Taipei\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;test\u0026#34;} ,deflate 测试SIP请求 基础玩法 测试方法:\nkamailio做代理, 软电话1005注册到kamailio(172.16.4.111)上, 软电话1008注册到freeswitch(172.16.4.114)上， 然后1005拨打1008, kamailio的配置方式为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 route[LOCATION] { #!ifdef WITH_SPEEDDIAL # search for short dialing - 2-digit extension if($rU=~\u0026#34;^[0-9][0-9]$\u0026#34;) { if(sd_lookup(\u0026#34;speed_dial\u0026#34;)) { route(SIPOUT); } } #!endif #!ifdef WITH_ALIASDB # search in DB-based aliases if(alias_db_lookup(\u0026#34;dbaliases\u0026#34;)) { route(SIPOUT); } #!endif $avp(oexten) = $rU; #if (!lookup(\u0026#34;location\u0026#34;)) { # $var(rc) = $rc; # route(TOVOICEMAIL); # t_newtran(); # switch ($var(rc)) { # case -1: # case -3: # send_reply(\u0026#34;404\u0026#34;, \u0026#34;Not Found\u0026#34;); # exit; # case -2: # send_reply(\u0026#34;405\u0026#34;, \u0026#34;Method Not Allowed\u0026#34;); # exit; # } #} # when routing via usrloc, log the missed calls also #if (is_method(\u0026#34;INVITE\u0026#34;)) { # setflag(FLT_ACCMISSED); #} #t_on_failure(\u0026#34;1\u0026#34;); #t_relay(); #exit; $du =\u0026#34;sip:172.16.4.114:5060\u0026#34;; append_hf(\u0026#34;Content-Encoding: deflate\\r\\n\u0026#34;); route(RELAY); exit; } 测试的sip图为: 软电话1005发送INVITE到kamailio上的详细请求为: kamailio转发INVITE到freeswitch上的详细请求为: 可以看到body这块压缩了:218/339=0.643\nfreeswitch回复183到kamailio上的详细请求为: freeswitch因为支持zlib压缩, 所以回复的183的body也压缩了。\nkamailio回复183到1005上的详细请求为: freeswitch回复200OK到kamailio上的详细请求为: kamailio回复200OK到1005上的详细请求为: 因为软电话不支持zlib解压,然后就报错直接发送BYE挂断了。\n那能否左边不压缩，右边压缩呢？这就是进阶玩法了。\n进阶玩法 配置在基础玩法的基础上，添加如下配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 onreply_route[MANAGE_REPLY] { xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;incoming reply---$rm|$rs|$tu|$rU|$fU|$si|$Ri:$Rp\\n\u0026#34;); remove_hf(\u0026#34;Content-Encoding\u0026#34;); if(status=~\u0026#34;[12][0-9][0-9]\u0026#34;) { route(NATMANAGE); } if (is_present_hf(\u0026#34;Record-Route\u0026#34;)) { remove_hf(\u0026#34;Record-Route\u0026#34;); append_hf(\u0026#34;Record-Route: \u0026lt;sip:172.16.4.111:5461;lr\u0026gt;\\r\\n\u0026#34;); xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;has record-route..\\n\u0026#34;); } return; } 在onreply_route上, 移除Content-Encoding头域, 就可以了。\n完整的信令图和基础的玩法一致。\n软电话1005发送INVITE到kamailio上的详细请求为: kamailio转发INVITE到freeswitch上的详细请求为: freeswitch回复183到kamailio上的详细请求为: kamailio回复183到1005上的详细请求为: 可以看到183的body没有压缩。\nfreeswitch回复200OK到kamailio上的详细请求为: kamailio回复200OK到1005上的详细请求为: 总结 该模块主要压缩的是body信息, 想要压缩转发的消息只需要带上Content-Encoding: deflate头域即可。\n同理，如果不想要压缩，只需要移除Content-Encoding头域即可。\n","date":"2025-08-12T10:02:14+08:00","image":"https://QuincyGao.github.io/p/kamailio-gzcompress%E6%A8%A1%E5%9D%97/backup_hu11555773975851146375.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-gzcompress%E6%A8%A1%E5%9D%97/","title":"kamailio gzcompress模块"},{"content":"背景 path 模块的主要功能是在REGISTER请求中添加Path头, 这样在后续拨打该注册用户时，可以找到回去的路径。\n官方文档地址: path, path的rfc文档为: path的rfc3327\n本次测试的版本为:\nversion: kamailio 5.8.5 (x86_64/linux)\n参数解析 1 2 3 4 5 6 7 8 9 10 # 将会使用第一个Route的received参数作为目的URI modparam(\u0026#34;path\u0026#34;, \u0026#34;use_received\u0026#34;, 1) # 这个received的参数要和alias的参数保持一致 modparam(\u0026#34;path\u0026#34;, \u0026#34;received_format\u0026#34;, 1) # 设置received的名称 modparam(\u0026#34;path\u0026#34;, \u0026#34;received_name\u0026#34;, \u0026#34;rcv\u0026#34;) # 会添加两个Path头,一个PATH的头是进来的网络socket,另一个是出去的网络socket。 modparam(\u0026#34;path\u0026#34;, \u0026#34;enable_r2\u0026#34;, 1) # 这个Path的uri会包含sn的参数 modparam(\u0026#34;path\u0026#34;, \u0026#34;sockname_mode\u0026#34;, 1) 重要函数 add_path() 添加Path头, 这个URI为outgoing的地址\nadd_path(user) 添加Path头, 设置URI的用户为user\nadd_path(user, parameters) 添加Path头, 设置URI的用户为user, 并添加parameters参数。\nadd_path_received() 添加received参数到Path。\nadd_path_received(user) 添加received参数到Path, 并设置用户为user。\nadd_path_received(user, parameters) 添加received参数到Path, 并设置用户为user, 并添加parameters参数。\n实战 配置示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 listen=udp:172.16.4.111:5461 loadmodule \u0026#34;stun.so\u0026#34; loadmodule \u0026#34;outbound.so\u0026#34; loadmodule \u0026#34;path.so\u0026#34; modparam(\u0026#34;path\u0026#34;, \u0026#34;use_received\u0026#34;, 1) modparam(\u0026#34;path\u0026#34;, \u0026#34;received_format\u0026#34;, 1) #modparam(\u0026#34;path\u0026#34;, \u0026#34;enable_r2\u0026#34;, 1) modparam(\u0026#34;path\u0026#34;, \u0026#34;sockname_mode\u0026#34;, 1) ... route[REGISTRAR] { if (!is_method(\u0026#34;REGISTER\u0026#34;)) return; if(isflagset(FLT_NATS)) { setbflag(FLB_NATB); #!ifdef WITH_NATSIPPING # do SIP NAT pinging setbflag(FLB_NATSIPPING); #!endif } fix_nated_contact(); if (!save(\u0026#34;location\u0026#34;,\u0026#34;0x02\u0026#34;)) { #if (!save(\u0026#34;location\u0026#34;)) { sl_reply_error(); } $fs=\u0026#34;udp:172.16.4.111:5461\u0026#34;; $du=\u0026#34;sip:172.16.4.114:5060\u0026#34;; add_path(); #msg_apply_changes(); #assign_hf_value(\u0026#34;Contact\u0026#34;, \u0026#34;\u0026lt;sip:$fU@172.16.4.111:5461\u0026gt;;expires=120\u0026#34;); #msg_apply_changes(); route(RELAY); exit; } 测试 测试场景 此种情况下，注册sip信令图：\n不修改Contact头 软电话1005发出的REGISTER到kamailio的请求信息为: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 2025/08/07 10:54:41.399376 172.16.80.13:59393 -\u0026gt; 172.16.4.111:5461 REGISTER sip:172.16.4.111:5461 SIP/2.0 Via: SIP/2.0/UDP 172.16.80.13:59393;rport;branch=z9hG4bKPj77f2c0f3baa14df98ab811dd0e6a132b Max-Forwards: 70 From: \u0026lt;sip:1005@172.16.4.111\u0026gt;;tag=1c4f54303f984e3bbaf7825c43e5eee4 To: \u0026lt;sip:1005@172.16.4.111\u0026gt; Call-ID: 647cb3bee39541c8ad4491d749e727fc CSeq: 18516 REGISTER User-Agent: MicroSIP/3.21.6 Contact: \u0026lt;sip:1005@172.16.80.13:59393;ob\u0026gt; Expires: 200 Allow: PRACK, INVITE, ACK, BYE, CANCEL, UPDATE, INFO, SUBSCRIBE, NOTIFY, REFER, MESSAGE, OPTIONS Authorization: Digest username=\u0026#34;1005\u0026#34;, realm=\u0026#34;172.16.4.111\u0026#34;, nonce=\u0026#34;be470993-7965-415f-b466-e94c2ddab774\u0026#34;, uri=\u0026#34;sip:172.16.4.111: 61\u0026#34;, response=\u0026#34;394b758a1f68f04af2998d17a59c2e96\u0026#34;, algorithm=MD5, cnonce=\u0026#34;0d405a7726f2402e8c9db4e3cc694603\u0026#34;, qop=auth, nc=00000001 Content-Length: 0 kamailio转发REGISTER: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 2025/08/07 10:54:41.399817 172.16.4.111:5461 -\u0026gt; 172.16.4.114:5060 REGISTER sip:172.16.4.111:5461 SIP/2.0 Via: SIP/2.0/UDP 172.16.4.111:5461;branch=z9hG4bK7294.4630172030dfbcb1018abcde74766f45.0 Via: SIP/2.0/UDP 172.16.80.13:59393;received=172.16.80.13;rport=59393;branch=z9hG4bKPj77f2c0f3baa14df98ab811dd0e6a132b Max-Forwards: 69 From: \u0026lt;sip:1005@172.16.4.111\u0026gt;;tag=1c4f54303f984e3bbaf7825c43e5eee4 To: \u0026lt;sip:1005@172.16.4.111\u0026gt; Call-ID: 647cb3bee39541c8ad4491d749e727fc CSeq: 18516 REGISTER User-Agent: MicroSIP/3.21.6 Contact: \u0026lt;sip:1005@172.16.80.13:59393;ob\u0026gt; Expires: 200 Allow: PRACK, INVITE, ACK, BYE, CANCEL, UPDATE, INFO, SUBSCRIBE, NOTIFY, REFER, MESSAGE, OPTIONS Authorization: Digest username=\u0026#34;1005\u0026#34;, realm=\u0026#34;172.16.4.111\u0026#34;, nonce=\u0026#34;be470993-7965-415f-b466-e94c2ddab774\u0026#34;, uri=\u0026#34;sip:172.16.4.111: 61\u0026#34;, response=\u0026#34;394b758a1f68f04af2998d17a59c2e96\u0026#34;, algorithm=MD5, cnonce=\u0026#34;0d405a7726f2402e8c9db4e3cc694603\u0026#34;, qop=auth, nc=00000001 Content-Length: 0 此时Contact为:\u0026lt;sip:1005@172.16.80.13:59393;ob\u0026gt;\nfreeswitch中的注册信息: 1 2 3 4 5 6 7 8 9 10 11 12 13 Call-ID: 647cb3bee39541c8ad4491d749e727fc User: 1005@172.16.4.114 Contact: \u0026#34;\u0026#34; \u0026lt;sip:1005@172.16.80.13:59393;ob\u0026gt; Agent: MicroSIP/3.21.6 Status: Registered(UDP)(unknown) EXP(2025-08-07 10:57:59) EXPSECS(137) Ping-Status: Reachable Ping-Time: 0.00 Host: fs IP: 172.16.4.111 Port: 5461 Auth-User: 1005 Auth-Realm: 172.16.4.111 MWI-Account: 1005@172.16.4.114 使用1008拨打1005的信令图： 可以看到INVITE的Request-URI就是1005注册信息中的Contact。 此时这个请求透过了kamailio。\n修改Contact头 放开注释:\n1 2 msg_apply_changes(); assign_hf_value(\u0026#34;Contact\u0026#34;, \u0026#34;\u0026lt;sip:$fU@172.16.4.111:5461\u0026gt;;expires=120\u0026#34;); 软电话1005发出的REGISTER到kamailio的请求信息为: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 2025/08/07 11:07:04.155172 172.16.80.13:59393 -\u0026gt; 172.16.4.111:5461 REGISTER sip:172.16.4.111:5461 SIP/2.0 Via: SIP/2.0/UDP 172.16.80.13:59393;rport;branch=z9hG4bKPj3c4917ead53c4a649e796e7bb26c1779 Max-Forwards: 70 From: \u0026lt;sip:1005@172.16.4.111\u0026gt;;tag=de351588eb384435b10b45196b4040b9 To: \u0026lt;sip:1005@172.16.4.111\u0026gt; Call-ID: 57b5c50d07b14706b046df403e99da99 CSeq: 37388 REGISTER User-Agent: MicroSIP/3.21.6 Contact: \u0026lt;sip:1005@172.16.80.13:59393;ob\u0026gt; Expires: 200 Allow: PRACK, INVITE, ACK, BYE, CANCEL, UPDATE, INFO, SUBSCRIBE, NOTIFY, REFER, MESSAGE, OPTIONS Authorization: Digest username=\u0026#34;1005\u0026#34;, realm=\u0026#34;172.16.4.111\u0026#34;, nonce=\u0026#34;f951f7e5-c53e-46f8-bfa5-ad6ff146ccc9\u0026#34;, uri=\u0026#34;sip:172.16.4.111: 61\u0026#34;, response=\u0026#34;d4d6608c547f105e00cacd4dd3820ad4\u0026#34;, algorithm=MD5, cnonce=\u0026#34;cf45cd14e34d435f994cdc1f82acb62d\u0026#34;, qop=auth, nc=00000001 Content-Length: 0 kamailio转发REGISTER: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 2025/08/07 11:07:04.156456 172.16.4.111:5461 -\u0026gt; 172.16.4.114:5060 REGISTER sip:172.16.4.111:5461 SIP/2.0 Via: SIP/2.0/UDP 172.16.4.111:5461;branch=z9hG4bK804c.e67315908cbc104f4f519092f4d97ecb.0 Via: SIP/2.0/UDP 172.16.80.13:59393;received=172.16.80.13;rport=59393;branch=z9hG4bKPj3c4917ead53c4a649e796e7bb26c1779 Max-Forwards: 69 From: \u0026lt;sip:1005@172.16.4.111\u0026gt;;tag=de351588eb384435b10b45196b4040b9 To: \u0026lt;sip:1005@172.16.4.111\u0026gt; Call-ID: 57b5c50d07b14706b046df403e99da99 CSeq: 37388 REGISTER User-Agent: MicroSIP/3.21.6 Contact: \u0026lt;sip:1005@172.16.4.111:5461\u0026gt;;expires=120 Expires: 200 Allow: PRACK, INVITE, ACK, BYE, CANCEL, UPDATE, INFO, SUBSCRIBE, NOTIFY, REFER, MESSAGE, OPTIONS Authorization: Digest username=\u0026#34;1005\u0026#34;, realm=\u0026#34;172.16.4.111\u0026#34;, nonce=\u0026#34;f951f7e5-c53e-46f8-bfa5-ad6ff146ccc9\u0026#34;, uri=\u0026#34;sip:172.16.4.111: 61\u0026#34;, response=\u0026#34;d4d6608c547f105e00cacd4dd3820ad4\u0026#34;, algorithm=MD5, cnonce=\u0026#34;cf45cd14e34d435f994cdc1f82acb62d\u0026#34;, qop=auth, nc=00000001 Content-Length: 0 可以看到Contact变成了\u0026lt;sip:1005@172.16.4.111:5461\u0026gt;;expires=120\nfreeswitch中的注册信息: 1 2 3 4 5 6 7 8 9 10 11 12 13 Call-ID: 57b5c50d07b14706b046df403e99da99 User: 1005@172.16.4.114 Contact: \u0026#34;\u0026#34; \u0026lt;sip:1005@172.16.4.111:5461\u0026gt; Agent: MicroSIP/3.21.6 Status: Registered(UDP)(unknown) EXP(2025-08-07 11:07:07) EXPSECS(128) Ping-Status: Reachable Ping-Time: 0.00 Host: fs IP: 172.16.4.111 Port: 5461 Auth-User: 1005 Auth-Realm: 172.16.4.111 MWI-Account: 1005@172.16.4.114 使用1008拨打1005的信令图： 可以看到INVITE的Request-URI就是1005注册信息中的Contact。 先不管是否拨打成功，但是这个修改是我们需要的。\n使用add_path 放开注释:\n1 add_path(); 软电话1005发出的REGISTER到kamailio的请求信息为: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 2025/08/07 11:13:29.926084 172.16.80.13:59393 -\u0026gt; 172.16.4.111:5461 REGISTER sip:172.16.4.111:5461 SIP/2.0 Via: SIP/2.0/UDP 172.16.80.13:59393;rport;branch=z9hG4bKPj734f2bbe803b4b7b8c7da61c7cae8121 Max-Forwards: 70 From: \u0026lt;sip:1005@172.16.4.111\u0026gt;;tag=60b64f9e189d4b73973b95640e5c1894 To: \u0026lt;sip:1005@172.16.4.111\u0026gt; Call-ID: ca33e9a8ff504a0d9e7aa0ebd558dc32 CSeq: 28980 REGISTER User-Agent: MicroSIP/3.21.6 Contact: \u0026lt;sip:1005@172.16.80.13:59393;ob\u0026gt; Expires: 200 Allow: PRACK, INVITE, ACK, BYE, CANCEL, UPDATE, INFO, SUBSCRIBE, NOTIFY, REFER, MESSAGE, OPTIONS Authorization: Digest username=\u0026#34;1005\u0026#34;, realm=\u0026#34;172.16.4.111\u0026#34;, nonce=\u0026#34;19ab3d8a-f754-48eb-b964-382a4ea6bb2a\u0026#34;, uri=\u0026#34;sip:172.16.4.111: 61\u0026#34;, response=\u0026#34;5feb7261cfafb500baa1c72efc942aa5\u0026#34;, algorithm=MD5, cnonce=\u0026#34;1abc1ff721484c69b50097870f1f445c\u0026#34;, qop=auth, nc=00000001 Content-Length: 0 kamailio转发REGISTER: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 2025/08/07 11:14:35.168348 172.16.4.111:5461 -\u0026gt; 172.16.4.114:5060 REGISTER sip:172.16.4.111:5461 SIP/2.0 Via: SIP/2.0/UDP 172.16.4.111:5461;branch=z9hG4bK3ebc.e457de15226712c7162a35cacec1aa9a.0 Via: SIP/2.0/UDP 172.16.80.13:59393;received=172.16.80.13;rport=59393;branch=z9hG4bKPjb2b73fc8e50849a5ae4aa5e71bb7c2ca Max-Forwards: 69 From: \u0026lt;sip:1005@172.16.4.111\u0026gt;;tag=62cbc4d210e245d5b7b8bdb733825fb5 To: \u0026lt;sip:1005@172.16.4.111\u0026gt; Call-ID: f5fbf048dd164736a91b0b8558d518e7 CSeq: 46523 REGISTER User-Agent: MicroSIP/3.21.6 Contact: \u0026lt;sip:1005@172.16.80.13:59393;ob\u0026gt; Expires: 200 Allow: PRACK, INVITE, ACK, BYE, CANCEL, UPDATE, INFO, SUBSCRIBE, NOTIFY, REFER, MESSAGE, OPTIONS Authorization: Digest username=\u0026#34;1005\u0026#34;, realm=\u0026#34;172.16.4.111\u0026#34;, nonce=\u0026#34;c8884fe9-cac0-4cf0-ab70-4f4a5f9588ef\u0026#34;, uri=\u0026#34;sip:172.16.4.111: 61\u0026#34;, response=\u0026#34;b605239c7eadc7ac5476e9e6072e615e\u0026#34;, algorithm=MD5, cnonce=\u0026#34;e1f085bbf949401980c867444c03f104\u0026#34;, qop=auth, nc=00000001 Content-Length: 0 Path: \u0026lt;sip:172.16.4.111:5461;lr\u0026gt; 可以看到Contact没变，但是Path添加了\u0026lt;sip:172.16.4.111:5461;lr\u0026gt;。\nfreeswitch中的注册信息: 1 2 3 4 5 6 7 8 9 10 11 12 13 Call-ID: f5fbf048dd164736a91b0b8558d518e7 User: 1005@172.16.4.114 Contact: \u0026#34;\u0026#34; \u0026lt;sip:1005@172.16.80.13:59393;ob;fs_path=sip%3A172.16.4.111%3A5461%3Blr\u0026gt; Agent: MicroSIP/3.21.6 Status: Registered(UDP)(unknown) EXP(2025-08-07 11:14:38) EXPSECS(177) Ping-Status: Reachable Ping-Time: 0.00 Host: fs IP: 172.16.4.111 Port: 5461 Auth-User: 1005 Auth-Realm: 172.16.4.111 MWI-Account: 1005@172.16.4.114 新增了fs_path=sip%3A172.16.4.111%3A5461%3Blr。\n使用1008拨打1005的信令图： 可以看到Request-URI为sip:1005@172.16.80.13:59393,但是发送请求到172.16.4.111:5461。 还添加了Route头为:172.16.4.111:5461。\n总结 当我们使用kamailio用作注册服务器时，一方面可以通过修改REGISTER中的Contact达到后续的请求转发到kamailio, 另一方面可以通过add_path添加Path头，达到此目的，当然前提是被注册的服务器要支持path。\nPath是在发送INVITE请求给注册的用户时，能往回发送INVITE请求到注册的路径。 Record-Route是在建立INVITE会话接通之后，信令找回的路径。 ","date":"2025-08-07T09:34:12+08:00","image":"https://QuincyGao.github.io/p/kamailio-path%E6%A8%A1%E5%9D%97/backup_hu4728017647157596323.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-path%E6%A8%A1%E5%9D%97/","title":"kamailio path模块"},{"content":"背景 rtpproxy是rtp媒体代理服务, 支持udp,tcp和webrtc, 和rtpengine功能大体一致。 但是又多了一些功能: 其提供rtp cluster来单独支持rptproxy的集群， rtpengine没有提供相关的功能。\n官方代码地址: rtporxy\n官方文档地址: rtpproxy文档\n本次测试的rtpproxy版本信息为：\n3.1.7456282\n安装 安装依赖 本次测试系统版本为：\ncentos7.9\ngcc \u0026gt; 5.0.0 1 2 3 yum install -y devtoolset-10-gcc devtoolset-10-gcc-c++ devtoolset-10-binutils source /opt/rh/devtoolset-10/enable; 其他依赖 1 yum install -y libsndfile-devel libsndfile libsrtp-devel libsrtp bcg729-devel bcg729 安装rtpproxy 1 2 3 git clone -b master https://github.com/sippy/rtpproxy.git git -C rtpproxy submodule update --init --recursive cd rtpproxy \u0026amp;\u0026amp; ./configure \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install 安装成功之后，可以看到的二进制程序有：\n1 2 3 4 5 6 [root@localhost rtpproxy]# ll /usr/local/bin/ total 5144 -rwxr-xr-x. 1 root root 122512 Jul 31 03:14 makeann -rwxr-xr-x. 1 root root 2419936 Jul 31 03:14 rtpproxy -rwxr-xr-x. 1 root root 2498160 Jul 31 03:14 rtpproxy_debug -rwxr-xr-x. 1 root root 222032 Jul 31 03:14 udp_contention lib库:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 [root@localhost rtpproxy]# ll /usr/local/lib/rtpproxy/ total 1404 -rwxr-xr-x. 1 root root 948 Jul 31 03:14 rtpp_acct_csv.la -rwxr-xr-x. 1 root root 137592 Jul 31 03:14 rtpp_acct_csv.so -rwxr-xr-x. 1 root root 999 Jul 31 03:14 rtpp_acct_csv_debug.la -rwxr-xr-x. 1 root root 298848 Jul 31 03:14 rtpp_acct_csv_debug.so -rwxr-xr-x. 1 root root 978 Jul 31 03:14 rtpp_acct_rtcp_hep.la -rwxr-xr-x. 1 root root 208784 Jul 31 03:14 rtpp_acct_rtcp_hep.so -rwxr-xr-x. 1 root root 1029 Jul 31 03:14 rtpp_acct_rtcp_hep_debug.la -rwxr-xr-x. 1 root root 351440 Jul 31 03:14 rtpp_acct_rtcp_hep_debug.so -rwxr-xr-x. 1 root root 960 Jul 31 03:14 rtpp_catch_dtmf.la -rwxr-xr-x. 1 root root 124776 Jul 31 03:14 rtpp_catch_dtmf.so -rwxr-xr-x. 1 root root 1011 Jul 31 03:14 rtpp_catch_dtmf_debug.la -rwxr-xr-x. 1 root root 286584 Jul 31 03:14 rtpp_catch_dtmf_debug.so 实战 运行 1 rtpproxy -l 0.0.0.0 -L 4096 -m 40000 -M 40100 -s udp:172.16.4.111:3333 -d DBUG -f -F 测试 使用kamailio的rtpproxy模块进行测试。\n1 2 3 4 #!define WITH_NAT modparam(\u0026#34;rtpproxy\u0026#34;, \u0026#34;rtpproxy_sock\u0026#34;, \u0026#34;udp:172.16.4.111:3333\u0026#34;) ... 其他的参数脚本使用kamailio的默认值, 软电话1004和1007注册到kamailio，使用软电话1004拨打1007。\n通话正常有声音.\n测试结果 rtpproxy的日志为: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 DBUG:GLOBAL:rtpp_command_split:375: received command \u0026#34;79_4 Uc8,0,101 ed5ddc640f9144d389f392bd2b6b8501 172.16.80.13 4004 84a153e3091f4204a53f0dc5180c3668;1\u0026#34; INFO:GLOBAL:rtpp_command_ul_handle:527: new IPv4/IPv4 session ed5ddc640f9144d389f392bd2b6b8501, tag 84a153e3091f4204a53f0dc5180c3668;1 requested, type strong INFO:ed5ddc640f9144d389f392bd2b6b8501:rtpp_command_ul_handle:592: new session on IPv4 port 40074 created, tag 84a153e3091f4204a53f0dc5180c3668;1 INFO:ed5ddc640f9144d389f392bd2b6b8501:rtpp_stream_prefill_addr:862: pre-filling caller\u0026#39;s RTP address with 172.16.80.13:4004 INFO:ed5ddc640f9144d389f392bd2b6b8501:rtpp_stream_prefill_addr:862: pre-filling caller\u0026#39;s RTCP address with 172.16.80.13:4005 DBUG:GLOBAL:rtpc_reply_deliver:136: sending reply \u0026#34;79_4 40074\\n\u0026#34; DBUG:GLOBAL:rtpp_command_split:375: received command \u0026#34;73_4 Lc8,0,101 ed5ddc640f9144d389f392bd2b6b8501 172.16.80.13 58192 84a153e3091f4204a53f0dc5180c3668;1 867be556;1\u0026#34; INFO:ed5ddc640f9144d389f392bd2b6b8501:rtpp_command_ul_handle:517: lookup on ports 40074/40038, session timer restarted INFO:ed5ddc640f9144d389f392bd2b6b8501:rtpp_stream_prefill_addr:862: pre-filling callee\u0026#39;s RTP address with 172.16.80.13:58192 INFO:ed5ddc640f9144d389f392bd2b6b8501:rtpp_stream_prefill_addr:862: pre-filling callee\u0026#39;s RTCP address with 172.16.80.13:58193 DBUG:GLOBAL:rtpc_reply_deliver:136: sending reply \u0026#34;73_4 40038\\n\u0026#34; INFO:ed5ddc640f9144d389f392bd2b6b8501:_rtpp_stream_latch:652: caller\u0026#39;s address latched in: 172.16.80.13:4005 (RTCP), SSRC=UNKNOWN, Seq=UNKNOWN INFO:ed5ddc640f9144d389f392bd2b6b8501:_rtpp_stream_latch:652: caller\u0026#39;s address latched in: 172.16.80.13:4004 (RTP), SSRC=0x72120CEB, Seq=20529 INFO:ed5ddc640f9144d389f392bd2b6b8501:_rtpp_stream_latch:652: callee\u0026#39;s address latched in: 172.16.80.13:58192 (RTP), SSRC=0xB102C9D7, Seq=4384 rtpproxy的监听端口: 和rtpengine不太一样的是, 如果未主动调用rtpproxy_delete,通话结束后， 其监听的端口不会释放(rtpengine会在没有流的60s后释放端口), rtpproxy会在下一次通话时，释放上次监听的端口。\n","date":"2025-08-04T09:45:19+08:00","image":"https://QuincyGao.github.io/p/rtpproxy%E5%88%9D%E4%BD%93%E9%AA%8C/backup_hu927961447250555249.jpg","permalink":"https://QuincyGao.github.io/p/rtpproxy%E5%88%9D%E4%BD%93%E9%AA%8C/","title":"rtpproxy初体验"},{"content":"背景 mohqueue 模块可以把INVITE请求转移到音乐等待队列中，并播放音乐，直到有接线员接通电话. 官方文档地址: mohqueue。 需要的外部服务为: rtpproxy。\n本次测试的版本信息为:\nversion: kamailio 5.8.5 (x86_64/linux)\n参数解析 1 2 3 4 5 6 7 8 9 10 # 数据库连接地址 modparam (\u0026#34;mohqueue\u0026#34;, \u0026#34;db_url\u0026#34;, DB_URL) # 队列表名 modparam (\u0026#34;mohqueue\u0026#34;, \u0026#34;db_qtable\u0026#34;, \u0026#34;mohqueues\u0026#34;) # 通话状态表 modparam (\u0026#34;mohqueue\u0026#34;, \u0026#34;db_ctable\u0026#34;, \u0026#34;mohqcalls\u0026#34;) # 音频文件存放路径 modparam (\u0026#34;mohqueue\u0026#34;, \u0026#34;mohdir\u0026#34;, \u0026#34;/var/kamailio/MOH\u0026#34;) # 一个队列中最大的通话数,默认:50 modparam (\u0026#34;mohqueue\u0026#34;, \u0026#34;moh_maxcalls\u0026#34;, 200) 本模块需要使用两个数据表:mohqueues和mohqcalls。\n重要函数 mohq_process() 检查当前的SIP消息是否涉及队列,如果涉及,则处理此消息并返回true.\nmohq_send(queue_name) 将当前的请求发送到不匹配的URI队列中\nmohq_retrieve(queue_name, URI) 检索队列中最旧的呼叫，并将其重定向到URI。\nmohq_count (queue_name, pvar) 获取队列中的通话数,并将结果存储在pvar中.\n实战 配置示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 loadmodule \u0026#34;rtpproxy.so\u0026#34; modparam(\u0026#34;rtpproxy\u0026#34;, \u0026#34;rtpproxy_sock\u0026#34;, \u0026#34;udp:172.16.4.111:3333\u0026#34;) modparam(\u0026#34;rtpproxy\u0026#34;, \u0026#34;rtpproxy_disable_tout\u0026#34;, 20) loadmodule \u0026#34;mohqueue.so\u0026#34; modparam(\u0026#34;mohqueue\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;mohqueue\u0026#34;, \u0026#34;db_qtable\u0026#34;, \u0026#34;mohqueues\u0026#34;) modparam(\u0026#34;mohqueue\u0026#34;, \u0026#34;db_ctable\u0026#34;, \u0026#34;mohqcalls\u0026#34;) modparam(\u0026#34;mohqueue\u0026#34;, \u0026#34;mohdir\u0026#34;, \u0026#34;/var/kamailio/MOH\u0026#34;) modparam(\u0026#34;mohqueue\u0026#34;, \u0026#34;moh_maxcalls\u0026#34;, 200) request_route { ... if (is_method(\u0026#34;INVITE\u0026#34;)) { mohq_count(\u0026#34;abc\u0026#34;, \u0026#34;$var(mohqcnt)\u0026#34;); xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;abc queue has $var(mohqcnt) calls!\\n\u0026#34;); if (mohq_process()) { xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;process done\\n\u0026#34;); } else { xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;mohq_process error\\n\u0026#34;); } } ... } 数据表:mohqueues插入数据: 1 insert into mohqueues (`name`, `uri`,`mohdir`,`moh_file`,`debug`) values (\u0026#39;abc\u0026#39;, \u0026#39;sip:1008@172.16.4.111:5461\u0026#39;,\u0026#39;/var/kamailio/MOH\u0026#39;,\u0026#39;test.pcm\u0026#39;, 1); uri很重要, 要和Request-URI保持一致,不然会无法触发mohq_process\n上传音频文件到/var/kamailio/MOH/目录下 1 2 3 ll /var/kamailio/MOH/ total 540 -rwxrwxrwx. 1 root root 550080 Jul 28 13:53 test.pcm.8 需要注意的是:\n音频文件的名称比mohqueues表中的moh_file字段的值多了\u0026rsquo;.type'\n如果kamailio和rtpproxy使用两个容器部署, 那么rtpproxy也要有/var/kamailio/MOH目录和相关的文件.\nrtpproxy的运行命令为:\n1 rtpproxy -l 0.0.0.0 -L 4096 -m 40000 -M 40100 -s udp:172.16.4.111:3333 -d DBUG -f -F 测试 使用软电话拨打1008, 可以听到录音文件的内容,但是有滋滋啦啦的声音,应该是音频格式问题，具体的格式需要后续再排查。\nkamailio的日志为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 14(10568) INFO: \u0026lt;script\u0026gt;: ------172.16.80.13:52570|172.16.4.111:5461|udp|INVITE 14(10568) INFO: \u0026lt;script\u0026gt;: abc queue has 0 calls! 14(10568) DEBUG: mohqueue [mohq_funcs.c:2554]: mohq_debug(): create_call: Added call (\u0026lt;sip:1004@172.16.4.111\u0026gt;;tag=6960f3996dc741dba443fef5900f3f05) to queue (abc) 14(10568) DEBUG: mohqueue [mohq_funcs.c:2554]: mohq_debug(): mohq_process: Processing INVITE, queue (abc) 14(10568) DEBUG: mohqueue [mohq_funcs.c:2554]: mohq_debug(): first_invite_msg: Making offer for RTP link for call (\u0026lt;sip:1004@172.16.4.111\u0026gt;;tag=6960f3996dc741dba443fef5900f3f05) from queue (abc) 14(10568) DEBUG: mohqueue [mohq_funcs.c:2554]: mohq_debug(): send_rtp_answer: Answering RTP link for call (\u0026lt;sip:1004@172.16.4.111\u0026gt;;tag=6960f3996dc741dba443fef5900f3f05) 14(10568) DEBUG: mohqueue [mohq_funcs.c:2554]: mohq_debug(): start_stream: Starting RTP link for call (\u0026lt;sip:1004@172.16.4.111\u0026gt;;tag=6960f3996dc741dba443fef5900f3f05) 14(10568) ERROR: dialog [dlg_handlers.c:542]: dlg_onreply(): Faked reply! 14(10568) DEBUG: mohqueue [mohq_funcs.c:2554]: mohq_debug(): send_rtp_answer: Responded to INVITE with RTP for call (\u0026lt;sip:1004@172.16.4.111\u0026gt;;tag=6960f3996dc741dba443fef5900f3f05) 14(10568) INFO: \u0026lt;script\u0026gt;: process done 15(10569) INFO: \u0026lt;script\u0026gt;: ------172.16.80.13:52570|172.16.4.111:5461|udp|ACK 16(10570) INFO: \u0026lt;script\u0026gt;: ------172.16.80.13:52570|172.16.4.111:5461|udp|BYE 34(10588) ERROR: mohqueue [mohq_funcs.c:1348]: invite_cb(): invite_cb: INVITE failed for call (\u0026lt;sip:1004@172.16.4.111\u0026gt;;tag=6960f3996dc741dba443fef5900f3f05), code=20000, callstate=68! 34(10588) DEBUG: mohqueue [mohq_funcs.c:2554]: mohq_debug(): delete_call: Deleting call (\u0026lt;sip:1004@172.16.4.111\u0026gt;;tag=6960f3996dc741dba443fef5900f3f05) from queue (abc) rtpproxy的日志为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 DBUG:GLOBAL:rtpp_command_split:375: received command \u0026#34;10568_4 Uc8,0,101 0251ec9fbe4548c1a8dda6e69e8b91a4 172.16.80.13 4008 6960f3996dc741dba443fef5900f3f05;1\u0026#34; INFO:GLOBAL:rtpp_command_ul_handle:527: new IPv4/IPv4 session 0251ec9fbe4548c1a8dda6e69e8b91a4, tag 6960f3996dc741dba443fef5900f3f05;1 requested, type strong INFO:0251ec9fbe4548c1a8dda6e69e8b91a4:rtpp_command_ul_handle:592: new session on IPv4 port 40072 created, tag 6960f3996dc741dba443fef5900f3f05;1 INFO:0251ec9fbe4548c1a8dda6e69e8b91a4:rtpp_stream_prefill_addr:862: pre-filling caller\u0026#39;s RTP address with 172.16.80.13:4008 INFO:0251ec9fbe4548c1a8dda6e69e8b91a4:rtpp_stream_prefill_addr:862: pre-filling caller\u0026#39;s RTCP address with 172.16.80.13:4009 DBUG:GLOBAL:rtpc_reply_deliver:136: sending reply \u0026#34;10568_4 40072\\n\u0026#34; DBUG:GLOBAL:rtpp_command_split:375: received command \u0026#34;10568_5 LZ20c8 0251ec9fbe4548c1a8dda6e69e8b91a4 172.16.80.13 1 6960f3996dc741dba443fef5900f3f05;1 f5ce571b08e47ce350df4b28201d4d1c-1b725a54;1\u0026#34; INFO:0251ec9fbe4548c1a8dda6e69e8b91a4:rtpp_command_ul_handle:517: lookup on ports 40072/40084, session timer restarted INFO:0251ec9fbe4548c1a8dda6e69e8b91a4:rtpp_stream_prefill_addr:862: pre-filling callee\u0026#39;s RTP address with 172.16.80.13:1 INFO:0251ec9fbe4548c1a8dda6e69e8b91a4:rtpp_stream_prefill_addr:862: pre-filling callee\u0026#39;s RTCP address with 172.16.80.13:2 INFO:0251ec9fbe4548c1a8dda6e69e8b91a4:rtpp_command_ul_handle:663: RTP packets from callee will be resized to 20 milliseconds DBUG:GLOBAL:rtpc_reply_deliver:136: sending reply \u0026#34;10568_5 40084\\n\u0026#34; DBUG:GLOBAL:rtpp_command_split:375: received command \u0026#34;10568_6 P-1 0251ec9fbe4548c1a8dda6e69e8b91a4 /var/kamailio/MOH/test.pcm session 6960f3996dc741dba443fef5900f3f05;1 f5ce571b08e47ce350df4b28201d4d1c-1b725a54;1\u0026#34; INFO:0251ec9fbe4548c1a8dda6e69e8b91a4:rtpp_stream_handle_play:511: -1 times playing prompt /var/kamailio/MOH/test.pcm codec 8: SSRC=0xAA2B056D, seq=26343 DBUG:GLOBAL:rtpc_reply_deliver:136: sending reply \u0026#34;10568_6 0\\n\u0026#34; INFO:0251ec9fbe4548c1a8dda6e69e8b91a4:_rtpp_stream_latch:652: caller\u0026#39;s address latched in: 172.16.80.13:4009 (RTCP), SSRC=UNKNOWN, Seq=UNKNOWN INFO:0251ec9fbe4548c1a8dda6e69e8b91a4:_rtpp_stream_latch:652: caller\u0026#39;s address latched in: 172.16.80.13:4008 (RTP), SSRC=0x24982D1B, Seq=14344 相关的sip信令为: ","date":"2025-07-31T09:16:00+08:00","image":"https://QuincyGao.github.io/p/kamailio-mohqueue-%E6%A8%A1%E5%9D%97/backup_hu15972776364628816188.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-mohqueue-%E6%A8%A1%E5%9D%97/","title":"kamailio mohqueue 模块"},{"content":"背景 msilo模块存储用户离线之后收到的信息，当用户上线之后会把这些信息再发送给他. 需要使用数据库, 官方文档地址:msilo\n本次测试的版本信息为:\nversion: kamailio 5.8.5 (x86_64/linux)\n参数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 数据库地址 modparam(\u0026#34;msilo\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) # 当用户上线时，发送离线消息的地址 modparam(\u0026#34;msilo\u0026#34;, \u0026#34;from_address\u0026#34;, \u0026#34;sip:registrar@example.org\u0026#34;) # 添加Contact头到通知消息 modparam(\u0026#34;msilo\u0026#34;, \u0026#34;contact_hdr\u0026#34;, \u0026#34;Contact: \u0026lt;sip:null@example.com\u0026gt;\\r\\n\u0026#34;) # 添加额外的头到通知消息 modparam(\u0026#34;msilo\u0026#34;, \u0026#34;extra_hdrs\u0026#34;, \u0026#34;X-Extra: $tu\\r\\nY-Extra: foo\\r\\n\u0026#34;) # 通知消息的body modparam(\u0026#34;msilo\u0026#34;, \u0026#34;offline_message\u0026#34;, \u0026#34;*** User $rU is offline!\u0026#34;) # 设置content-type值 modparam(\u0026#34;msilo\u0026#34;, \u0026#34;content_type_hdr\u0026#34;, \u0026#34;Content-Type: text/plain\\r\\n\u0026#34;) # 数据表中消息过期时间 modparam(\u0026#34;msilo\u0026#34;, \u0026#34;expire_time\u0026#34;, 36000) # 检查存储消息是否发送成功的时间间隔,单位秒,默认:60 modparam(\u0026#34;msilo\u0026#34;, \u0026#34;check_time\u0026#34;, 10) # 检查是否有提醒消息的时间间隔 modparam(\u0026#34;msilo\u0026#34;, \u0026#34;send_time\u0026#34;, 60) # 当消息过期时,检查的循环次数. modparam(\u0026#34;msilo\u0026#34;, \u0026#34;clean_period\u0026#34;, 3) # 是否使用Contact地址来发送消息 modparam(\u0026#34;msilo\u0026#34;, \u0026#34;use_contact\u0026#34;, 0) # 存储发送时间的AVP modparam(\u0026#34;msilo\u0026#34;, \u0026#34;snd_time_avp\u0026#34;, \u0026#34;$avp(i:123)\u0026#34;) # 当message存储时,是否添加创建时间 modparam(\u0026#34;msilo\u0026#34;, \u0026#34;add_date\u0026#34;, 0) # 一个AoR号,最多存储的消息数量,0:没有限制. modparam(\u0026#34;msilo\u0026#34;, \u0026#34;max_messages\u0026#34;, 0) 重要函数 m_store([owner]) 存储当前sip请求的消息, OWNER必须包含SIP URI,可以是from,to等, OWNER缺失时, 使用R-URI。\nm_store_addrs(owner, srcaddr, dstaddr) 功能和m_store相同, 但是从From-URI获取源用户地址,从To-URI获取目的用户地址.\nm_dump([owner]) 发送存储的消息。\n实战 配置示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 loadmodule \u0026#34;msilo.so\u0026#34; modparam(\u0026#34;msilo\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;msilo\u0026#34;, \u0026#34;db_table\u0026#34;, \u0026#34;silo\u0026#34;) modparam(\u0026#34;msilo\u0026#34;, \u0026#34;from_address\u0026#34;, \u0026#34;sip:registrar@example.org\u0026#34;) modparam(\u0026#34;msilo\u0026#34;,\u0026#34;contact_hdr\u0026#34;,\u0026#34;Contact: registrar@172.16.4.111:5460;msilo=yes\\r\\n\u0026#34;) modparam(\u0026#34;msilo\u0026#34;,\u0026#34;content_type_hdr\u0026#34;,\u0026#34;Content-Type: text/plain\\r\\n\u0026#34;) modparam(\u0026#34;msilo\u0026#34;,\u0026#34;offline_message\u0026#34;,\u0026#34;*** User $rU is offline!\u0026#34;) ... route { ... if (uri==myself) { { # for testing purposes, simply okay all REGISTERs if (method==\u0026#34;REGISTER\u0026#34;) { save(\u0026#34;location\u0026#34;); xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;REGISTER received -\u0026gt; dumping messages with MSILO\\n\u0026#34;); # MSILO - dumping user\u0026#39;s offline messages if (m_dump()) { xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;MSILO: offline messages dumped - if they were\\n\u0026#34;); }else{ xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;MSILO: no offline messages dumped\\n\u0026#34;); }; exit; }; # domestic SIP destinations are handled using our USRLOC DB if(!lookup(\u0026#34;location\u0026#34;)) { if (! t_newtran()) { sl_reply_error(); exit; }; # we do not care about anything else but MESSAGEs if (!method==\u0026#34;MESSAGE\u0026#34;) { if (!t_reply(\u0026#34;404\u0026#34;, \u0026#34;Not found\u0026#34;)) { sl_reply_error(); }; exit; }; xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;MESSAGE received -\u0026gt; storing using MSILO\\n\u0026#34;); # MSILO - storing as offline message if (m_store(\u0026#34;$ru\u0026#34;)) { xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;MSILO: offline message stored\\n\u0026#34;); if (!t_reply(\u0026#34;202\u0026#34;, \u0026#34;Accepted\u0026#34;)) { sl_reply_error(); }; }else{ xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;MSILO: offline message NOT stored\\n\u0026#34;); if (!t_reply(\u0026#34;503\u0026#34;, \u0026#34;Service Unavailable\u0026#34;)) { sl_reply_error(); }; }; exit; }; # if the downstream UA does not support MESSAGE requests # go to failure_route[1] t_on_failure(\u0026#34;1\u0026#34;); t_relay(); exit; }; # forward anything else t_relay(); } failure_route[1] { # forwarding failed -- check if the request was a MESSAGE if (!method==\u0026#34;MESSAGE\u0026#34;) { exit; }; xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;MSILO:the downstream UA doesn\u0026#39;t support MESSAGEs\\n\u0026#34;); # we have changed the R-URI with the contact address, ignore it now if (m_store(\u0026#34;$ou\u0026#34;)) { xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;MSILO: offline message stored\\n\u0026#34;); t_reply(\u0026#34;202\u0026#34;, \u0026#34;Accepted\u0026#34;); }else{ xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;MSILO: offline message NOT stored\\n\u0026#34;); t_reply(\u0026#34;503\u0026#34;, \u0026#34;Service Unavailable\u0026#34;); }; } 目前的配置示例使用的是MESSAGE消息。\n测试 本次测试分别使用软电话MicroSIP号码为1004,1008注册到kamailio, 然后使用MicroSIP的Message功能发送消息。\nMicroSIP的Message功能所在的位置为:\n坐席1008在线 坐席1008离线后再在线 坐席1008离线后,1004发送Message,信令图:\n通知信令图:\n数据表silo的数据为: 坐席1008上线之后, 收到了离线的信息: 相关的sip信令为: 总结 此功能主要是用作留言MESSAGE, 坐席也要支持MESSAGE信令才行。\n","date":"2025-07-22T11:26:27+08:00","image":"https://QuincyGao.github.io/p/kamailio-msilo-%E6%A8%A1%E5%9D%97/backup_hu16804477940127834048.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-msilo-%E6%A8%A1%E5%9D%97/","title":"kamailio msilo 模块"},{"content":"背景 动态路由可以根据前缀,被叫/组，时间,权重等因素来选择最优的路由路径。\n官方文档:drouting\n本次测试的opensips版本为:\nversion: opensips 3.5.5 (x86_64/linux)\n配置解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 数据库地址 modparam(\u0026#34;drouting\u0026#34;, \u0026#34;db_url\u0026#34;,\u0026#34;DBURL\u0026#34;) # gateway表 modparam(\u0026#34;drouting\u0026#34;, \u0026#34;drd_table\u0026#34;, \u0026#34;dr_gateways\u0026#34;) # 路由表 modparam(\u0026#34;drouting\u0026#34;, \u0026#34;drr_table\u0026#34;, \u0026#34;dr_rules\u0026#34;) # 路由组表 modparam(\u0026#34;drouting\u0026#34;, \u0026#34;drg_table\u0026#34;, \u0026#34;dr_groups\u0026#34;) # carriers表 modparam(\u0026#34;drouting\u0026#34;, \u0026#34;drc_table\u0026#34;, \u0026#34;dr_carriers\u0026#34;) # 黑名单表 modparam(\u0026#34;drouting\u0026#34;, \u0026#34;define_blacklist\u0026#34;, \u0026#39;bl_name= 3,5,25,23\u0026#39;) # 强制dns解析 modparam(\u0026#34;drouting\u0026#34;, \u0026#34;force_dns\u0026#34;, 0) # 持久化状态 modparam(\u0026#34;drouting\u0026#34;, \u0026#34;persistent_state\u0026#34;, 0) # 如果为1,则不允许并发重新加载配置,当有大量路由时，能避免内存暴增。 modparam(\u0026#34;drouting\u0026#34;, \u0026#34;no_concurrent_reload\u0026#34;, 1) # 路由探测时间间隔 modparam(\u0026#34;drouting\u0026#34;, \u0026#34;probing_interval\u0026#34;, 60) # 路由探测方法 modparam(\u0026#34;drouting\u0026#34;, \u0026#34;probing_method\u0026#34;, \u0026#34;INFO\u0026#34;) # 路由探测来源 modparam(\u0026#34;drouting\u0026#34;, \u0026#34;probing_from\u0026#34;, \u0026#34;sip:pinger@192.168.2.10\u0026#34;) # 路由探测回复码 modparam(\u0026#34;drouting\u0026#34;, \u0026#34;probing_reply_codes\u0026#34;, \u0026#34;501, 403\u0026#34;) # 路由探测socket modparam(\u0026#34;drouting\u0026#34;, \u0026#34;probing_socket\u0026#34;, \u0026#34;udp:192.168.1.100:5060\u0026#34;) # 当从数据库获取网关时,网关加载的过滤条件, \u0026#34;all\u0026#34;: 所有网关加载到内存. # \u0026#34;matched-only\u0026#34;: 只加载socket匹配的网关. # \u0026#34;ignore\u0026#34;: 忽略配置网关的socket值。 modparam(\u0026#34;drouting\u0026#34;, \u0026#34;gw_socket_filter_mode\u0026#34;, \u0026#34;matched-only\u0026#34;) 该模块总共使用dr_rules,dr_gateways,dr_carriers,dr_groups,dr_partitions五张表。\n重要函数 do_routing([groupID], [flags], [gw_whitelist], [rule_attrs_pvar], [gw_attrs_pvar], [carrier_attrs_pvar], [partition]) 根据规则路由\nroute_to_carrier( carriers, [gw_attrs_pvar], [carrier_attrs_pvar], [partition]) 路由到carriers表\nroute_to_gw(gw_id, [gw_attrs_var], [carrier_attrs_var], [partition]) 路由到gw_id网关\nuse_next_gw( [rule_attrs_pvar], [gw_attrs_pvar], [carrier_attrs_pvar], [partition]) 使用下一个网关\ngoes_to_gw( [type], [flags], [gw_attrs_pvar], [carrier_attrs_pvar], [partition]) 判断当前的请求URI是否路由到网关\nis_from_gw([type], [flags], [gw_attrs_pvar], [carrier_attrs_pvar], [partition]) 判断当前的发送信息(source IP + source port)是否路由到网关\ndr_is_gw( sip_uri, [type], [flags], [gw_attrs_pvar], [carrier_attrs_pvar], [partition]) 判断sip_uri是否路由到网关\ndr_disable([partition]) 设置路由禁用\ndr_match(groupID, [flags], number, [rule_attrs_pvar], [partition]) number 和 groupID 匹配\n实战 配置示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 socket=udp:172.16.4.111:5260 socket=udp:172.16.4.111:5261 ... loadmodule \u0026#34;drouting.so\u0026#34; modparam(\u0026#34;drouting\u0026#34;, \u0026#34;db_url\u0026#34;,\u0026#34;mysql://opensips:opensipsrw@172.16.4.111/opensips_3_5\u0026#34;) ... route{ ... route_to_gw(\u0026#34;1\u0026#34;); # if (!lookup(\u0026#34;location\u0026#34;,\u0026#34;method-filtering\u0026#34;)) { # t_newtran(); # t_reply(404, \u0026#34;Not Found\u0026#34;); # exit; # } # route(relay); } dr_gateways表插入数据: 1 2 3 4 INSERT INTO opensips_3_5.dr_gateways (`gwid`, `type`, `address`, `pri_prefix`, `attrs`, `probe_mode`, `socket`, `description`) VALUES (\u0026#39;1\u0026#39;, 0, \u0026#39;172.16.4.114:5060\u0026#39;, \u0026#39;10\u0026#39;, \u0026#39;ping fs\u0026#39;, 2, \u0026#39;udp:172.16.4.111:5260\u0026#39;, \u0026#39;test\u0026#39;); dr_groups表插入数据： 1 2 3 4 INSERT INTO opensips_3_5.dr_groups (`username`, `domain`, `groupid`, `description`) VALUES (\u0026#39;1004\u0026#39;,\u0026#39;172.16.4.111\u0026#39;, 2, \u0026#39;test\u0026#39;); dr_rules表插入数据: 1 2 3 4 INSERT INTO opensips_3_5.dr_rules (`groupid`,`prefix`,`timerec`, `priority`, `routeid`,`gwlist`,`sort_profile`,`attrs`,`description`) VALUES (\u0026#39;2\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;1753084591\u0026#39;, 1, \u0026#39;3\u0026#39;,\u0026#39;GW-1\u0026#39;, 0,\u0026#39;test-rules\u0026#39;,\u0026#39;test description\u0026#39;); dr_carriers表插入数据： 1 2 3 4 INSERT INTO opensips_3_5.dr_carriers (`carrierid`,`gwlist`,`flags`, `sort_alg`, `attrs`,`description`) VALUES (\u0026#39;3\u0026#39;,\u0026#39;GW-1\u0026#39;,0, \u0026#39;N\u0026#39;,\u0026#39;test-carriers\u0026#39;,\u0026#39;carriers description\u0026#39;); 测试 使用软电话1004拨打1008, 可以看到的信令图： 目前只成功使用route_to_gw, 其他的do_routing,route_to_carrier没使用成功。\n","date":"2025-07-15T09:26:01+08:00","image":"https://QuincyGao.github.io/p/opensips-drouting-%E6%A8%A1%E5%9D%97/backup_hu8930028521629260893.jpg","permalink":"https://QuincyGao.github.io/p/opensips-drouting-%E6%A8%A1%E5%9D%97/","title":"opensips drouting 模块"},{"content":"背景 mi_script 提供了方法调用mi管理接口, 支持同步或者异步方式. 官方地址:mi_script\n本次测试的opensips版本为:\nversion: opensips 3.5.5 (x86_64/linux)\n配置解析 1 2 3 4 5 6 # 是否格式化json返回值打印,默认:0 modparam(\u0026#34;mi_script\u0026#34;, \u0026#34;pretty_printing\u0026#34;, 1) # 设置trace的地址,要结合`sip_trace`使用 modparam(\u0026#34;mi_stream\u0026#34;, \u0026#34;trace_destination\u0026#34;, \u0026#34;hep_dest\u0026#34;) # 设置trace的黑白名单 modparam(\u0026#34;mi_stream\u0026#34;, \u0026#34;trace_bwlist\u0026#34;, \u0026#34;w: sip_trace\u0026#34;) 主要函数 mi(command, [ret_var [,params_avp[, vals_avp]]]) 同步调用mi接口,返回值为0表示成功.\n如果想异步执行，可以这样:\n1 2 3 4 5 6 7 route { async(mi(\u0026#34;dr_reload\u0026#34;), after_reload); } route[after_reload] { xlog(\u0026#34;reload completed\\n\u0026#34;); } 实战 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 loadmodule \u0026#34;mi_script.so\u0026#34; modparam(\u0026#34;mi_script\u0026#34;, \u0026#34;pretty_printing\u0026#34;, 1) route { ... if (is_method(\u0026#34;REGISTER\u0026#34;)) { # indicate that the client supports DTLS # so we know when he is called if (isflagset(\u0026#34;SRC_WS\u0026#34;)) setbflag(\u0026#34;DST_WS\u0026#34;); fix_nated_register(); if (!save(\u0026#34;location\u0026#34;)) sl_reply_error(); mi(\u0026#34;ul_dump\u0026#34;, $var(ret)); xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---main-1-:$rm|$rs|$tu|-dump: $var(ret)\\n\u0026#34;); exit; } ... } 官方的示例:\n1 2 3 modparam(\u0026#34;proto_hep\u0026#34;, \u0026#34;trace_destination\u0026#34;, \u0026#34;[hep_dest]10.0.0.2;transport=tcp;version=3\u0026#34;) modparam(\u0026#34;mi_stream\u0026#34;, \u0026#34;trace_destination\u0026#34;, \u0026#34;hep_dest\u0026#34;) 存在的问题,已提issue:\nproto_hep没有trance_destination参数. mi_stream应该为mi_script 测试 mi(\u0026quot;ul_dump\u0026quot;, $var(ret)) 打印的日志为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ul 9 11:01:34 [693] DBG:[201][fef6cc7387cd433189b0fde83b2f3942]---main-1-:REGISTER|\u0026lt;null\u0026gt;|sip:1005@172.16.4.111|-dump: { \u0026#34;Domains\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;location\u0026#34;, \u0026#34;hash_size\u0026#34;: 512, \u0026#34;AORs\u0026#34;: [{ \u0026#34;AOR\u0026#34;: \u0026#34;1005\u0026#34;, \u0026#34;Contacts\u0026#34;: [{ \u0026#34;Contact\u0026#34;: \u0026#34;sip:1005@172.16.80.13:60773;ob\u0026#34;, \u0026#34;ContactID\u0026#34;: \u0026#34;3784712536851487464\u0026#34;, \u0026#34;Expires\u0026#34;: \u0026#34;deleted\u0026#34;, \u0026#34;Q\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Callid\u0026#34;: \u0026#34;fef6cc7387cd433189b0fde83b2f3942\u0026#34;, \u0026#34;Cseq\u0026#34;: 51796, \u0026#34;User-agent\u0026#34;: \u0026#34;MicroSIP/3.21.6\u0026#34;, \u0026#34;Received\u0026#34;: \u0026#34;sip:172.16.80.13:60773\u0026#34;, \u0026#34;State\u0026#34;: \u0026#34;CS_SYNC\u0026#34;, \u0026#34;Flags\u0026#34;: 0, \u0026#34;Cflags\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Socket\u0026#34;: \u0026#34;udp:172.16.4.111:5261\u0026#34;, \u0026#34;Methods\u0026#34;: 8063 }] }] }] } mi(ul_show_contact, $var(ret), $avp(params)) 参考示例：\n1 2 3 4 5 6 $avp(params) = \u0026#34;local\u0026#34;; $avp(params) = \u0026#34;password_user1\u0026#34;; mi(\u0026#34;cache_remove\u0026#34;,,$avp(params)); # the following command is similar to the above mi(\u0026#34;cache_remove local password_user1\u0026#34;); 按照示例方式配置, 目前请求失败:Table not found:\n1 2 3 $avp(params) = \u0026#34;location\u0026#34;; $avp(params) = \u0026#34;1005\u0026#34;; mi(\u0026#34;ul_show_contact\u0026#34;,$var(ret),$avp(params)); 改成下面的设置:\n1 mi(\u0026#34;ul_show_contact location 1005\u0026#34;,$var(ret)); 可以正常返回结果:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \u0026#34;AOR\u0026#34;: \u0026#34;1005\u0026#34;, \u0026#34;Contacts\u0026#34;: [{ \u0026#34;Contact\u0026#34;: \u0026#34;sip:1005@172.16.80.13:60773;ob\u0026#34;, \u0026#34;ContactID\u0026#34;: \u0026#34;3784712536851487479\u0026#34;, \u0026#34;Expires\u0026#34;: \u0026#34;deleted\u0026#34;, \u0026#34;Q\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Callid\u0026#34;: \u0026#34;9d06d410ffee4f65b9a20dc771a0076c\u0026#34;, \u0026#34;Cseq\u0026#34;: 46793, \u0026#34;User-agent\u0026#34;: \u0026#34;MicroSIP/3.21.6\u0026#34;, \u0026#34;Received\u0026#34;: \u0026#34;sip:172.16.80.13:60773\u0026#34;, \u0026#34;State\u0026#34;: \u0026#34;CS_SYNC\u0026#34;, \u0026#34;Flags\u0026#34;: 0, \u0026#34;Cflags\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Socket\u0026#34;: \u0026#34;udp:172.16.4.111:5261\u0026#34;, \u0026#34;Methods\u0026#34;: 8063 }] } 总结 使用mi_script模块，可以调用mi接口，查看服务状态。\n","date":"2025-07-09T10:49:28+08:00","image":"https://QuincyGao.github.io/p/opensips-mi_script%E6%A8%A1%E5%9D%97/backup_hu12379180249080152000.jpg","permalink":"https://QuincyGao.github.io/p/opensips-mi_script%E6%A8%A1%E5%9D%97/","title":"opensips mi_script模块"},{"content":"背景 fail2ban 是用来通过服务日志，监控异常IP, 并根据配置，自动封禁这些IP。\n最近在把opensips部署到外网之后，发现外网有很多攻击IP, 于是想通过fail2ban来监控攻击IP。 fail2ban的官方地址:fail2ban\n当然前提是opensips要把日志输出LOG_LOCAL0, 然后使用rsyslog来收集日志。\n本次测试的fail2ban的版本为：\n1.1.1.1\n测试 安装准备 Python3.7 nftables 本次采用手动安装, 先安装Python3.7, fail2ban默认使用的是nftables来拦截IP, 再安装nftables:yum install -y nftables。\n安装fail2ban 安装fail2ban: 1 2 3 git clone https://github.com/fail2ban/fail2ban.git cd fail2ban python3.7 setup.py install 运行fail2ban: 1 2 3 4 cp fail2ban/build/fail2ban.service /etc/systemd/system/ systemctl daemon-reload systemctl start fail2ban systemctl enable fail2ban 如果systemctl start fail2ban运行失败，日志也没什么报错，但是手动运行/usr/local/bin/fail2ban-server -xf start成功， 那么就是python环境问题，请在fail2ban.service里添加:Environment=\u0026quot;PYTHONPATH=/usr/local/lib/python3.7/site-packages\u0026quot;\n配置fail2ban fail2ban的配置文件在/etc/fail2ban/下,\n1 2 cp jail.conf jail.local cp fail2ban.conf fail2ban.local 由于没使用数据库，所以需要设置dbfile = None\n在fail2ban.local里: 1 dbfile = None jail.lcal新增: 1 2 3 4 5 6 7 8 [sbc] enabled = true port = 5060,5080,5088 action_ = %(default/action_)s[name=%(__name__)s-tcp, protocol=\u0026#34;tcp\u0026#34;] %(default/action_)s[name=%(__name__)s-udp, protocol=\u0026#34;udp\u0026#34;] logpath = /data/opensips/log/opensips.log maxretry = 5 bantime = 3600 新增filter/sbc.conf 1 2 3 4 5 6 7 8 9 10 11 [INCLUDES] before = common.conf [Definition] _daemon = sbc mode = normal failregex= user:\\d+,ip:\u0026lt;HOST\u0026gt; not match white list 主要是failregex的配置，这个是opensips的日志中出错时要屏蔽的IP, 日志是自定义的。\n验证效果 查看/var/log/fail2ban.log日志: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 2025-07-04 17:13:15,070 fail2ban.filter [3256715]: INFO [sbc] Found 108.181.9.67 - 2025-07-04 17:13:04 2025-07-04 17:13:15,071 fail2ban.filter [3256715]: INFO [sbc] Found 198.204.234.202 - 2025-07-04 17:13:04 2025-07-04 17:13:15,072 fail2ban.filter [3256715]: INFO [sbc] Found 108.181.9.67 - 2025-07-04 17:13:04 2025-07-04 17:13:15,073 fail2ban.filter [3256715]: INFO [sbc] Found 198.204.234.202 - 2025-07-04 17:13:04 2025-07-04 17:13:15,075 fail2ban.filter [3256715]: INFO [sbc] Found 198.204.234.202 - 2025-07-04 17:13:04 2025-07-04 17:13:15,076 fail2ban.filter [3256715]: INFO [sbc] Found 198.204.234.202 - 2025-07-04 17:13:04 2025-07-04 17:13:15,077 fail2ban.filter [3256715]: INFO [sbc] Found 108.181.9.67 - 2025-07-04 17:13:04 2025-07-04 17:13:15,078 fail2ban.filter [3256715]: INFO [sbc] Found 108.181.9.67 - 2025-07-04 17:13:04 2025-07-04 17:13:15,079 fail2ban.filter [3256715]: INFO [sbc] Found 108.181.9.67 - 2025-07-04 17:13:04 2025-07-04 17:13:15,080 fail2ban.filter [3256715]: INFO [sbc] Found 108.181.9.67 - 2025-07-04 17:13:04 2025-07-04 17:13:15,082 fail2ban.actions [3256715]: NOTICE [sbc] 108.181.9.67 already banned 2025-07-04 17:13:15,083 fail2ban.filter [3256715]: INFO [sbc] Found 108.181.9.67 - 2025-07-04 17:13:04 2025-07-04 17:13:15,084 fail2ban.actions [3256715]: NOTICE [sbc] 108.181.9.67 already banned 2025-07-04 17:13:15,086 fail2ban.filter [3256715]: INFO [sbc] Found 108.181.9.67 - 2025-07-04 17:13:04 2025-07-04 17:13:15,086 fail2ban.actions [3256715]: NOTICE [sbc] 108.181.9.67 already banned fail2ban-client status sbc: 1 2 3 4 5 6 7 8 9 10 fail2ban-client status sbc Status for the jail: sbc |- Filter | |- Currently failed: 2 | |- Total failed: 566 | `- File list: /data/opensips/log/opensips.log `- Actions |- Currently banned: 3 |- Total banned: 3 `- Banned IP list: 108.181.9.67 198.204.234.202 108.181.6.47 可以看到108.181.9.67已经被屏蔽了，并且opensips.log也没有记录108.181.9.67的错误日志。\n不过，如果使用sngrep还是可以看到来源是108.181.9.67的大量sip请求。\n其他用法 fail2ban-regex 这个功能是对sbc.conf过滤规则进行测试。 比如: fail2ban-regex /data/opensips/log/opensips.log /etc/fail2ban/filter.d/sbc.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 Running tests ============= Use filter file : sbc, basedir: /etc/fail2ban Use datepattern : {^LN-BEG} : Default Detectors Use log file : /data/opensips/log/opensips.log Use encoding : UTF-8 Results ======= Failregex: 8044 total |- #) [# of hits] regular expression | 1) [8044] user:\\d+,ip:\u0026lt;HOST\u0026gt; not match white list `- Ignoreregex: 0 total Date template hits: |- [# of hits] date format | [156150] {^LN-BEG}(?:DAY )?MON Day %k:Minute:Second(?:\\.Microseconds)?(?: ExYear)? `- Lines: 156150 lines, 0 ignored, 8044 matched, 148106 missed [processed in 10.70 sec] Missed line(s): too many to print. Use --print-all-missed to print all 148106 lines 更改底层屏蔽组件jail.local 1 2 anaction = iptables-multiport banaction_allports = iptables-allports 默认使用的是nftables, 如果想要改成其他的，参考action.d/xxx,可以选择firewallcmd,iptables,nftables\n改完要systemctl restart fail2ban,使用fail2ban-client reload不行。\n总结 通过fail2ban可以根据服务日志来设置需要屏蔽的IP, 可以设置屏蔽时间以及白名单ip等。\n","date":"2025-07-07T10:49:40+08:00","image":"https://QuincyGao.github.io/p/fail2ban-%E4%BD%BF%E7%94%A8/backup_hu12623801686498752555.jpg","permalink":"https://QuincyGao.github.io/p/fail2ban-%E4%BD%BF%E7%94%A8/","title":"fail2ban 使用"},{"content":"背景 最近梳理了opensips作为代理的配置，并结合rfc3665重新实现了该功能,现对其记录如下。\n本次测试的opensips版本为:\nversion: opensips 3.5.5 (x86_64/linux)\n实战 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 ###### Global Parameters ######### xlog_level=4 #debug_mode=yes stderror_enabled=yes syslog_facility=LOG_LOCAL0 # Set up listeners #socket=tls:127.0.0.1:5261 socket=udp:172.16.4.111:5260 socket=udp:172.16.4.111:5261 ####### Modules Section ######## # set module path mpath=\u0026#34;/usr/local/lib64/sbc/modules/\u0026#34; #### SIGNALING module loadmodule \u0026#34;signaling.so\u0026#34; loadmodule \u0026#34;db_mysql.so\u0026#34; #### StateLess module loadmodule \u0026#34;sl.so\u0026#34; #### Transaction Module loadmodule \u0026#34;tm.so\u0026#34; modparam(\u0026#34;tm\u0026#34;, \u0026#34;fr_timeout\u0026#34;, 5) modparam(\u0026#34;tm\u0026#34;, \u0026#34;fr_inv_timeout\u0026#34;, 30) modparam(\u0026#34;tm\u0026#34;, \u0026#34;restart_fr_on_each_reply\u0026#34;, 0) modparam(\u0026#34;tm\u0026#34;, \u0026#34;onreply_avp_mode\u0026#34;, 1) #### Record Route Module loadmodule \u0026#34;rr.so\u0026#34; modparam(\u0026#34;rr\u0026#34;, \u0026#34;append_fromtag\u0026#34;, 0) #### MAX ForWarD module loadmodule \u0026#34;maxfwd.so\u0026#34; #### SIP MSG OPerationS module loadmodule \u0026#34;sipmsgops.so\u0026#34; #### FIFO Management Interface loadmodule \u0026#34;mi_fifo.so\u0026#34; modparam(\u0026#34;mi_fifo\u0026#34;, \u0026#34;fifo_name\u0026#34;, \u0026#34;/tmp/opensips_fifo\u0026#34;) modparam(\u0026#34;mi_fifo\u0026#34;, \u0026#34;fifo_mode\u0026#34;, 0666) loadmodule \u0026#34;httpd.so\u0026#34; loadmodule \u0026#34;mi_http.so\u0026#34; modparam(\u0026#34;httpd\u0026#34;,\u0026#34;port\u0026#34;,9998) #### USeR LOCation module loadmodule \u0026#34;usrloc.so\u0026#34; modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;nat_bflag\u0026#34;, \u0026#34;NAT\u0026#34;) modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;working_mode_preset\u0026#34;, \u0026#34;single-instance-sql-write-back\u0026#34;) modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;db_url\u0026#34;, \u0026#34;mysql://opensips:opensipsrw@172.16.4.111/opensips\u0026#34;) #### REGISTRAR module loadmodule \u0026#34;registrar.so\u0026#34; #### RTPengine protocol loadmodule \u0026#34;rtpengine.so\u0026#34; modparam(\u0026#34;rtpengine\u0026#34;, \u0026#34;rtpengine_sock\u0026#34;, \u0026#34;udp:172.16.4.111:2222\u0026#34;) #### Nathelper protocol loadmodule \u0026#34;nathelper.so\u0026#34; modparam(\u0026#34;registrar|nathelper\u0026#34;, \u0026#34;received_avp\u0026#34;, \u0026#34;$avp(rcv)\u0026#34;) #### UDP protocol loadmodule \u0026#34;proto_udp.so\u0026#34; loadmodule \u0026#34;proto_tcp.so\u0026#34; #### TLS protocol #loadmodule \u0026#34;proto_tls.so\u0026#34; #### WebSocket and WebSocketSecure protocol #loadmodule \u0026#34;proto_wss.so\u0026#34; loadmodule \u0026#34;proto_ws.so\u0026#34; ####### Routing Logic ######## # main request routing logic route{ if (!mf_process_maxfwd_header(10)) { sl_send_reply(483,\u0026#34;Too Many Hops\u0026#34;); exit; } if (has_totag()) { # sequential requests within a dialog should # take the path determined by record-routing if (loose_route()) { if (is_method(\u0026#34;INVITE\u0026#34;)) { # even if in most of the cases is useless, do RR for # re-INVITEs alos, as some buggy clients do change route set # during the dialog. record_route(); } xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---has-tag-:$rm|$rs|$tu|$socket_in(port)|$var(contact)\\n\u0026#34;); if ($si == \u0026#34;172.16.4.114\u0026#34;) { $socket_out=\u0026#34;udp:172.16.4.111:5261\u0026#34;; } else { $socket_out=\u0026#34;udp:172.16.4.111:5260\u0026#34;; } # route it out to whatever destination was set by loose_route() # in $du (destination URI). route(relay); } else { if ( is_method(\u0026#34;ACK\u0026#34;) ) { if ( t_check_trans() ) { # non loose-route, but stateful ACK; must be an ACK after # a 487 or e.g. 404 from upstream server t_relay(); exit; } else { # ACK without matching transaction -\u0026gt; # ignore and discard exit; } } sl_send_reply(404,\u0026#34;Not here\u0026#34;); } exit; } # CANCEL processing if (is_method(\u0026#34;CANCEL\u0026#34;)) { if (t_check_trans()) t_relay(); exit; } t_check_trans(); #if (!is_method(\u0026#34;REGISTER\u0026#34;)) { #\tif (is_myself(\u0026#34;$fd\u0026#34;)) { #\t# if caller is not local, then called number must be local #\tif (!is_myself(\u0026#34;$rd\u0026#34;)) { #\tsend_reply(403,\u0026#34;Rely forbidden\u0026#34;); #\texit; #\t} #\t} #} # preloaded route checking if (loose_route()) { xlog(\u0026#34;L_ERR\u0026#34;, \u0026#34;Attempt to route with preloaded Route\u0026#39;s [$fu/$tu/$ru/$ci]\u0026#34;); if (!is_method(\u0026#34;ACK\u0026#34;)) sl_send_reply(403,\u0026#34;Preload Route denied\u0026#34;); exit; } # record routing if (!is_method(\u0026#34;REGISTER|MESSAGE\u0026#34;)) record_route_preset(\u0026#34;172.16.4.111:5260\u0026#34;); if (!is_myself(\u0026#34;$rd\u0026#34;)) { append_hf(\u0026#34;P-hint: outbound\\r\\n\u0026#34;); route(relay); } # requests for my domain if (is_method(\u0026#34;PUBLISH|SUBSCRIBE\u0026#34;)) { sl_send_reply(503, \u0026#34;Service Unavailable\u0026#34;); exit; } # check if the clients are using WebSockets or WebSocketSecure if ( $socket_in(proto) == \u0026#34;WS\u0026#34;|| $socket_in(proto) == \u0026#34;WSS\u0026#34;) setflag(\u0026#34;SRC_WS\u0026#34;); # consider the client is behind NAT - always fix the contact fix_nated_contact(); xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---main-1-:$rm|$rs|$tu|$socket_in(port)|$var(contact)\\n\u0026#34;); if (is_method(\u0026#34;REGISTER\u0026#34;)) { # indicate that the client supports DTLS # so we know when he is called if (isflagset(\u0026#34;SRC_WS\u0026#34;)) setbflag(\u0026#34;DST_WS\u0026#34;); fix_nated_register(); if (!save(\u0026#34;location\u0026#34;)) sl_reply_error(); exit; } xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---main--:$rm|$rs|$tu|$socket_in(port)|$var(contact)\\n\u0026#34;); if ($rU==NULL) { # request with no Username in RURI sl_send_reply(484,\u0026#34;Address Incomplete\u0026#34;); exit; } if ($si != \u0026#34;172.16.4.114\u0026#34;) { $du = \u0026#34;sip:172.16.4.114:5060\u0026#34;; $socket_out=\u0026#34;udp:172.16.4.111:5260\u0026#34;; } #\t# do lookup with method filtering #\tif (!lookup(\u0026#34;location\u0026#34;,\u0026#34;method-filtering\u0026#34;)) { #\tt_newtran(); #\tt_reply(404, \u0026#34;Not Found\u0026#34;); #\texit; #\t} route(relay); } route[relay] { # for INVITEs enable some additional helper routes if (is_method(\u0026#34;INVITE\u0026#34;)) { t_on_branch(\u0026#34;handle_nat\u0026#34;); t_on_reply(\u0026#34;handle_nat\u0026#34;); } else if (is_method(\u0026#34;BYE|CANCEL\u0026#34;)) { rtpengine_delete(); } if (!t_relay()) { send_reply(500,\u0026#34;Internal Error\u0026#34;); }; exit; } branch_route[handle_nat] { xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;[$cfg_line][$ci]--m01---:$rm|$rs|$tu|$rU|$fU|$si|$socket_in(proto)|$socket_in(port)\\n\u0026#34;); if (!is_method(\u0026#34;INVITE\u0026#34;) || !has_body(\u0026#34;application/sdp\u0026#34;)) return; $var(rtp_flag) = \u0026#34;replace-origin \u0026#34;; if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) { #web-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; ICE=force-relay DTLS=passive\u0026#34;; } else if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)){ #web-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; codec-strip-G722 codec-strip-CN codec-strip-red strip-extmap rtcp-mux-demux DTLS=off SDES-off ICE=remove RTP/AVP\u0026#34;; } else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) {#sip-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; rtcp-mux-offer generate-mid DTLS=passive SDES-off ICE=force RTP/SAVPF\u0026#34;; } else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)) #sip-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; DTLS=off SDES-off ICE=remove RTP/AVP\u0026#34;; rtpengine_offer(\u0026#34;$var(rtp_flag)\u0026#34;); } onreply_route[handle_nat] { xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;[$cfg_line][$ci]--onreply-route---:$rm|$rs|$tu|$rU|$fU|$si|$socket_in(proto)|$socket_in(port)\\n\u0026#34;); if (is_present_hf(\u0026#34;Record-Route\u0026#34;)) { remove_hf(\u0026#34;Record-Route\u0026#34;); append_hf(\u0026#34;Record-Route: \u0026lt;sip:172.16.4.111:5261;lr\u0026gt;\\r\\n\u0026#34;); xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;has record-route..\\n\u0026#34;); } fix_nated_contact(); if (!has_body(\u0026#34;application/sdp\u0026#34;)) return; $var(rtp_flag) = \u0026#34;replace-origin \u0026#34;; if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) #web-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; ICE=force-relay DTLS=passive\u0026#34;; else if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)) #web-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; codec-strip-G722 codec-strip-CN codec-strip-red codec-strip-opus rtcp-mux-offer generate-mid DTLS=passive SDES-off ICE=force\u0026#34;; else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) #sip-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; rtcp-mux-offer generate-mid DTLS=passive SDES-off ICE=remove RTP/AVP\u0026#34;; else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)) #sip-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; DTLS=off SDES-off ICE=remove RTP/AVP\u0026#34;; rtpengine_answer(\u0026#34;$var(rtp_flag)\u0026#34;); } 测试 使用场景为:\n拨打的完整信令图:\n详细的信令信息：\n拨打opensips的INVITE: 主要看Request-URI,Via,Contact字段。\nopensips转发INVITE: 这里我并没有修改Request-URI,添加了Record-Route.\n这个Record-Route是为了uas发BYE可以到正确的端口上。\nContact是uas在接通之后，任何消息的Request-URI,比如本例中的INFO, BYE\n之后的183和200OK是通过Via找到回去的路由。\nopensips收到200OK后: 主要看Via字段。\nopensips转发200OK: 主要看Via,Record-Route,Contact字段。\n这里的Record-Route是为了uas接通之后，发送信令如：BYE,INFO到正确的端口上.\nContact是uac接通之后，任何消息的Request-URI,比如ACK,BYE。\nopensips收到ACK: opensips转发ACK: opensips收到uas的INFO: opensips转发INFO: opensips收到200OK: opensips转发200OK: opensips收到uac的INFO: opensips转发INFO: opensips收到200ok: opensips转发200OK: opensips收到uas的BYE: opensips转发BYE: opensips收到uac的200OK: opensips转发200OK: 总结 当未接通时，需要设置Record-Route,$du,$socket_out。\n前提是Contact未修改，如果Contact修改了,那么整个流程都要一起变。\n当通话接通之后，整个流程都不需要设置，只设置$socket_out。\n问题: 可以看到uac在收到200OK时,Contact是uas的地址,我们并不希望uac知道uas的地址。 uac后续的Request-URI都使用uas的地址，这个是不安全的, 需要修改Contact为opensips的地址。\n","date":"2025-07-02T10:14:05+08:00","image":"https://QuincyGao.github.io/p/opensips-%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/backup_hu15197335820753552228.jpg","permalink":"https://QuincyGao.github.io/p/opensips-%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/","title":"opensips 基础代理设置"},{"content":"背景 call_center是一个带有呼入队列和坐席的呼叫中心，实现了呼入排队,坐席分配，坐席管理,坐席CDR, 依赖b2b_logic和database。官方文档地址:call_center\n本次测试的opensips版本为:\nversion: opensips 3.5.5 (x86_64/linux)\n目前没调通, 只是记录一下测试情况。\n参数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 数据库地址,cc_flows, cc_agents, cc_calls表 modparam(\u0026#34;call_center\u0026#34;, \u0026#34;db_url\u0026#34;, \u0026#34;DB_URL\u0026#34;) # 数据库地址,cc_cdrs表 modparam(\u0026#34;call_center\u0026#34;, \u0026#34;acc_db_url\u0026#34;, \u0026#34;DB_URL\u0026#34;) # 运行时的库地址,只有cc_calls表 modparam(\u0026#34;call_center\u0026#34;, \u0026#34;rt_db_url\u0026#34;, \u0026#34;DB_URL\u0026#34;) # 坐席呼叫完成后,下一次接收呼叫的等待时间,默认: 30s modparam(\u0026#34;call_center\u0026#34;, \u0026#34;wrapup_time\u0026#34;, 45) # 将呼叫发送给媒体进行等待播放时,用于报告等待队列中的SIPURL的参数名称. modparam(\u0026#34;call_center\u0026#34;, \u0026#34;queue_pos_param\u0026#34;, \u0026#34;cc_pos\u0026#34;) # 当没有可用的坐席时,是否拒绝呼叫,默认: 1 modparam(\u0026#34;call_center\u0026#34;, \u0026#34;reject_on_no_agents\u0026#34;, 0) # 分发坐席的策略, balancing: 轮询分配 ;full-load:当有坐席接通后，后面的呼叫不会分配给其他坐席 modparam(\u0026#34;call_center\u0026#34;, \u0026#34;chat_dispatch_policy\u0026#34;, \u0026#34;balancing\u0026#34;) # 内部电话是否也进行分机分配,默认: 1 modparam(\u0026#34;call_center\u0026#34;, \u0026#34;internal_call_dispatching\u0026#34;, 0) # 坐席表,默认:\u0026#34;cc_agents\u0026#34; modparam(\u0026#34;call_center\u0026#34;, \u0026#34;cc_agents_table\u0026#34;, \u0026#34;my_agents\u0026#34;) # 流程表,默认: \u0026#34;cc_flows\u0026#34; modparam(\u0026#34;call_center\u0026#34;, \u0026#34;cc_flows_table\u0026#34;, \u0026#34;queues\u0026#34;) # $b2b_logic.ctx变量名 modparam(\u0026#34;call_center\u0026#34;, \u0026#34;b2b_logic_ctx_param\u0026#34;, \u0026#34;b2b_callid\u0026#34;) 重要函数 cc_handle_call( flowID [,param]) 必须用在INVITE请求中, 返回值：\n-1: 不能获取flowID参数 -2: 不能解析From URI -3: flowID在数据库中没找到 -4: 没有坐席在该flow中 -5: 内部错误 cc_agent_login(agentID, state) 设置坐席的状态, state:0,下线；其他:上线\n实战 配置示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 loadmodule \u0026#34;event_route.so\u0026#34; loadmodule \u0026#34;uac_auth.so\u0026#34; loadmodule \u0026#34;b2b_entities.so\u0026#34; loadmodule \u0026#34;b2b_logic.so\u0026#34; loadmodule \u0026#34;call_center.so modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;contact_user\u0026#34;, 1) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;server_address\u0026#34;, \u0026#34;sip:$fU@$socket_in(ip):$socket_in(port)\u0026#34;) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;db_mode\u0026#34;, 1) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;b2bl_th_init_timeout\u0026#34;, 60) modparam(\u0026#34;call_center\u0026#34;, \u0026#34;db_url\u0026#34;, \u0026#34;mysql://opensips:opensipsrw@172.16.4.111/opensips_3_5\u0026#34;) modparam(\u0026#34;call_center\u0026#34;, \u0026#34;wrapup_time\u0026#34;, 45) modparam(\u0026#34;call_center\u0026#34;, \u0026#34;queue_pos_param\u0026#34;, \u0026#34;cc_pos\u0026#34;) route { ... if(is_method(\u0026#34;INVITE\u0026#34;) \u0026amp;\u0026amp; !has_totag()) { xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---call-center-new--rm|$rs|$tu|$socket_in(port)|$var(contact)\\n\u0026#34;); if (!cc_handle_call(\u0026#34;tech_support\u0026#34;)) { send_reply(403,\u0026#34;Cannot handle call\u0026#34;); exit; } exit; } ... } event_route[E_CALLCENTER_AGENT_REPORT]{ xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;$param(1), $param(2)\\n\u0026#34;); } 数据表cc_flows插入数据:\n1 insert into opensips_3_5.cc_flows(\u0026#39;flowid\u0026#39;,\u0026#39;skill\u0026#39;,\u0026#39;message_welcome\u0026#39;,\u0026#39;message_queue\u0026#39;)value(\u0026#39;tech_support\u0026#39;,\u0026#39;test\u0026#39;,\u0026#39;sip:9999@172.16.4.114:5060\u0026#39;,\u0026#39;sip:172.16.4.113:5050\u0026#39;); 数据表cc_agent插入数据:\n1 insert into opensips_3_5.cc_agents(\u0026#39;agentid\u0026#39;,\u0026#39;location\u0026#39;,\u0026#39;skills\u0026#39;)values(\u0026#39;1008\u0026#39;,\u0026#39;sip:1008@172.16.4.114:5060\u0026#39;,\u0026#39;test\u0026#39;); 测试 理想的逻辑应该是软电话1005呼叫1008, 播放等待音，再拨打1008号码. 目前只到了播放等待音，不能转坐席.\n手动让坐席上线 opensips-cli -x mi cc_agent_login 1008 1\n软电话1005呼叫1008 可以看到call_center使用了b2b_logic生成新的call-id:\n新的请求SIP URL的地址是cc_flows里的message_welcome字段， 172.16.4.114:5060是freeswitch,我配了个播放音的dialplain/public.xml：\n1 2 3 4 5 6 7 \u0026lt;extension name=\u0026#34;play_9999\u0026#34;\u0026gt; \u0026lt;condition field=\u0026#34;destination_number\u0026#34; expression=\u0026#34;^9999$\u0026#34;\u0026gt; \u0026lt;action application=\u0026#34;answer\u0026#34;/\u0026gt; \u0026lt;action application=\u0026#34;sleep\u0026#34; data=\u0026#34;1000\u0026#34;/\u0026gt; \u0026lt;action application=\u0026#34;playback\u0026#34; data=\u0026#34;/usr/local/freeswitch/share/freeswitch/sounds/en/us/callie/ivr/48000/ivr-welcome_to_freeswitch.wav\u0026#34;/\u0026gt; \u0026lt;/condition\u0026gt; \u0026lt;/extension\u0026gt; 报错日志:\n1 2 3 4 5 6 7 8 Jul 1 15:20:17 [839] DBG:[245][5ecb0e8751ce43bebbd0629278e025b1]---call-center-new--rm|\u0026lt;null\u0026gt;|sip:1008@172.16.4.111|5261|\u0026lt;null\u0026gt; Jul 1 15:20:21 [838] WARNING:b2b_logic:b2b_get_local_contact: Failed to print format string from \u0026#39;server_address\u0026#39; Jul 1 15:20:21 [838] ERROR:b2b_logic:b2b_get_local_contact: No current SIP message, failed to build Contact from send socket Jul 1 15:20:21 [838] ERROR:b2b_logic:b2bl_new_client: Failed to build Contact Jul 1 15:20:21 [838] ERROR:b2b_logic:bridging_new_client: Failed to generate new client Jul 1 15:20:21 [838] ERROR:b2b_logic:b2bl_api_bridge: Failed to start bridging with new entity Jul 1 15:20:21 [838] ERROR:call_center:set_call_leg: bridging failed Jul 1 15:20:21 [838] ERROR:call_center:b2bl_callback_customer: failed to set new destination for call 目前没有找到正确使用call_center的opensips.cfg配置.\n","date":"2025-07-01T15:17:57+08:00","image":"https://QuincyGao.github.io/p/opensips-call_center%E6%A8%A1%E5%9D%97/backup_hu16713040506039523758.jpg","permalink":"https://QuincyGao.github.io/p/opensips-call_center%E6%A8%A1%E5%9D%97/","title":"opensips call_center模块"},{"content":"背景 ratelimit模块用来限制sip请求, 并不是按照源ip来限制,可以根据不同的分组设置,和pike不同.\n该模块可以和Redis或者memcache结合, 可以实现集群opensips的统一限制。 另外也可以使用clusterer分布式模块,使用pipe_replication_cluster参数,把pipes复制到其他的实例上。\n如果要使用CacheDB发送，就在pipes后加/r, 如果要用clusterer,就在pipes后加/b。\n支持的算法有:\n(Tail Drop Algorithm)TAILDROP: 请求达到限制后，后面的请求丢弃 (Random Early Detection Algorithm)RED: 随机早期检测算法，测量平均负载并动态调整丢包率 (Slot Based Taildropping)SBT: 持有一个或多个slot组成的窗口. NETWORK: 依赖网口上等待消耗的字节数 FEEDBACK: 使用PID控制模型, 根据负载因子动态调整下降率. 官方文档地址:ratelimit\n本次测试的opensips版本:\nversion: opensips 3.5.5 (x86_64/linux)\n配置参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 定时时间间隔,单位秒,默认:10 modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;timer_interval\u0026#34;, 5) # 每个时间间隔的限制数,默认:0(每秒), 1:(每timer_interval) modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;limit_per_interval\u0026#34;, 1) # 多长时间pipe保存在内存中,默认: 3600 modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;expire_time\u0026#34;, 1800) # 哈希表大小,默认: 1024 modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;hash_size\u0026#34;, 512) # 设置算法， 默认: TAILDROP modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;default_algorithm\u0026#34;, \u0026#34;RED\u0026#34;) # 缓存数据库的URL,默认: \u0026#34;\u0026#34; modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;cachedb_url\u0026#34;, \u0026#34;redis://root:root@127.0.0.1/\u0026#34;) # 缓存数据库的key前缀,默认: \u0026#34;rl_pipe_\u0026#34; modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;db_prefix\u0026#34;, \u0026#34;ratelimit_\u0026#34;) # 设置集群下的发送buffer大小,默认: 32767 bytes modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;repl_buffer_threshold\u0026#34;, 500) # 集群模式下, 发送数据的时间间隔,默认: 200ms modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;repl_timer_interval\u0026#34;, 100) # 集群模式下, 发送数据的过期时间,默认: 10s modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;repl_timer_expire\u0026#34;, 10) # 设置集群id modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;pipe_replication_cluster\u0026#34;, 1) # SBT窗口大小,默认: 10 modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;window_size\u0026#34;, 5) # SBT的slot间隔,单位ms。 modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;slot_period\u0026#34;, 100) 重要函数 rl_check(name, limit[, algorithm]) 当前请求和pipe name的算法比较限制数, 如果pipe没有,会根据限制数和算法创建新的，如果算法也没有，使用默认的。\nrl_dec_count(name) 减少pipe name当前的计数\nrl_reset_count(name) 重置pipe name的当前计数\n实战 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 loadmodule \u0026#34;ratelimit.so\u0026#34; modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;timer_interval\u0026#34;, 5) modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;limit_per_interval\u0026#34;, 1) modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;expire_time\u0026#34;, 1800) modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;default_algorithm\u0026#34;, \u0026#34;TAILDROP\u0026#34;) route { ... if (is_method(\u0026#34;INVITE\u0026#34;)\u0026amp;\u0026amp;!rl_check(\u0026#34;gw_$si\u0026#34;, 3)) { sl_send_reply(503, \u0026#34;Server Unavailable\u0026#34;); xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;-----receive limit-----\\n\u0026#34;); exit; } ... } 为了测试出效果, pipe名字为: gw_$si, 以源ip来测试。\n测试 设置的是3个请求/5s, 当并发请求10个/5s,看到的信令图:\n可以看到,当达到第6个请求之后,第7个请求就被拒绝了, 之后当计数减少之后，后续还是能再次请求成功。\n测试过程中使用opensips-cli -x mi rl_list查看：\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;Pipes\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;gw_172.16.4.113\u0026#34;, \u0026#34;algorithm\u0026#34;: \u0026#34;TAILDROP\u0026#34;, \u0026#34;limit\u0026#34;: 3, \u0026#34;counter\u0026#34;: 7 } ], \u0026#34;drop_rate\u0026#34;: 82 } 请求拒绝的信令:\n总结 opensips的ratelimit功能比kamailio的ratelimit强大, opensips可以使用clusterer模块或者cacheDB实现集群的ratelimit, kamailio不可以。 ","date":"2025-06-24T17:01:58+08:00","image":"https://QuincyGao.github.io/p/opensips-ratelimit%E6%A8%A1%E5%9D%97/backup_hu11257748823583723252.jpg","permalink":"https://QuincyGao.github.io/p/opensips-ratelimit%E6%A8%A1%E5%9D%97/","title":"opensips ratelimit模块"},{"content":"背景 pike模块提供了简单的防DOS攻击功能，根据请求的ip对请求进行计数, 达到限制时, 只是上报信息，后续执行哪种动作，由用户决定。此功能和之前章节kamailio的pike模块功能一致。\n支持两种模式：\n手动模式, 调用pike_check_req 自动模式, 设置路由check_route 官方文档地址:pike\n本次测试的opensips版本:\nversion: opensips 3.5.5 (x86_64/linux)\n配置参数 1 2 3 4 5 6 7 8 # 采样的时间间隔, 单位秒,默认2 modparam(\u0026#34;pike\u0026#34;, \u0026#34;sampling_time_unit\u0026#34;, 10) # 每个采样时间内, 每个ip的最大请求数, 默认30 modparam(\u0026#34;pike\u0026#34;, \u0026#34;reqs_density_per_unit\u0026#34;, 30) # ip地址保存多长时间在内存中,默认: 120 modparam(\u0026#34;pike\u0026#34;, \u0026#34;remove_latency\u0026#34;, 130) # pike日志级别, 默认: 1(L_WARN) modparam(\u0026#34;pike\u0026#34;, \u0026#34;pike_log_level\u0026#34;, -1) 重要函数 pike_check_req() 检查当前请求的ip是否超过限制, 如果超过, 则返回false。\n返回值:\n1(true): `ip`没有被限制或者内部错误 -1(false): `ip`是洪水来源,正在检测 -2(false): `ip`是新的洪水来源，正在检测 实战 配置 手动模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 loadmodule \u0026#34;pike.so\u0026#34; modparam(\u0026#34;pike\u0026#34;, \u0026#34;sampling_time_unit\u0026#34;, 5) modparam(\u0026#34;pike\u0026#34;, \u0026#34;reqs_density_per_unit\u0026#34;, 3) modparam(\u0026#34;pike\u0026#34;, \u0026#34;remove_latency\u0026#34;, 130) modparam(\u0026#34;pike\u0026#34;, \u0026#34;pike_log_level\u0026#34;, -1) route { ... if (is_method(\u0026#34;INVITE\u0026#34;)\u0026amp;\u0026amp; !pike_check_req()) { append_to_reply(\u0026#34;Retry-After: 5\\r\\n\u0026#34;); sl_send_reply(503,\u0026#34;Limiting\u0026#34;); xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]----receive limited--\\n\u0026#34;); exit; } ... } 自动模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 loadmodule \u0026#34;pike.so\u0026#34; modparam(\u0026#34;pike\u0026#34;, \u0026#34;sampling_time_unit\u0026#34;, 5) modparam(\u0026#34;pike\u0026#34;, \u0026#34;reqs_density_per_unit\u0026#34;, 3) modparam(\u0026#34;pike\u0026#34;, \u0026#34;remove_latency\u0026#34;, 130) modparam(\u0026#34;pike\u0026#34;, \u0026#34;pike_log_level\u0026#34;, -1) modparam(\u0026#34;pike\u0026#34;, \u0026#34;check_route\u0026#34;, \u0026#34;pike\u0026#34;) route[pike] { if ($si == 172.16.4.114) { drop; } xlog(\u0026#34;L_DBG\u0026#34;, \u0026#34;receive packeage.\\n\u0026#34;); } 测试 手动模式 并发请求，得到的信令图为:\n可以看到如果5s内请求数超过3次，后续请求都会返回503。如果要解除锁定就要remove_latency时间过期. 503返回:\n自动模式 并发请求，得到的信令图为:\n达到限制时日志为:\n1 2 3 4 Jun 24 14:58:19 [540] DBG:receive packeage. Jun 24 14:58:19 [540] ERROR:PIKE - BLOCKing ip 172.16.4.113, node=0x7fae720338c8 Jun 24 14:58:19 [540] DBG:receive packeage. Jun 24 14:58:20 [535] DBG:receive packeage 达到限制之后的sip信令图为: 可以看到之后的请求没处理，这种方式不可控，而且会导致正常的会话未完成: 由于达到了限制，正常的一通对话的后面的信令就不再接收了.\n总结 手动模式比自动模式更可控，可自定义返回错误码. opensips的pike和kamailio的pike功能一样，但kamailio的pike没有自动模式。 ","date":"2025-06-24T10:38:45+08:00","image":"https://QuincyGao.github.io/p/opensips-pike%E6%A8%A1%E5%9D%97/backup_hu2480213898192745278.jpg","permalink":"https://QuincyGao.github.io/p/opensips-pike%E6%A8%A1%E5%9D%97/","title":"opensips pike模块"},{"content":"背景 ratelimit模块限制sip请求数,相对于上章介绍的pipelimit,多了队列功能,不需要数据库。\n算法支持:TAILDROP,RED,NETWORK, Dynamic Rate Limiting Algorithms, FEEDBACK\n本次测试的kamailio版本:\nversion: kamailio 5.8.5 (x86_64/linux)\n配置参数 1 2 3 4 5 6 7 # 时间间隔,单位秒,默认10 modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;timer_interval\u0026#34;, 5) # 格式为\u0026#34;pipe_no:method\u0026#34;,设置一个队列接受所有的方法,用*替换。 modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;queue\u0026#34;, \u0026#34;0:REGISTER\u0026#34;) modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;queue\u0026#34;, \u0026#34;1:*\u0026#34;) # 定义pipe_no的算法和限制大小, 示例: pipe 0 with a limit of 80 pkts/sec using TAILDROP modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;pipe\u0026#34;, \u0026#34;0:TAILDROP:80\u0026#34;) 重要函数 rl_check([pvar]) 检查当前请求匹配的ratelimit算法, 如果没有参数,使用METHOD匹配。 如果pvar提供了pipe number,按照pipe_no匹配。\n当达到限制时,会返回错误码，后续动作需要用户来决定。\nrl_check_pipe(pipe_no) 检查pipe_no的限制,如果没有设置,返回0.\n实战 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 loadmodule \u0026#34;ratelimit.so\u0026#34; modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;timer_interval\u0026#34;, 5) modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;queue\u0026#34;, \u0026#34;1:INVITE\u0026#34;) modparam(\u0026#34;ratelimit\u0026#34;, \u0026#34;pipe\u0026#34;, \u0026#34;1:TAILDROP:3\u0026#34;) request_route { ... if (is_method(\u0026#34;INVITE\u0026#34;)) { if (!rl_check()) { append_to_reply(\u0026#34;Retry-After: 5\\r\\n\u0026#34;); sl_send_reply(\u0026#34;503\u0026#34;,\u0026#34;Limiting\u0026#34;); xlog(\u0026#34;L_ALERT\u0026#34;,\u0026#34;received limit \\n\u0026#34;); exit; } } } 测试 使用sipp分别作为uac和uas, uac发送并发请求到kamailio, 可以看到输出的结果为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 9(5655) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 10(5656) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 16(5662) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 14(5660) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 11(5657) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 9(5655) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 14(5660) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 13(5659) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 16(5662) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 14(5660) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 16(5662) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 10(5656) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 15(5661) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 9(5655) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 10(5656) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 13(5659) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 13(5659) ALERT: \u0026lt;script\u0026gt;: received limit 9(5655) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 9(5655) ALERT: \u0026lt;script\u0026gt;: received limit 10(5656) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 10(5656) ALERT: \u0026lt;script\u0026gt;: received limit 因为配置了 3pkts/5s, 所以可以看到当请求到15个之后,第16个INVITE会触发限制， 此时由于配置了503错误，所以sip信令如下： 总结 MAX_PIPES和MAX_QUEUES分别为32 ratelimit和pipelimit功能类似，ratelimit不需要数据库，pipelimit需要数据库。 ratelimit可以配置多个队列，每个队列可以配置多个算法，pipelimit只能一个pipe name一个算法。 ","date":"2025-06-23T09:26:23+08:00","image":"https://QuincyGao.github.io/p/kamailio-ratelimit%E6%A8%A1%E5%9D%97/backup_hu9764373132981244873.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-ratelimit%E6%A8%A1%E5%9D%97/","title":"kamailio ratelimit模块"},{"content":"背景 pipelimit 用于限制sip请求, 定义了管道(pipe)概念,可用来表示来自用户的SIP请求流(INVITE or REGISTER)。\n脱胎于ratelimit, 可以在数据库中自定义pipe限制,专注于流量整形,没有队列功能。依赖数据库, 官方文档:pipelimit\n支持的算法有：\nTail Drop Algorithm(TAILDROP)\n这是一个简单的算法, 和定时器一起使用，但是和长时间间隔的定时器使用有风险。 当定时器开始之前，会清除计数。定时器开始后，每次请求计数增加，达到限制之后，pl_check()返回false\nRandom Early Detection Algorithm(RED)\n随机早期检测算法,这是默认算法. 通过测量平均负载并动态调整丢弃率来规避TAILDROP算法带来的同步问题。\n使用此算法时, kamailio会每第n个包向路由引擎返回错误, 试图把上一个时间间隔的负载均匀分布到当前时间间隔。 负面影响是:有可能会丢信息即便是未达到时间间隔. 出现这种现象请减少时间间隔。\nNetwork Algorithm(NETWORK)\n依赖网口提供的信息，每时间间隔内检测网口上等待消耗的字节数，如果数据超过限制,pl_check()返回false\nFeedback Algorithm(FEEDBACK)\n使用PID控制模式,根据cpu负载系数动态调整下降率, 以便负载系数保持在指定值附近。 由于读取cpu负载开销较大, 因此每隔定时时间才读一次，反馈值也会在这段时间间隔内重新计算。\n本次测试的kamailio版本:\nversion: kamailio 5.8.5 (x86_64/linux)\n参数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # hash_table大小, slots:2^hash_size, hash_size最大10,默认为6 modparam(\u0026#34;pipelimit\u0026#34;, \u0026#34;hash_size\u0026#34;, 10) # 数据库连接 modparam(\u0026#34;pipelimit\u0026#34;, \u0026#34;db_url\u0026#34;, \u0026#34;DBURL\u0026#34;) # pipe数据表名,默认:pl_pipes modparam(\u0026#34;pipelimit\u0026#34;, \u0026#34;plp_table_name\u0026#34;, \u0026#34;pl_pipes\u0026#34;) # 定时器时间,单位秒,默认10 modparam(\u0026#34;pipelimit\u0026#34;, \u0026#34;timer_interval\u0026#34;, 5) # 控制使用哪种定时器, 0:使用主程快速定时器, 1:使用辅助轮式定时器, 默认:0 modparam(\u0026#34;pipelimit\u0026#34;, \u0026#34;timer_mode\u0026#34;, 1) # 控制是否获取cpu和流量负载,0:不获取,1: 定时获取. 默认:1 modparam(\u0026#34;pipelimit\u0026#34;, \u0026#34;load_fetch\u0026#34;, 0) # 当达到限制时,返回错误值，默认: 503 modparam(\u0026#34;pipelimit\u0026#34;, \u0026#34;reply_code\u0026#34;, 505) # 错误原因,默认: Server Unavailable modparam(\u0026#34;pipelimit\u0026#34;, \u0026#34;reply_reason\u0026#34;, \u0026#34;Limiting\u0026#34;) # 到达多长时间间,是否清除未使用的pipes, 默认:0(不清理) modparam(\u0026#34;pipelimit\u0026#34;, \u0026#34;clean_unused\u0026#34;, 10) 重要函数 pl_check(name [, algorithm, limit]) 检查当前name的pipe请求,可以用在ANY_ROUTE,参数:\nname: pipe名称 algorithm: 算法名称, 可以为: TAILDROP,RED,NETWORK,FEEDBACK limit: 限制值,默认: 0(不限制) 返回值:\n-2: pipe没找到 -1: pipe达到限制 1: pipe有限制但是没达到 2: pipe有NOP算法 pl_active(name) 检查name的pipe是否创建了, 1: pipe被发现; -1: pipe没发现;可以用在ANY_ROUTE\npl_drop([ [min ], max ]) 对于当前的请求,达到限制后503- Server Unavailable已发送返回.\n如果没设置参数, 这个reply不带Retry-After头\n如果设置max, 那么带Retry-After:max\n如果设置了min和max, 那么带Retry-After:x, x为min和max之间的随机值.\n实战 pl_pipes数据表 pl_pipes的表结构为:\npipeid: pipe的唯一id algorithm: 算法可以为: NOP,RED, TAILDROP, FEEDBACK, NETWORK plimit: 每秒限制数 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 loadmodule \u0026#34;pipelimit.so\u0026#34; modparam(\u0026#34;pipelimit\u0026#34;, \u0026#34;hash_size\u0026#34;, 10) modparam(\u0026#34;pipelimit\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;pipelimit\u0026#34;, \u0026#34;timer_interval\u0026#34;, 5) modparam(\u0026#34;pipelimit\u0026#34;, \u0026#34;timer_mode\u0026#34;, 0) modparam(\u0026#34;pipelimit\u0026#34;, \u0026#34;reply_code\u0026#34;, 505) modparam(\u0026#34;pipelimit\u0026#34;, \u0026#34;reply_reason\u0026#34;, \u0026#34;Limiting\u0026#34;) request_route { ... if (is_method(\u0026#34;INVITE\u0026#34;)) { $var(check_result) = pl_check(\u0026#34;one\u0026#34;); switch($var(check_result)) { case -2: xlog(\u0026#34;L_ALERT\u0026#34;,\u0026#34;pl_check(\\\u0026#34;$var(p)\\\u0026#34;) drop -pipe NOT found\\n\u0026#34;); pl_drop(); exit; break; case -1: xlog(\u0026#34;L_ALERT\u0026#34;,\u0026#34;pl_check(\\\u0026#34;$var(p)\\\u0026#34;) drop\\n\u0026#34;); pl_drop(\u0026#34;5\u0026#34;); exit; break; case 1: xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;pl_check(\\\u0026#34;$var(p)\\\u0026#34;) pass\\n\u0026#34;); break; case 2: xlog(\u0026#34;L_ALERT\u0026#34;,\u0026#34;pl_check(\\\u0026#34;$var(p)\\\u0026#34;) pass -NOP algorithm\\n\u0026#34;); break; default: xlog(\u0026#34;L_ERR\u0026#34;,\u0026#34;pl_check(\\\u0026#34;$var(p)\\\u0026#34;) dropping with unexpected retcode=$var(check_result)\\n\u0026#34;); pl_drop(); exit; } } ... } 数据表pl_pipes新增数据: insert into pl_pipes(pipeid, algorithm, plimit) values('one', 'TAILDROP', 2);\npipeid即是pl_check的参数name\n测试 使用sipp分别做uac和uas, 并发请求，得到的日志为:\n1 2 3 4 5 6 7 8 9(5257) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 9(5257) INFO: \u0026lt;script\u0026gt;: pl_check(\u0026#34;0\u0026#34;) pass 10(5258) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 10(5258) INFO: \u0026lt;script\u0026gt;: pl_check(\u0026#34;0\u0026#34;) pass 14(5262) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 14(5262) ALERT: \u0026lt;script\u0026gt;: pl_check(\u0026#34;0\u0026#34;) drop 9(5257) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 9(5257) ALERT: \u0026lt;script\u0026gt;: pl_check(\u0026#34;0\u0026#34;) drop 我们配的是2个请求限制/5s,当请求大于2时, 可以看到日志有报错，并且剩下的请求返回505\n因为我们配了pl_drop(\u0026quot;5\u0026quot;),所以头带了Retry-After:5\n总结 此pipelimit模块和上章介绍的pike功能大体相似，都能限制请求并发数， 但是pipelimit的功能相对较丰富。\npipelimit可设置算法,限制的pipe,可自定义返回的错误码和错误原因。\npike只能通过ip来限制,也没有算法选择，限制之后的返回需要用户自己设置。\n","date":"2025-06-20T08:50:52+08:00","image":"https://QuincyGao.github.io/p/kamailio-pipelimit%E6%A8%A1%E5%9D%97/backup_hu15873456346852548614.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-pipelimit%E6%A8%A1%E5%9D%97/","title":"kamailio pipelimit模块"},{"content":"背景 pike模块可以跟踪sip请求的ip源, 如果达到限制, 会产生日志表示达到了最高限制,后续的动作由用户来决定。 官方文档地址: pike\n本次测试的kamailio版本:\nversion: kamailio 5.8.5 (x86_64/linux)\n参数解析 1 2 3 4 5 6 7 8 # 用于采样的时间段,值越小越好,但是会慢。默认2 modparam(\u0026#34;pike\u0026#34;, \u0026#34;sampling_time_unit\u0026#34;, 10) # 在sampling_time_unit时间内,允许多少个请求,ipv4为x到3*x, ipv6为x到8*x. 默认30 modparam(\u0026#34;pike\u0026#34;, \u0026#34;reqs_density_per_unit\u0026#34;, 30) # 设置上次请求的ip保留多长时间在内存中,默认120s modparam(\u0026#34;pike\u0026#34;, \u0026#34;remove_latency\u0026#34;, 130) # pike模块的日志等级,默认1(L_WARN) modparam(\u0026#34;pike\u0026#34;, \u0026#34;pike_log_level\u0026#34;, -1) 重要函数 pike_check_req() 检查请求是否被限制。返回值:\n1: ip没有限制或者内部错误 -1: ip是洪水源, 被检测到 -2: ip是新的洪水源被首次检测到. pike_check_ip(ipaddr) 检查ip是否被限制,如果ip被限制,返回false, 返回参数和pike_check_req()一致。\n实战 配置新增 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 loadmodule \u0026#34;pike.so\u0026#34; modparam(\u0026#34;pike\u0026#34;, \u0026#34;sampling_time_unit\u0026#34;, 2) modparam(\u0026#34;pike\u0026#34;, \u0026#34;reqs_density_per_unit\u0026#34;, 6) modparam(\u0026#34;pike\u0026#34;, \u0026#34;pike_log_level\u0026#34;, -1) request_route { xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;------$si:$sp|$Ri:$Rp|$pr|$rm\\n\u0026#34;); if (!has_totag() \u0026amp;\u0026amp; !pike_check_req()) { xlog(\u0026#34;L_ERROR\u0026#34;, \u0026#34;----$si receive limit\\n\u0026#34;); sl_send_reply(\u0026#34;500\u0026#34;, \u0026#34;request limit\u0026#34;); exit; } ... } 设置2s内, 相同ip6个请求, 测试是否能触发限制.\n测试方式 使用sipp分别作为uac和uas, uac发送并发请求到kamailio, 然后kamailio转发请求到uas.\nuac的参数: -l 10 -m 10\n实际看到的日志:\n1 2 3 4 5 6 7 8 9 10 11 12 13 11(3977) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 9(3975) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 15(3981) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 11(3977) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 10(3976) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 16(3982) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 9(3975) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 14(3980) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 13(3979) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 12(3978) INFO: \u0026lt;script\u0026gt;: ------172.16.4.113:5666|172.16.4.111:5461|udp|INVITE 12(3978) ERROR: pike [pike_funcs.c:135]: pike_check_ipaddr(): PIKE - BLOCKing ip 172.16.4.113, node=0x7f9f01214b30 12(3978) ERROR: \u0026lt;script\u0026gt;: ----172.16.4.113 receive limit 33(3999) ERROR: pike [pike_funcs.c:313]: refresh_node(): PIKE - UNBLOCKing node 0x7f9f01214b30 因为pike_check_req,只是用来检测ip是否被限制, 如果想要拦截请求，可以使用sl_send_reply(\u0026quot;\u0026quot;, \u0026quot;\u0026quot;);自定义返回错误。\n使用kamcmd pike.top,看到的数据为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 { max_hits: 6 list: { { ip_addr: 172.16.4.113 leaf_hits_prev: 9 leaf_hits_curr: 0 expires: 118 status: HOT } } number_of_rows: 1 } ","date":"2025-06-17T11:16:44+08:00","image":"https://QuincyGao.github.io/p/kamailio-pike%E6%A8%A1%E5%9D%97/backup_hu4548993909214251502.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-pike%E6%A8%A1%E5%9D%97/","title":"kamailio pike模块"},{"content":"背景 在上一章中，我们介绍了dtmf按键功能，可以看到rtpengine能够把收到的rfc2833和inbound类型的dtmf透传到uas。\n在实际项目中, 我们可能还需要对dtmf做按键类型转换, 在rtpengine的官方文档transcoding中，我们找到这样一段话：\nRtpengine supports transcoding between RFC 2833/4733 DTMF event packets (telephone-event payloads) and in-band DTMF audio tones. When enabled, rtpengine translates DTMF event packets to in-band DTMF audio by generating DTMF tones and injecting them into the audio stream, and translates in-band DTMF tones by running the audio stream through a DSP, and generating DTMF event packets when a DTMF tone is detected.\n所以可以得知rfc2833/4733和inbound类型可以互相转换。\n本次测试的rtpengine版本:\nVersion: 13.1.0.0+0~mr13.1.0.0 git-heads/mr13.0.1.2-3ac08574\nrfc2833 转inbound 在opensips在转发invite时,rtpengine_manager里,参数设置如下: always-transcode codec-mask-all codec-transcode-telephone-event codec-strip-telephone-event\n通过抓包得到的结果如下: opensips转发给uas的RTP按键内容为: 所以可以确定rfc2833转inbound成功。\n另外uac发送的invite的SDP信息为: opensips转发给uas的invite的sdp信息： 可能有点问题的是： 这个转发的invite居然把media相关的信息都去掉了。\n20250623 修正 opensips转发invite时,rtpengine_manager参数设置为:\nalways-transcode codec-strip-telephone-event DTLS=off SDES-off ICE=remove RTP/AVP\n从uac发送过来的invitesip信令图为: opensips转发给uas的invite信令图为: 可以看到转发的invite只是去掉了telephone-event\nopensips收到183ring或者200OK时的rtpengine_manager参数为:\nDTLS=off SDES-off ICE=remove RTP/AVP\n从uas返回的183ring或者200OK的sip信令图为: 从opensips返回给软电话的183ring或者200OK的sip信令图为: 可以看到返回的183ring或者200OK的sip信令,新增了telephone-event\n整体信令图： 可以看到rfc2833被转成了inbound, 这种方式比方案1更好。\ninbound 转rfc2833 目前没有成功,我用了always-transcode detect-DTMF codec-transcode-telephone-event codec-strip=telephone-event 和always-transcode inject-DTMF codec-transcode-telephone-event codec-strip=telephone-event,都没转成功。\n在rtpengine的group发的帖子,一直自动删除. 后面如果有成功的,会在这里补充。\nINFO 转 rfc2833 按键INFO的sip信令如下: 可以看到按键的INFO的sip头里的content-type为application/dtmf-relay, BODY里的Signal即为按键内容。\n在opensips的配置中，设置如下:\n1 2 3 4 5 6 7 8 9 10 11 if(is_method(\u0026#34;INFO\u0026#34;) \u0026amp;\u0026amp; ($cT == \u0026#34;application/dtmf-relay\u0026#34;)){ $var(info-body) = $rb; $var(signal) = $(var(info-body){s.substr,0,8}); if ($var(signal) != \u0026#34;\u0026#34;) { $var(signalNumber) = $(var(signal){s.substr,7,1}); xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---info--:$rm|$rs|$tu|---receive dtmf:$rb,signal:$var(signal),number:$var(signalNumber)\\n\u0026#34;); rtpengine_play_dtmf($var(signalNumber)); sl_send_reply(200, \u0026#34;OK\u0026#34;); exit; } } 能接收的按键为:(0-9)和(*,#,A,B,C,D)。\n另外还要在转发的invite,生成SDP信息时，rtpengine_manager的参数添加如下:\nalways-transcode inject-DTMF codec-mask-all\n实际抓包的sip信令如下: 确实可以看到INFO转成了rfc2833类型的按键。\nuac发送的invite的SDP信息为: opensips转发给uas的invite的sdp信息： INFO 转 inbound 暂未成功。\n总结 rtpengine的按键转换功能, 目前验证成功是rfc2833转inbound和INFO转rfc2833。inbound转rfc2833和INFO转inbound暂未成功。 rfc2833或者inbound应该不能转成INFO类型。 ","date":"2025-06-10T16:24:48+08:00","image":"https://QuincyGao.github.io/p/rtpengine-%E6%8C%89%E9%94%AE%E8%BD%AC%E6%8D%A2/backup_hu8177833563666898818.jpg","permalink":"https://QuincyGao.github.io/p/rtpengine-%E6%8C%89%E9%94%AE%E8%BD%AC%E6%8D%A2/","title":"rtpengine 按键转换"},{"content":"背景 项目上使用的是opensips(3.3.10)+rtpengine(13.1.0.0+0~mr13.1.0.0 git-heads/mr13.0.1.2-3ac08574)用做注册代理。\n软电话通过opensips注册到uas, 按键进行ivr流程。\n问题现象 软电话通过opensips的外网ip进行注册, 按键进行ivr流程, 按键无效,但是说话能识别。\nuas没有日志,所以不能通过日志分析问题。\n排查分析 通过抓包发现按键信息确实发送给了uas, uas也收到了按键消息,但是uas没有响应。 切换到内网测试opensips,把opensips转到同一个uas上, 按键有效！！！\n通过对比纯内网和带外网的opensips的服务器上抓包，发现问题出在opensips转发invite信令。 sdp信息中的ip是外网ip, opensips和uas是纯内网交互，这个的ip要是内网ip。 解决方法 在opensips.cfg的t_on_branch(\u0026quot;per_branch_ops\u0026quot;)请求rtpengine获取sdp信息时,传递media-address=内网ip。 强制生成的sdp信息中的ip是内网ip。 1 rtpengine_manage(\u0026#34; media-address=172.16.7.239 \u0026#34;); 修改之后，验证成功,按键有效。 疑问: sip服务器为何因为sdp信息中的ip是外网ip而没有响应按键不得而知(第三方的,没人能解答)。\n延伸 按键dtmf 类型 按键主要有三种类型，在抓包中的表现形式为:\nrfc2833 通过wireshark抓包的sip信令上，可以看到rfc2833和语音RTP流是分开的，能够很直观的区分.\n点击此信令,能够看到的详细信息: inbound inboud 按键和语音RTP流是一起的, 无法区分。\n通过播放该rtp流, 可以听到按键声音,也可以看到按键的波形。\nINFO INFO是指按键信息以SIP INFO的方式发送,直接抓sip信令就能看到。 按键信息: 在INFO的body中，可以看到按键信息。\nopensips 内外网ip的问题 使用opensips做网关时, 比较重要的就是内外网ip的转换问题。 这里包括两个部分:\nsip信令中的Record-Route, 使用 record_route_preset不要用record_route sdp信息中的c, 使用media-address设置。 以下列的sip信令为例: 需要修改的地方:\n在转发INVITE给uas时,Record-Route要改成内网ip, sdp的c改成内网ip。 收到uas的183或者200 OK信令时, 转发给uac时Record-Route要改成外网ip, sdp的c改成外网ip。 ","date":"2025-06-09T11:05:03+08:00","image":"https://QuincyGao.github.io/p/opensips-dtmf-%E6%8C%89%E9%94%AE%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/backup_hu16515711277534375845.jpg","permalink":"https://QuincyGao.github.io/p/opensips-dtmf-%E6%8C%89%E9%94%AE%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/","title":"opensips dtmf 按键失效问题"},{"content":"背景 最近使用unimrcp对接了好几家厂商的asr和tts。\n虽然unimrcp内部有umc和unimrcpclient客户端来测试，但是asr测试是要读音频文件，测试不太方便。所以就想到了使用freeswitch的mrcp模块对接unimrcp,使用软电话直接语音测试。 参考文档:play_and_detect_speech\n本次测试的freeswitch版本是:\nversion: FreeSWITCH Version 1.10.2-release+git20230615T110520Z4ce1b74880~64bit\nfreeswitch 配置修改 编译mrcp模块 编译文件:build/modules.conf.in, 放开asr_tts/mod_unimrcp, 编译mod_unimrcp库。\n打包生成freeswitch容器。\n配置mrcp 新建test-mrcp.xml 路径: conf/mrcp_profiles/, 里面有一些示例, 可以参考nuance-5.0-mrcp-v2.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;include\u0026gt; \u0026lt;profile name=\u0026#34;test-mrcp\u0026#34; version=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;!--param name=\u0026#34;client-ext-ip\u0026#34; value=\u0026#34;auto\u0026#34;--\u0026gt; \u0026lt;param name=\u0026#34;client-ip\u0026#34; value=\u0026#34;auto\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;client-port\u0026#34; value=\u0026#34;5090\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;server-ip\u0026#34; value=\u0026#34;172.16.7.206\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;server-port\u0026#34; value=\u0026#34;8060\u0026#34;/\u0026gt; \u0026lt;!--param name=\u0026#34;force-destination\u0026#34; value=\u0026#34;1\u0026#34;/--\u0026gt; \u0026lt;param name=\u0026#34;sip-transport\u0026#34; value=\u0026#34;udp\u0026#34;/\u0026gt; \u0026lt;!--param name=\u0026#34;ua-name\u0026#34; value=\u0026#34;FreeSWITCH\u0026#34;/--\u0026gt; \u0026lt;!--param name=\u0026#34;sdp-origin\u0026#34; value=\u0026#34;FreeSWITCH\u0026#34;/--\u0026gt; \u0026lt;!--param name=\u0026#34;rtp-ext-ip\u0026#34; value=\u0026#34;auto\u0026#34;/--\u0026gt; \u0026lt;param name=\u0026#34;rtp-ip\u0026#34; value=\u0026#34;auto\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;rtp-port-min\u0026#34; value=\u0026#34;4000\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;rtp-port-max\u0026#34; value=\u0026#34;5000\u0026#34;/\u0026gt; \u0026lt;!-- enable/disable rtcp support --\u0026gt; \u0026lt;param name=\u0026#34;rtcp\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;!-- rtcp bye policies (rtcp must be enabled first) 0 - disable rtcp bye 1 - send rtcp bye at the end of session 2 - send rtcp bye also at the end of each talkspurt (input) --\u0026gt; \u0026lt;param name=\u0026#34;rtcp-bye\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;!-- rtcp transmission interval in msec (set 0 to disable) --\u0026gt; \u0026lt;param name=\u0026#34;rtcp-tx-interval\u0026#34; value=\u0026#34;5000\u0026#34;/\u0026gt; \u0026lt;!-- period (timeout) to check for new rtcp messages in msec (set 0 to disable) --\u0026gt; \u0026lt;param name=\u0026#34;rtcp-rx-resolution\u0026#34; value=\u0026#34;1000\u0026#34;/\u0026gt; \u0026lt;!--param name=\u0026#34;playout-delay\u0026#34; value=\u0026#34;50\u0026#34;/--\u0026gt; \u0026lt;!--param name=\u0026#34;max-playout-delay\u0026#34; value=\u0026#34;200\u0026#34;/--\u0026gt; \u0026lt;!--param name=\u0026#34;ptime\u0026#34; value=\u0026#34;20\u0026#34;/--\u0026gt; \u0026lt;param name=\u0026#34;codecs\u0026#34; value=\u0026#34;PCMU PCMA L16/96/8000\u0026#34;/\u0026gt; \u0026lt;!-- Add any default MRCP params for SPEAK requests here --\u0026gt; \u0026lt;synthparams\u0026gt; \u0026lt;/synthparams\u0026gt; \u0026lt;!-- Add any default MRCP params for RECOGNIZE requests here --\u0026gt; \u0026lt;recogparams\u0026gt; \u0026lt;!--param name=\u0026#34;start-input-timers\u0026#34; value=\u0026#34;false\u0026#34;/--\u0026gt; \u0026lt;/recogparams\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/include\u0026gt; 这个配置里需要注意的是:\nprofile name=, 这个是后续选择mrcp时的名称。 server-ip=和server-port分别填unimrcp的ip和port,port默认是8060. 修改unimrcp.conf.xml 路径: conf/autoload_configs/unimrcp.conf.xml,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;configuration name=\u0026#34;unimrcp.conf\u0026#34; description=\u0026#34;UniMRCP Client\u0026#34;\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!-- UniMRCP profile to use for TTS --\u0026gt; \u0026lt;param name=\u0026#34;default-tts-profile\u0026#34; value=\u0026#34;test-mrcp\u0026#34;/\u0026gt; \u0026lt;!-- UniMRCP profile to use for ASR --\u0026gt; \u0026lt;param name=\u0026#34;default-asr-profile\u0026#34; value=\u0026#34;test-mrcp\u0026#34;/\u0026gt; \u0026lt;!-- UniMRCP logging level to appear in freeswitch.log. Options are: EMERGENCY|ALERT|CRITICAL|ERROR|WARNING|NOTICE|INFO|DEBUG --\u0026gt; \u0026lt;param name=\u0026#34;log-level\u0026#34; value=\u0026#34;DEBUG\u0026#34;/\u0026gt; \u0026lt;!-- Enable events for profile creation, open, and close --\u0026gt; \u0026lt;param name=\u0026#34;enable-profile-events\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;max-connection-count\u0026#34; value=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;offer-new-connection\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;request-timeout\u0026#34; value=\u0026#34;3000\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;X-PRE-PROCESS cmd=\u0026#34;include\u0026#34; data=\u0026#34;../mrcp_profiles/*.xml\u0026#34;/\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;/configuration\u0026gt; default-tts-profile和default-asr-profile分别填test-mrcp,其他的配置走默认即可。\n配置拨号策略 路径: conf/dialplans/default.xml, 配置如下:\n1 2 3 4 5 6 7 8 \u0026lt;extension name=\u0026#34;play_and_detect_speech example\u0026#34;\u0026gt; \u0026lt;condition field=\u0026#34;destination_number\u0026#34; expression=\u0026#34;^5004$\u0026#34;\u0026gt; \u0026lt;action application=\u0026#34;set\u0026#34; data=\u0026#34;tts_engine=unimrcp\u0026#34;/\u0026gt; \u0026lt;action application=\u0026#34;set\u0026#34; data=\u0026#34;tts_voice=donna\u0026#34;/\u0026gt; \u0026lt;action application=\u0026#34;play_and_detect_speech\u0026#34; data=\u0026#34;say:please say yes or no.please say something! detect:unimrcp {start-input-timers=false,no-input-timeout=5000,recognition-timeout=5000}builtin:grammar/boolean?language=en-US;y=1;n=2\u0026#34;/\u0026gt; \u0026lt;action application=\u0026#34;log\u0026#34; data=\u0026#34;CRIT ${detect_speech_result}\u0026#34;/\u0026gt; \u0026lt;/condition\u0026gt; \u0026lt;/extension\u0026gt; 该配置是freeswitch的play_and_detect_speech模块的示例。\n测试 使用软电话拨打5004,如果你的tts支持英语, 会听到please say yes or no.please say something!。用户说话也能识别出来.\nasr的相关日志:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 EXECUTE [depth=0] sofia/internal/1007@172.16.4.111 play_and_detect_speech(say:please say yes or no.please say something! detect:unimrcp {start-input-timers=false,no-input-timeout=5000,recognition-timeout=5000}builtin:grammar/boolean?language=en-US;y=1;n=2) 2025-05-29 15:13:50.315891 [INFO] mod_unimrcp.c:3134 asr_handle: name = unimrcp, codec = (null), rate = 8000, grammar = (null), param = (null) 2025-05-29 15:13:50.315891 [INFO] mod_unimrcp.c:3136 codec = L16, rate = 8000, dest = (null) 2025-05-29 15:13:50.315891 [DEBUG] mod_unimrcp.c:690 (ASR-1) audio queue created 2025-05-29 15:13:50.315891 [NOTICE] mrcp_application.c:96 (ASR-1) Create MRCP Handle 0x7f1d68012e30 [test-mrcp] 2025-05-29 15:13:50.315891 [INFO] mrcp_client_session.c:133 (ASR-1) Create Channel ASR-1 \u0026lt;new\u0026gt; 2025-05-29 15:13:50.315891 [DEBUG] apt_task.c:265 () Signal Message to [MRCP Client] [0x7f1d68008d50;4;0] 2025-05-29 15:13:50.315891 [DEBUG] apt_task.c:337 () Process Message [MRCP Client] [0x7f1d68008d50;4;0] 2025-05-29 15:13:50.315891 [INFO] mrcp_client_session.c:387 (ASR-1) Receive App Request ASR-1 \u0026lt;new\u0026gt; [2] 2025-05-29 15:13:50.315891 [INFO] mrcp_client.c:700 (ASR-1) Add MRCP Handle ASR-1 \u0026lt;new\u0026gt; 2025-05-29 15:13:50.315891 [DEBUG] mrcp_client_session.c:1283 (ASR-1) Dispatch App Request ASR-1 \u0026lt;new\u0026gt; [2] 2025-05-29 15:13:50.315891 [DEBUG] apt_task.c:265 () Signal Message to [MRCPv2ConnectionAgent] [0x7f1dc4005000;1;0] 2025-05-29 15:13:50.315891 [NOTICE] mrcp_client_session.c:719 (ASR-1) Add Control Channel ASR-1 \u0026lt;new@speechrecog\u0026gt; 2025-05-29 15:13:50.315891 [DEBUG] mrcp_client_session.c:745 (ASR-1) Add Media Termination ASR-1 \u0026lt;new@media-tm\u0026gt; 2025-05-29 15:13:50.315891 [DEBUG] mrcp_client_session.c:777 (ASR-1) Add Media Termination ASR-1 \u0026lt;new@rtp-tm\u0026gt; 2025-05-29 15:13:50.315891 [DEBUG] apt_task.c:265 () Signal Message to [MediaEngine] [0x7f1dc4019c40;1;0] 2025-05-29 15:13:50.315891 [DEBUG] apt_consumer_task.c:141 () Wait for Messages [MRCP Client] 2025-05-29 15:13:50.315891 [DEBUG] apt_poller_task.c:261 () Process Poller Wakeup [MRCPv2ConnectionAgent] 2025-05-29 15:13:50.315891 [DEBUG] apt_task.c:337 () Process Message [MRCPv2ConnectionAgent] [0x7f1dc4005000;1;0] 2025-05-29 15:13:50.315891 [DEBUG] apt_task.c:265 () Signal Message to [MRCP Client] [0x7f1dc0000be0;2;0] 2025-05-29 15:13:50.315891 [DEBUG] apt_poller_task.c:251 () Wait for Messages [MRCPv2ConnectionAgent] 2025-05-29 15:13:50.315891 [DEBUG] apt_task.c:337 () Process Message [MRCP Client] [0x7f1dc0000be0;2;0] 2025-05-29 15:13:50.315891 [DEBUG] mrcp_client_session.c:294 (ASR-1) Control Channel Added ASR-1 \u0026lt;new@speechrecog\u0026gt; 2025-05-29 15:13:50.315891 [DEBUG] apt_consumer_task.c:141 () Wait for Messages [MRCP Client] 2025-05-29 15:13:50.315891 [DEBUG] apt_task.c:337 () Process Message [MediaEngine] [0x7f1dc4019c40;1;0] 2025-05-29 15:13:50.315891 [DEBUG] mpf_context.c:182 () Add Media Context ASR-1 2025-05-29 15:13:50.315891 [DEBUG] apt_task.c:265 () Signal Message to [MRCP Client] [0x7f1d60000b60;3;0] 2025-05-29 15:13:50.315891 [DEBUG] apt_task.c:337 () Process Message [MRCP Client] [0x7f1d60000b60;3;0] 2025-05-29 15:13:50.315891 [DEBUG] mrcp_client_session.c:944 (ASR-1) Media Termination Added ASR-1 \u0026lt;new@media-tm\u0026gt; 2025-05-29 15:13:50.315891 [DEBUG] mrcp_client_session.c:944 (ASR-1) Media Termination Added ASR-1 \u0026lt;new@rtp-tm\u0026gt; 2025-05-29 15:13:50.315891 [INFO] mrcp_client_session.c:411 (ASR-1) Send Offer ASR-1 \u0026lt;new\u0026gt; [c:1 a:1 v:0] to 172.16.7.206:8060 2025-05-29 15:13:50.315891 [INFO] mrcp_sofiasip_client_agent.c:354 (ASR-1) Local SDP ASR-1 \u0026lt;new\u0026gt; v=0 o=FreeSWITCH 0 0 IN IP4 172.16.4.111 s=- c=IN IP4 172.16.4.111 t=0 0 m=application 9 TCP/MRCPv2 1 a=setup:active a=connection:new a=resource:speechrecog a=cmid:1 m=audio 4000 RTP/AVP 0 8 96 a=rtpmap:0 PCMU/8000 a=rtpmap:8 PCMA/8000 a=rtpmap:96 L16/8000 a=sendonly a=mid:1 2025-05-29 15:13:50.315891 [DEBUG] apt_consumer_task.c:141 () Wait for Messages [MRCP Client] 2025-05-29 15:13:50.315891 [INFO] mrcp_sofiasip_client_agent.c:609 () Receive SIP Event [nua_i_state] Status 0 INVITE sent [test-mrcp] 2025-05-29 15:13:50.315891 [NOTICE] mrcp_sofiasip_client_agent.c:547 (ASR-1) SIP Call State ASR-1 [calling] 2025-05-29 15:13:50.335890 [INFO] mrcp_sofiasip_client_agent.c:609 () Receive SIP Event [nua_r_invite] Status 200 OK [test-mrcp] 2025-05-29 15:13:50.335890 [INFO] mrcp_sofiasip_client_agent.c:609 () Receive SIP Event [nua_i_state] Status 200 OK [test-mrcp] 2025-05-29 15:13:50.335890 [NOTICE] mrcp_sofiasip_client_agent.c:547 (ASR-1) SIP Call State ASR-1 [ready] 2025-05-29 15:13:50.335890 [INFO] mrcp_sofiasip_client_agent.c:433 (ASR-1) Remote SDP ASR-1 \u0026lt;new\u0026gt; v=0 o=UniMRCPServer 5306294943051381812 5608901609573390734 IN IP4 172.16.7.206 s=- c=IN IP4 172.16.7.206 t=0 0 m=application 1544 TCP/MRCPv2 1 a=setup:passive a=connection:new a=channel:8fe20c9c3c5c11f0@speechrecog a=cmid:1 m=audio 5074 RTP/AVP 0 a=rtpmap:0 PCMU/8000 a=recvonly a=mid:1 2025-05-29 15:13:50.335890 [DEBUG] apt_task.c:265 () Signal Message to [MRCP Client] [0x7f1d980015a0;1;0] 2025-05-29 15:13:50.335890 [INFO] mrcp_sofiasip_client_agent.c:609 () Receive SIP Event [nua_i_active] Status 200 Call active [test-mrcp] 2025-05-29 15:13:50.335890 [DEBUG] apt_task.c:337 () Process Message [MRCP Client] [0x7f1d980015a0;1;0] 2025-05-29 15:13:50.335890 [INFO] mrcp_client_session.c:151 (ASR-1) Receive Answer ASR-1 \u0026lt;new\u0026gt; [c:1 a:1 v:0] Status 200 2025-05-29 15:13:50.335890 [DEBUG] mrcp_client_session.c:1141 (ASR-1) Modify Control Channel ASR-1 \u0026lt;8fe20c9c3c5c11f0\u0026gt; 2025-05-29 15:13:50.335890 [DEBUG] apt_task.c:265 () Signal Message to [MRCPv2ConnectionAgent] [0x7f1dc4005000;1;0] 2025-05-29 15:13:50.335890 [DEBUG] mrcp_client_session.c:1180 (ASR-1) Modify Media Termination ASR-1 \u0026lt;8fe20c9c3c5c11f0@rtp-tm\u0026gt; 2025-05-29 15:13:50.335890 [DEBUG] apt_task.c:265 () Signal Message to [MediaEngine] [0x7f1dc40198c0;1;0] 2025-05-29 15:13:50.335890 [DEBUG] apt_consumer_task.c:141 () Wait for Messages [MRCP Client] 2025-05-29 15:13:50.335890 [DEBUG] apt_poller_task.c:261 () Process Poller Wakeup [MRCPv2ConnectionAgent] 2025-05-29 15:13:50.335890 [DEBUG] apt_task.c:337 () Process Message [MRCPv2ConnectionAgent] [0x7f1dc4005000;1;0] 2025-05-29 15:13:50.335890 [NOTICE] mrcp_client_connection.c:338 () Established TCP/MRCPv2 Connection 172.16.4.111:63555 \u0026lt;-\u0026gt; 172.16.7.206:1544 2025-05-29 15:13:50.335890 [INFO] mrcp_client_connection.c:435 (ASR-1) Add Control Channel \u0026lt;8fe20c9c3c5c11f0@speechrecog\u0026gt; 172.16.4.111:63555 \u0026lt;-\u0026gt; 172.16.7.206:1544 [1] 2025-05-29 15:13:50.335890 [DEBUG] apt_task.c:265 () Signal Message to [MRCP Client] [0x7f1dc0000b80;2;1] 2025-05-29 15:13:50.335890 [DEBUG] apt_poller_task.c:251 () Wait for Messages [MRCPv2ConnectionAgent] 2025-05-29 15:13:50.335890 [DEBUG] apt_task.c:337 () Process Message [MRCP Client] [0x7f1dc0000b80;2;1] 2025-05-29 15:13:50.335890 [DEBUG] mrcp_client_session.c:311 (ASR-1) Control Channel Modified ASR-1 \u0026lt;8fe20c9c3c5c11f0@speechrecog\u0026gt; 2025-05-29 15:13:50.335890 [DEBUG] apt_consumer_task.c:141 () Wait for Messages [MRCP Client] 2025-05-29 15:13:50.335890 [DEBUG] apt_task.c:337 () Process Message [MediaEngine] [0x7f1dc40198c0;1;0] 2025-05-29 15:13:50.335890 [INFO] mpf_rtp_stream.c:331 () Enable RTP Session 172.16.4.111:4000 2025-05-29 15:13:50.335890 [DEBUG] mpf_bridge.c:129 () Create Linear Audio Bridge ASR-1 2025-05-29 15:13:50.335890 [INFO] mpf_rtp_stream.c:921 () Open RTP Transmitter 172.16.4.111:4000 -\u0026gt; 172.16.7.206:5074 2025-05-29 15:13:50.335890 [INFO] mpf_bridge.c:93 () Media Path ASR-1 Source-\u0026gt;[LPCM/8000/1]-\u0026gt;Bridge-\u0026gt;[LPCM/8000/1]-\u0026gt;Encoder-\u0026gt;[PCMU/8000/1]-\u0026gt;Sink 2025-05-29 15:13:50.335890 [DEBUG] apt_task.c:265 () Signal Message to [MRCP Client] [0x7f1d60000ad0;3;0] 2025-05-29 15:13:50.335890 [DEBUG] apt_task.c:337 () Process Message [MRCP Client] [0x7f1d60000ad0;3;0] 2025-05-29 15:13:50.335890 [DEBUG] mrcp_client_session.c:985 (ASR-1) Media Termination Modified ASR-1 \u0026lt;8fe20c9c3c5c11f0@rtp-tm\u0026gt; 2025-05-29 15:13:50.335890 [INFO] mrcp_client_session.c:455 (ASR-1) Raise App Response ASR-1 \u0026lt;8fe20c9c3c5c11f0\u0026gt; [2] SUCCESS [0] 2025-05-29 15:13:50.335890 [DEBUG] mod_unimrcp.c:1900 (ASR-1) RECOGNIZER channel is ready, codec = LPCM, sample rate = 8000 2025-05-29 15:13:50.335890 [DEBUG] mod_unimrcp.c:1584 (ASR-1) CLOSED ==\u0026gt; READY 2025-05-29 15:13:50.335890 [DEBUG] apt_consumer_task.c:141 () Wait for Messages [MRCP Client] 2025-05-29 15:13:50.335890 [DEBUG] mod_unimrcp.c:1062 (ASR-1) channel is ready 2025-05-29 15:13:50.335890 [DEBUG] sofia.c:7301 Channel sofia/internal/1007@172.16.4.111 entering state [early][183] 2025-05-29 15:13:50.335890 [DEBUG] switch_core_media_bug.c:970 Attaching BUG to sofia/internal/1007@172.16.4.111 2025-05-29 15:13:50.335890 [DEBUG] mod_unimrcp.c:1465 (ASR-1) param = start-input-timers, val = false 2025-05-29 15:13:50.335890 [DEBUG] mod_unimrcp.c:1465 (ASR-1) param = no-input-timeout, val = 5000 2025-05-29 15:13:50.335890 [DEBUG] mod_unimrcp.c:1465 (ASR-1) param = recognition-timeout, val = 5000 2025-05-29 15:13:50.335890 [DEBUG] mod_unimrcp.c:3201 (ASR-1) grammar = builtin:grammar/boolean?language=en-US;y=1;n=2, name = 2025-05-29 15:13:50.335890 [DEBUG] mod_unimrcp.c:3218 (ASR-1) Grammar is URI 2025-05-29 15:13:50.335890 [DEBUG] mod_unimrcp.c:3290 (ASR-1) grammar is text/uri-list 2025-05-29 15:13:50.335890 [DEBUG] mod_unimrcp.c:2361 (ASR-1) Loading grammar 611352e4-73b3-4a1b-a17e-b5a9a4416440, data = builtin:grammar/boolean?language=en-US;y=1;n=2 2025-05-29 15:13:50.335890 [DEBUG] mod_unimrcp.c:2526 (ASR-1) Disabling all grammars 2025-05-29 15:13:50.335890 [DEBUG] mod_unimrcp.c:2485 (ASR-1) Enabling grammar 611352e4-73b3-4a1b-a17e-b5a9a4416440 2025-05-29 15:13:50.335890 [DEBUG] mod_unimrcp.c:2848 (ASR-1) \u0026#34;recognition-timeout\u0026#34;: \u0026#34;5000\u0026#34; 2025-05-29 15:13:50.335890 [DEBUG] mod_unimrcp.c:2848 (ASR-1) \u0026#34;start-input-timers\u0026#34;: \u0026#34;false\u0026#34; 2025-05-29 15:13:50.335890 [DEBUG] mod_unimrcp.c:2848 (ASR-1) \u0026#34;no-input-timeout\u0026#34;: \u0026#34;5000\u0026#34; 2025-05-29 15:13:50.335890 [DEBUG] apt_task.c:265 () Signal Message to [MRCP Client] [0x7f1d6801f470;4;0] 2025-05-29 15:13:50.335890 [DEBUG] apt_task.c:337 () Process Message [MRCP Client] [0x7f1d6801f470;4;0] 2025-05-29 15:13:50.335890 [INFO] mrcp_client_session.c:392 (ASR-1) Receive App MRCP Request ASR-1 \u0026lt;8fe20c9c3c5c11f0\u0026gt; 2025-05-29 15:13:50.335890 [INFO] mrcp_client_session.c:622 (ASR-1) Send MRCP Request ASR-1 \u0026lt;8fe20c9c3c5c11f0@speechrecog\u0026gt; [1] 2025-05-29 15:13:50.335890 [DEBUG] apt_task.c:265 () Signal Message to [MRCPv2ConnectionAgent] [0x7f1dc4005000;1;0] 2025-05-29 15:13:50.335890 [DEBUG] apt_consumer_task.c:141 () Wait for Messages [MRCP Client] 2025-05-29 15:13:50.335890 [DEBUG] apt_poller_task.c:261 () Process Poller Wakeup [MRCPv2ConnectionAgent] 2025-05-29 15:13:50.335890 [DEBUG] apt_task.c:337 () Process Message [MRCPv2ConnectionAgent] [0x7f1dc4005000;1;0] 2025-05-29 15:13:50.335890 [INFO] mrcp_client_connection.c:530 (ASR-1) Send MRCPv2 Data 172.16.4.111:63555 \u0026lt;-\u0026gt; 172.16.7.206:1544 [275 bytes] MRCP/2.0 275 RECOGNIZE 1 Channel-Identifier: 8fe20c9c3c5c11f0@speechrecog Content-Type: text/uri-list Cancel-If-Queue: false Recognition-Timeout: 5000 Start-Input-Timers: false No-Input-Timeout: 5000 Content-Length: 46 builtin:grammar/boolean?language=en-US;y=1;n=2 2025-05-29 15:13:50.335890 [DEBUG] apt_poller_task.c:246 () Wait for Messages [MRCPv2ConnectionAgent] timeout [3000] 2025-05-29 15:13:50.495892 [DEBUG] apt_poller_task.c:269 () Process Signalled Descriptor [MRCPv2ConnectionAgent] 2025-05-29 15:13:50.495892 [INFO] mrcp_client_connection.c:635 () Receive MRCPv2 Data 172.16.4.111:63555 \u0026lt;-\u0026gt; 172.16.7.206:1544 [83 bytes] MRCP/2.0 83 1 200 IN-PROGRESS Channel-Identifier: 8fe20c9c3c5c11f0@speechrecog 2025-05-29 15:13:50.495892 [DEBUG] apt_task.c:265 () Signal Message to [MRCP Client] [0x7f1dc0000a80;2;3] 2025-05-29 15:13:50.495892 [DEBUG] apt_poller_task.c:251 () Wait for Messages [MRCPv2ConnectionAgent] 2025-05-29 15:13:50.495892 [DEBUG] apt_task.c:337 () Process Message [MRCP Client] [0x7f1dc0000a80;2;3] 2025-05-29 15:13:50.495892 [INFO] mrcp_client_session.c:500 (ASR-1) Raise App MRCP Response ASR-1 \u0026lt;8fe20c9c3c5c11f0\u0026gt; 2025-05-29 15:13:50.495892 [DEBUG] mod_unimrcp.c:3610 (ASR-1) RECOGNIZE IN PROGRESS 如果识别成功,会产生DETECTED SPEECH, 业务需要监听这个事件, 然后解析识别出的结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 2025-05-29 15:13:56.695885 [DEBUG] mod_unimrcp.c:2545 (ASR-1) SUCCESS, have result 2025-05-29 15:13:56.695885 [DEBUG] mod_unimrcp.c:2786 (ASR-1) result: \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;result grammar=\u0026#34;builtin:grammar/boolean?language=en-US;y=1;n=2\u0026#34;\u0026gt; \u0026lt;interpretation grammar=\u0026#34;builtin:grammar/boolean?language=en-US;y=1;n=2\u0026#34; confidence=\u0026#34;0.97\u0026#34;\u0026gt; \u0026lt;input mode=\u0026#34;speech\u0026#34;\u0026gt; Hello hello.\u0026lt;/input\u0026gt; \u0026lt;instance\u0026gt; Hello hello.\u0026lt;/instance\u0026gt; \u0026lt;/interpretation\u0026gt; \u0026lt;/result\u0026gt; 2025-05-29 15:13:56.695885 [INFO] mpf_rtp_stream.c:1199 () Generate RTCP SR [ssrc:169295438 s:310 o:49600 ts:51040] 2025-05-29 15:13:56.695885 [INFO] mpf_rtp_stream.c:1386 () Send Compound RTCP Packet [BYE] [76 bytes] 172.16.4.111:4001 -\u0026gt; 172.16.7.206:5075 2025-05-29 15:13:56.715889 [INFO] switch_ivr_async.c:4501 (sofia/internal/1007@172.16.4.111) DETECTED SPEECH EXECUTE [depth=0] sofia/internal/1007@172.16.4.111 log(CRIT \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;result grammar=\u0026#34;builtin:grammar/boolean?language=en-US;y=1;n=2\u0026#34;\u0026gt; \u0026lt;interpretation grammar=\u0026#34;builtin:grammar/boolean?language=en-US;y=1;n=2\u0026#34; confidence=\u0026#34;0.97\u0026#34;\u0026gt; \u0026lt;input mode=\u0026#34;speech\u0026#34;\u0026gt; Hello hello.\u0026lt;/input\u0026gt; \u0026lt;instance\u0026gt; Hello hello.\u0026lt;/instance\u0026gt; \u0026lt;/interpretation\u0026gt; \u0026lt;/result\u0026gt; ) 2025-05-29 15:13:56.715889 [CRIT] mod_dptools.c:1866 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;result grammar=\u0026#34;builtin:grammar/boolean?language=en-US;y=1;n=2\u0026#34;\u0026gt; \u0026lt;interpretation grammar=\u0026#34;builtin:grammar/boolean?language=en-US;y=1;n=2\u0026#34; confidence=\u0026#34;0.97\u0026#34;\u0026gt; \u0026lt;input mode=\u0026#34;speech\u0026#34;\u0026gt; Hello hello.\u0026lt;/input\u0026gt; \u0026lt;instance\u0026gt; Hello hello.\u0026lt;/instance\u0026gt; \u0026lt;/interpretation\u0026gt; \u0026lt;/result\u0026gt; 问题 Failed to Create Session ASR-1 日志：\n1 2 3 4 5 6 7 8 2025-05-29 15:24:04.446106 [NOTICE] mrcp_application.c:96 (ASR-1) Create MRCP Handle 0x7f22d800f740 [test-mrcp] 2025-05-29 15:24:04.446106 [INFO] mrcp_client_session.c:133 (ASR-1) Create Channel ASR-1 \u0026lt;new\u0026gt; 2025-05-29 15:24:04.446106 [DEBUG] apt_task.c:265 () Signal Message to [MRCP Client] [0x7f22d8008bc0;4;0] 2025-05-29 15:24:04.446106 [DEBUG] apt_task.c:337 () Process Message [MRCP Client] [0x7f22d8008bc0;4;0] 2025-05-29 15:24:04.446106 [INFO] mrcp_client_session.c:387 (ASR-1) Receive App Request ASR-1 \u0026lt;new\u0026gt; [2] 2025-05-29 15:24:04.446106 [WARNING] mrcp_client_session.c:1269 (ASR-1) Failed to Create Session ASR-1 \u0026lt;new\u0026gt; [2] 2025-05-29 15:24:04.446106 [INFO] mrcp_client_session.c:533 (ASR-1) Raise App Response ASR-1 \u0026lt;new\u0026gt; [2] FAILURE [1] 2025-05-29 15:24:04.446106 [ERR] mod_unimrcp.c:1920 (ASR-1) RECOGNIZER channel error! 如果unimrcp服务ok,但是使用freeswitch连接就是不行, freeswitch使用的是容器部署。\n检查一下test-mrcp.xml里是不是没有配置client-ip和client-port。 查看一下play_and_detect_speech的用法是否正确。 Receive SIP Event [nua_r_invite] Status 503 Service Unavailable [test-mrcp] 日志：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 025-05-30 09:26:25.837024 [INFO] mrcp_client_session.c:411 (ASR-0) Send Offer ASR-0 \u0026lt;new\u0026gt; [c:1 a:1 v:0] to 172.16.7.206:8060 2025-05-30 09:26:25.837024 [INFO] mrcp_sofiasip_client_agent.c:354 (ASR-0) Local SDP ASR-0 \u0026lt;new\u0026gt; v=0 o=FreeSWITCH 0 0 IN IP4 172.16.4.111 s=- c=IN IP4 172.16.4.111 t=0 0 m=application 9 TCP/MRCPv2 1 a=setup:active a=connection:new a=resource:speechrecog a=cmid:1 m=audio 4000 RTP/AVP 0 8 96 a=rtpmap:0 PCMU/8000 a=rtpmap:8 PCMA/8000 a=rtpmap:96 L16/8000 a=sendonly a=mid:1 2025-05-30 09:26:25.837024 [DEBUG] apt_consumer_task.c:141 () Wait for Messages [MRCP Client] 2025-05-30 09:26:25.837024 [INFO] mrcp_sofiasip_client_agent.c:609 () Receive SIP Event [nua_i_state] Status 0 INVITE sent [test-mrcp] 2025-05-30 09:26:25.837024 [NOTICE] mrcp_sofiasip_client_agent.c:547 (ASR-0) SIP Call State ASR-0 [calling] 2025-05-30 09:26:25.837024 [INFO] mrcp_sofiasip_client_agent.c:609 () Receive SIP Event [nua_r_invite] Status 503 Service Unavailable [test-mrcp] 2025-05-30 09:26:25.837024 [INFO] mrcp_sofiasip_client_agent.c:609 () Receive SIP Event [nua_i_state] Status 503 Service Unavailable [test-mrcp] 2025-05-30 09:26:25.837024 [NOTICE] mrcp_sofiasip_client_agent.c:547 (ASR-0) SIP Call State ASR-0 [terminated] 2025-05-30 09:26:25.837024 [DEBUG] apt_task.c:265 () Signal Message to [MRCP Client] [0x7f286c001fa0;1;0] 2025-05-30 09:26:25.837024 [DEBUG] apt_task.c:337 () Process Message [MRCP Client] [0x7f286c001fa0;1;0] 2025-05-30 09:26:25.837024 [INFO] mrcp_client_session.c:151 (ASR-0) Receive Answer ASR-0 \u0026lt;new\u0026gt; [c:0 a:0 v:0] Status 503 2025-05-30 09:26:25.837024 [INFO] mrcp_client_session.c:455 (ASR-0) Raise App Response ASR-0 \u0026lt;new\u0026gt; [2] FAILURE [2] 2025-05-30 09:26:25.837024 [ERR] mod_unimrcp.c:1920 (ASR-0) RECOGNIZER channel error! unimrcp服务正常，端口也能通。但是使用freeswitch连接不通,报错503 Service Unavailable, 此时检查test-mrcp.xml里是不是没有配置client-ip,容器内这个参数一定要配,要么是auto,要么是具体的ip。\n","date":"2025-05-30T09:15:44+08:00","image":"https://QuincyGao.github.io/p/freeswitch-%E6%B5%8B%E8%AF%95mrcp%E6%A8%A1%E5%9D%97/backup_hu16672930140574900740.jpg","permalink":"https://QuincyGao.github.io/p/freeswitch-%E6%B5%8B%E8%AF%95mrcp%E6%A8%A1%E5%9D%97/","title":"freeswitch 测试mrcp模块"},{"content":"背景 现阶段opensips线上版本最新的是3.6.0-beta, 3.5.x已发布一段时间，3.3.x目前处于停止维护状态。 为保持和官方版本的一致性，决定升级opensips版本到3.5.5。之后的模块介绍都采用3.5.5版本。\n编译修改内容 Makefile.conf.template 为了保持3.5.5版本模块的兼容性，需要修改Makefile.conf.template文件。 参考3.3.10版本Makefile.conf.template文件中的exclude_modules(不编译的模块), 把3.5.5中模块需要编译的去掉.\n运行准备 数据表 opensips在运行时会检查数据表version中各个模块的版本号, 如果版本号不一致, 会报错。 为了避免影响之前的数据库opensips, 可以新建数据库opensips_3_5。\n使用opensips-cli工具创建数据库。\n修改opensips-cli.cfg的database_name为:opensips_3_5\n完整的配置如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [default] log_level: WARNING prompt_name: opensips-cli prompt_intro: Welcome to OpenSIPS Command Line Interface! prompt_emptyline_repeat_cmd: False history_file: ~/.opensips-cli.history history_file_size: 1000 output_type: pretty-print communication_type: http url:http://localhost:9998/mi fifo_file: /run/opensips/opensips_fifo # 选择模块添加数据库表结构 database_modules: ALL # 数据库脚本目录 database_schema_path: /data/scripts/ # 数据库管理员账号 database_admin_url: mysql://root:123456@localhost:3306 database_url: mysql://opensips:opensipsrw@localhost:3306 # 数据库名称 database_name: opensips_3_5 plain_text_password: tru 在此配置中,因为我把opensips-cli和opensips分别制作成两个容器，所以选择的通信方式http, opensips要开启httpd模块。\n如果你是在一个容器中运行opensips-cli和opensips, 可以选择fifo通信方式。\n创建数据库:\n1 opensips-cli -f ./opensips-cli.cfg -x database create opensips.cfg脚本 官方的示例配置在源码/etc/opensips.cfg,分别对比3.3.10和3.5.5版本的配置。\n可以看到，升级到3.5.5版本, 3.3.10需要修改的地方有:\nlog_stderror=no -\u0026gt; stderror_enable=no log_facility=LOG_LOCAL0 -\u0026gt; syslog_facility=LOG_LOCAL0 新增stderror_enabled=no参数 lookup(\u0026quot;location\u0026quot;, \u0026quot;m\u0026quot;) -\u0026gt; lookup(\u0026quot;location\u0026quot;,\u0026quot;method-filtering\u0026quot;) 数据库由opensips修改成opensips_3_5 如果有使用其他的模块,需要根据报错信息修改。\n运行 1 ./opensips -f ./opensips.cfg -m 512 -M 1024 -F 模块变化 详细的变化可以查看官方文档: version-upgrade\n主要模块变化:\nPROTO_MSRP-\u0026gt;PROTO_IPSEC 新增launch_darkly: 不清楚用途 新增http2d: http2 server 新增AKA_AV_DIAMETER: rfc 3310 使用 新增AUTH_AKA: rfc 3310 使用 新增MQUEUE: 基于配置的消息队列 AVPOPS -\u0026gt; SQLOPS: 直接操作数据库 新增PUA_REGINFO: 发布关于注册的信息 新增PRESENCE_REGINFO: 处理注册事件 ","date":"2025-05-27T10:16:52+08:00","image":"https://QuincyGao.github.io/p/opensips-3.3.10-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E5%88%B0-3.5.5/backup_hu629465301679588143.jpg","permalink":"https://QuincyGao.github.io/p/opensips-3.3.10-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E5%88%B0-3.5.5/","title":"opensips 3.3.10 版本升级到 3.5.5"},{"content":"背景 这两个模块用于账号认证的,auth_db模块必须和auth模块一起,不能独立使用。\nauth_db要使用数据库存储账号信息.和上一章kamailio的这个两个模块功能相同。\n相对于kamailio,opensips支持RFC 8760更强的密码认证(SHA-512-256)\n官方文档地址:\nauth auth_db 本次测试的opensips版本是:\nversion: opensips 3.3.10 (x86_64/linux)\nauth 模块 参数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 计算nonce的密钥,默认是随机生成的字符串 modparam(\u0026#34;auth\u0026#34;, \u0026#34;secret\u0026#34;, \u0026#34;johndoessecretphrase\u0026#34;) # 设置nonce的过期时间,单位s,默认:300s modparam(\u0026#34;auth\u0026#34;, \u0026#34;nonce_expire\u0026#34;, 15) # 为Remote-Party-ID添加前缀 modparam(\u0026#34;auth\u0026#34;, \u0026#34;rpid_prefix\u0026#34;, \u0026#34;Whatever \u0026lt;\u0026#34;) # 为Remote-Party-ID添加后缀 modparam(\u0026#34;auth\u0026#34;, \u0026#34;rpid_suffix\u0026#34;, \u0026#34;@1.2.3.4\u0026gt;\u0026#34;) # 设置realm自动删除的前缀,默认:\u0026#34;\u0026#34; modparam(\u0026#34;auth\u0026#34;, \u0026#34;realm_prefix\u0026#34;, \u0026#34;sip.\u0026#34;) # avp变量存储RPID,默认:\u0026#34;$avp(rpid)\u0026#34; modparam(\u0026#34;auth\u0026#34;, \u0026#34;rpid_avp\u0026#34;, \u0026#34;$avp(caller_rpid)\u0026#34;) # 用户名存储在avp变量中,默认:\u0026#34;NULL\u0026#34; modparam(\u0026#34;auth\u0026#34;, \u0026#34;username_spec\u0026#34;, \u0026#34;$var(username)\u0026#34;) # 密码存储在avp变量中,默认:\u0026#34;NULL\u0026#34; modparam(\u0026#34;auth\u0026#34;, \u0026#34;password_spec\u0026#34;, \u0026#34;$var(password)\u0026#34;) # 密码是否使用HA1格式. modparam(\u0026#34;auth\u0026#34;, \u0026#34;calculate_ha1\u0026#34;, 1) 主要函数 www_challenge(realm[, qop[, algorithms]]) 生成WWW-Authorize头部给响应,algorithms默认md5。\nrealm: 通常为服务端的domain,如果为空,对应REGISTER使用$td,其他请求使用$fd\nqop: 可以为:\nauth auth-int auth,auth-int algorithms: 可以为:\nMD5 MD5-sess SHA-256 SHA-256-sess SHA-512-256 SHA-512-256-sess proxy_challenge(realm[, qop[, algorithms]]) 生成Proxy-Authorize头部给响应，参数和www_challenge一样。\nconsume_credentials() 删除认证信息,比如:删除Authorize头部,删除Proxy-Authorize头部. 必须在www_authorize()或者proxy_authorize()之后调用。\nis_rpid_user_e164() 检查Remote-Party-ID是否是E164格式。\nappend_rpid_hf() 追加SIP URI到Remote-Party-ID头部字段。\nappend_rpid_hf(prefix, suffix) 追加前后缀到Remote-Party-ID头部字段。\npv_www_authorize(realm) 验证credentials是否正确,如果正确,标记此credentials已经验证了,如果失败,后面可以主动调用www_challenge()再次请求验证。\n返回值： -5: 通用错误,不发送回复 -4: 请求没有credentials -3: nonce状态 -2: 密码错误 -1: 用户名错误 pv_proxy_authorize(realm) 验证credentials是否正确,如果正确,标记此credentials已经验证了,如果失败,后面可以主动调用proxy_challenge()再次请求验证。\nauth_db 模块 使用到的数据表subscriber和uri\n参数解析 1 2 3 4 5 6 7 8 9 10 # 数据库连接 modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;db_url\u0026#34;, \u0026#34;DBURL\u0026#34;) # 是否使用HA1格式的密码来认证 modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;calculate_ha1\u0026#34;, 1) # 是否使用domain modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;use_domain\u0026#34;, 1) # 设置是否加载credentials到avp变量,默认:\u0026#34;\u0026#34; modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;load_credentials\u0026#34;, \u0026#34;$avp(13)=rpid;email_address\u0026#34;) # 设置是否跳过版本检查,默认:0 modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;skip_version_check\u0026#34;, 1) 主要函数 www_authorize(realm, table) 验证credentials是否正确,如果正确,标记此credentials已经验证了,如果失败,后面可以主动调用www_challenge()再次请求验证。\n返回值：\n-5: 通用错误,不发送回复 -4: 请求没有credentials -3: nonce状态 -2: 密码错误 -1: 用户名错误 realm: 通常为服务端的domain,如果为空,对应REGISTER使用$td,其他请求使用$fd\ntable: 数据库表名\nproxy_authorize(realm, table) 验证credentials是否正确,如果正确,标记此credentials已经验证了,如果失败,后面可以主动调用proxy_challenge()再次请求验证。 入参,返回值和www_authorize一样。\ndb_is_to_authorized(table) 检查To头部的URI是否是授权的。\ndb_is_from_authorized(table) 检查From头部的URI是否是授权的。\ndb_does_uri_exist(uri, table) 检查 username@domain 是否存在subscriber表中\ndb_get_auth_id(table, uri, auth, realm) 检查uri是否存在subscriber表中.\n实战 不使用数据库 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 socket=udp:172.16.4.111:5261 ... loadmodule \u0026#34;auth.so\u0026#34; modparam(\u0026#34;auth\u0026#34;, \u0026#34;nonce_expire\u0026#34;, 60) modparam(\u0026#34;auth\u0026#34;, \u0026#34;username_spec\u0026#34;, \u0026#34;$var(username)\u0026#34;) modparam(\u0026#34;auth\u0026#34;, \u0026#34;password_spec\u0026#34;, \u0026#34;$var(password)\u0026#34;) modparam(\u0026#34;auth\u0026#34;, \u0026#34;calculate_ha1\u0026#34;, 1) route { ... if (is_method(\u0026#34;REGISTER\u0026#34;)) { $var(username)=\u0026#34;1007\u0026#34;; $var(password)=\u0026#34;1234\u0026#34;; if (!pv_www_authorize(\u0026#34;\u0026#34;)) { www_challenge(\u0026#34;\u0026#34;, \u0026#34;auth,auth-int\u0026#34;); exit; } # indicate that the client supports DTLS # so we know when he is called if (isflagset(\u0026#34;SRC_WS\u0026#34;)) setbflag(\u0026#34;DST_WS\u0026#34;); fix_nated_register(); if (!save(\u0026#34;location\u0026#34;)) sl_reply_error(); exit; } if (!lookup(\u0026#34;location\u0026#34;,\u0026#34;m\u0026#34;)) { t_newtran(); t_reply(404, \u0026#34;Not Found\u0026#34;); exit; } route(relay); } 说明: 如果要使用SHA-512-256及SHA-512-256-sess算法,openssl需要升级版本\u0026gt;=1.1.1, 否则会报错。\n1 2 3 core:dauth_fixup_algorithms: Unsupported algorithm type: \u0026#34;SHA-512-256\u0026#34; May 26 14:24:13 [242] ERROR:core:fix_cmd: Fixup failed for param [3] May 26 14:24:13 [242] ERROR:core:fix_actions: Failed to fix command \u0026lt;www_challenge\u0026gt; 输出结果 使用软电话注册号码1007,密码1234,注册成功: 可以看到在401 信令上,WWW-Authenticate头部包含qop和algorithm。\n如果用户名或者密码错误,sip信令图: 使用pv_proxy_authenticate()函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 route { if (is_method(\u0026#34;REGISTER\u0026#34;)) { $var(username)=\u0026#34;1007\u0026#34;; $var(password)=\u0026#34;1234\u0026#34;; if (!pv_proxy_authorize(\u0026#34;\u0026#34;)) { proxy_challenge(\u0026#34;\u0026#34;, \u0026#34;auth,auth-int\u0026#34;,\u0026#34;SHA-256\u0026#34;); # Realm will be autogenerated exit; } # indicate that the client supports DTLS # so we know when he is called if (isflagset(\u0026#34;SRC_WS\u0026#34;)) setbflag(\u0026#34;DST_WS\u0026#34;); fix_nated_register(); if (!save(\u0026#34;location\u0026#34;)) sl_reply_error(); exit; } } 输出的信令图： 可以看到在407 信令上,Proxy-Authenticate头部包含qop和algorithm。\n使用数据库 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 socket=udp:172.16.4.111:5261 ... loadmodule \u0026#34;auth.so\u0026#34; modparam(\u0026#34;auth\u0026#34;, \u0026#34;nonce_expire\u0026#34;, 60) modparam(\u0026#34;auth\u0026#34;, \u0026#34;username_spec\u0026#34;, \u0026#34;$var(username)\u0026#34;) modparam(\u0026#34;auth\u0026#34;, \u0026#34;password_spec\u0026#34;, \u0026#34;$var(password)\u0026#34;) #modparam(\u0026#34;auth\u0026#34;, \u0026#34;calculate_ha1\u0026#34;, 1) loadmodule \u0026#34;auth_db.so\u0026#34; modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;db_url\u0026#34;, \u0026#34;DBURL\u0026#34;) #modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;calculate_ha1\u0026#34;, 1) route { ... if (is_method(\u0026#34;REGISTER\u0026#34;)) { if (!www_authorize(\u0026#34;\u0026#34;, \u0026#34;subscriber\u0026#34;)) { www_challenge(\u0026#34;\u0026#34;, \u0026#34;auth\u0026#34;,\u0026#34;SHA-256\u0026#34;); exit; } # indicate that the client supports DTLS # so we know when he is called if (isflagset(\u0026#34;SRC_WS\u0026#34;)) setbflag(\u0026#34;DST_WS\u0026#34;); fix_nated_register(); if (!save(\u0026#34;location\u0026#34;)) sl_reply_error(); exit; } } 数据表subscriber的结构为： ha1字段的计算方式: md5(username:realm:password)\nha1_sha256字段的计算方式: sha256(username:realm:password)\nha1_sha512t256 字段的计算方式: sha512t256(username:realm:password)\n添加用户:\n使用opensips-cli 客户端创建用户: 1 opensips-cli -f ./opensips-cli.cfg -x user add 1007@172.16.4.111 1234 直接在数据表添加用户: 1 insert into subcriber (\u0026#39;username\u0026#39;,\u0026#39;domain\u0026#39;,\u0026#39;password\u0026#39;,\u0026#39;ha1\u0026#39;,\u0026#39;ha1_sha256\u0026#39;)values(\u0026#39;1007\u0026#39;,\u0026#39;172.16.4.111\u0026#39;,\u0026#39;1234\u0026#39;,\u0026#39;167f7cc6ce5f65305e413cd7d040cce3\u0026#39;,\u0026#39;467bd26ba1d413546561c0f3c32cd85f1c162ee84c19acb687efc6faa6c11266\u0026#39;) 输出结果 使用md5算法,注册成功: 如果使用HA1算法,放开配置modparam(\u0026quot;auth_db\u0026quot;, \u0026quot;calculate_ha1\u0026quot;, 1),目前未注册成功: 日志报错: 一直报错:sha256认证失败, 但是数据库中ha1_sha256字段的值是正确的。暂时未找到问题所在。\n总结 opensips在不使用数据库的情况下, 用户名和密码都要设置, kamailio只设置密码。 opensips支持MD5,SHA-256和SHA-512-256算法, kamailio支持MD5,SHA-256算法。 ","date":"2025-05-26T09:38:24+08:00","image":"https://QuincyGao.github.io/p/opensips-auth%E5%92%8Cauth_db%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/backup_hu451907087946171817.jpg","permalink":"https://QuincyGao.github.io/p/opensips-auth%E5%92%8Cauth_db%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","title":"opensips auth和auth_db模块介绍"},{"content":"背景 这两个模块用于账号认证的,auth_db模块必须和auth模块一起. auth_db要使用数据库存储账号信息.\n官方文档地址:\nauth auth_db 本次测试的kamailio版本是:\nversion: kamailio 5.8.5 (x86_64/linux)\nauth 模块 参数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # 用来对注册信息完整性检查,参数查看auth_checks_in_dlg解释, 11:URI+callid+source ip modparam(\u0026#34;auth\u0026#34;, \u0026#34;auth_checks_register\u0026#34;, 11) # 检查sip请求是否没有`ToHearder`或者`To tag`, 9:URI+source ip modparam(\u0026#34;auth\u0026#34;, \u0026#34;auth_checks_no_dlg\u0026#34;, 9) # 检查sip请求是否是dialog, 1: 检查URI是否改变;2:检查callid;3:检查From tag;4:检查源ip地址 modparam(\u0026#34;auth\u0026#34;, \u0026#34;auth_checks_in_dlg\u0026#34;, 15) # 设置qop 参数,默认:\u0026#34;\u0026#34;, 可以为:auth, auth-int, \u0026#34;\u0026#34; modparam(\u0026#34;auth\u0026#34;, \u0026#34;qop\u0026#34;, \u0026#34;auth\u0026#34;) # 会记录nc值并和之前的nc值比较,如果小于之前的nc值,就会拒绝请求,依赖qop参数,默认:0 modparam(\u0026#34;auth\u0026#34;, \u0026#34;nonce_count\u0026#34;, 1) # 如果设置成1,nonce不能重用 modparam(\u0026#34;auth\u0026#34;, \u0026#34;one_time_nonce\u0026#34;, 1) # 控制nonce_count和one_time_nonce的分区,默认:1,可以为:1,2,4,8,16,32,64 modparam(\u0026#34;auth\u0026#34;, \u0026#34;nid_pool_no\u0026#34;, 4) # 设置最大的nonce_count,默认:1048576(1Mb memory) modparam(\u0026#34;auth\u0026#34;, \u0026#34;nc_array_size\u0026#34;, 4194304) # 4Mb # 和nc_array_size功能一致,nc_array_size=2^nc_array_order,默认:20(1Mb memory) modparam(\u0026#34;auth\u0026#34;, \u0026#34;nc_array_order\u0026#34;, 22) # 设置最大的one_time_nonce,默认:1048576(1M nonces, 128Kb memory) modparam(\u0026#34;auth\u0026#34;, \u0026#34;otn_in_flight_no\u0026#34;, 8388608) # 8 Mb (1Mb memory) # 和otn_in_flight_no等价,otn_in_flight_order=2^otn_in_flight_no,默认:20(1M nonces, 128Kb memory) modparam(\u0026#34;auth\u0026#34;, \u0026#34;otn_in_flight_order\u0026#34;, 23) # 8 Mb (1Mb memory) # 用于计算nonce的密钥,默认是随机生成的字符串 modparam(\u0026#34;auth\u0026#34;, \u0026#34;secret\u0026#34;, \u0026#34;johndoessecretphrase\u0026#34;) # 设置nonce的过期时间,单位s,默认:300s modparam(\u0026#34;auth\u0026#34;, \u0026#34;nonce_expire\u0026#34;, 600) # Set nonce_expire to 600s # 设置nonce的最大漂移时间,单位s,默认:3s modparam(\u0026#34;auth\u0026#34;, \u0026#34;nonce_auth_max_drift\u0026#34;, 1) # set max drift to 1 s # 如果设置为1, 不管事务是否存在,www_challenge()和proxy_challenge()都返回无状态的回复. 0:有状态回复. modparam(\u0026#34;auth\u0026#34;, \u0026#34;force_stateless_reply\u0026#34;, 1) # 设置realm前缀,默认:\u0026#34;\u0026#34; modparam(\u0026#34;auth\u0026#34;, \u0026#34;realm_prefix\u0026#34;, \u0026#34;sip.\u0026#34;) # 设置算法,默认:MD5,可以为:SHA-256。SHA-256使用的空间是MD5的2倍 modparam(\u0026#34;auth\u0026#34;, \u0026#34;algorithm\u0026#34;, \u0026#34;SHA-256\u0026#34;) #是否把authentication-info添加到200OK响应中,默认:no modparam(\u0026#34;auth\u0026#34;, \u0026#34;add_authinfo_hdr\u0026#34;, yes) 主要函数 consume_credentials() 删除认证信息,比如:删除Authorization头部,删除Proxy-Authorization头部.\nhas_credentials(realm) 检查请求的Authorization或者Proxy-Authorization头部是否包含realm.\nwww_challenge(realm, flags) 生成WWW-Authenticate头部给响应并发送401返回.\nrealm: 不能为空,在REGISTER请求中,可以用$td(To domain),其他请求中,可以用$fd(From domain). flags: 可以为: 1: 构建challenge头,使用qop=auth 2: 构建challenge头,使用qop=auth-int 4: 在一些失败的场景中,不发送500 Internal Server Error响应 16: 构建challenge头,使用stale=true proxy_challenge(realm, flags) 生成Proxy-Authenticate头部给响应并发送407返回.参数和www_challenge一样.\nauth_challenge(realm, flags) 是www_challenge()和proxy_challenge()的合集. 如果请求是REGISTER请求,就生成authentication返回401,其他的请求,返回407。\npv_www_authenticate(realm, passwd, flags [, method]) 验证credentials是否正确,如果正确,标记此credentials已经验证了,如果失败,后面可以主动调用www_challenge()再次请求验证.\n返回值：\n-1: 通用错误,不发送回复 -2: 密码错误 -4: nonce过期 -5: 请求没有包含realm的Authorization头部 -6: nonce已经被用过了 flags:\n1: password必须是HA1格式 2: 构建不带qop的WWW-Authenticate头部,并添加到avp变量 4: 构建带qop=auth的WWW-Authenticate头部,并添加到avp变量 8: 构建带qop=auth-int的WWW-Authenticate头部,并添加到avp变量 16: 构建带stale=true的WWW-Authenticate头部 32: 身份验证失败时,nc不失效 pv_proxy_authenticate(realm, passwd, flags) 功能和pv_www_authenticate()一样,只是验证失败之后，可以调用proxy_challenge重新验证.\npv_auth_check(realm, passwd, flags, checks) 是pv_www_authenticate和pv_proxy_authenticate的合集\nauth_get_www_authenticate(realm, flags, pvdest) 构建WWW-Authenticate头部,设置结果到pvdest变量.参数和pv_www_authenticate一致\nauth_db 模块 参数解析 1 2 3 4 5 6 7 8 9 10 # 数据库连接 modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;db_url\u0026#34;, \u0026#34;DBURL\u0026#34;) # 是否使用HA1格式的密码来认证 modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;calculate_ha1\u0026#34;, 1) # 是否使用domain来认证,默认:0 modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;use_domain\u0026#34;, 1) # 设置从数据库获取的凭证 modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;load_credentials\u0026#34;, \u0026#34;$avp(i:123)=rpid;email_address\u0026#34;) # 是否检查subscriber表版本,默认:1 modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;version_table\u0026#34;, 0) 主要函数 www_authenticate(realm, table [, method]) 验证credentials是否正确,如果正确,标记此credentials已经验证了,如果失败,后面可以主动调用www_challenge()再次请求验证.\n返回值： -1: 通用错误,不发送回复 -2: 密码错误 -3: 用户不存在 -4: nonce过期 -5: 请求没有包含realm的Authorization头部 -6: nonce已经被用过了 -8: From/To/RURI中的用户和认证的用户不一致 www_authorize(realm, table) 和www_authenticate功能一样\nproxy_authenticate(realm, table) 验证credentials是否正确,如果正确,标记此credentials已经验证了,如果失败,后面可以主动调用proxy_challenge()再次请求验证.\nproxy_authorize(realm, table) 和proxy_authenticate功能一样\nauth_check(realm, table, flags) 是www_authenticate和proxy_authenticate的合集\nis_subscriber(uri, dbtable, flags) 检查uri是否是subscriber\n实战 官方配置 官方配置文件: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 !define WITH_AUTH listen=udp:172.16.4.111:5460 #!ifdef WITH_AUTH loadmodule \u0026#34;auth.so\u0026#34; loadmodule \u0026#34;auth_db.so\u0026#34; #!ifdef WITH_IPAUTH loadmodule \u0026#34;permissions.so\u0026#34; #!endif #!endif #!ifdef WITH_AUTH modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;calculate_ha1\u0026#34;, yes) modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;password_column\u0026#34;, \u0026#34;password\u0026#34;) modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;load_credentials\u0026#34;, \u0026#34;\u0026#34;) modparam(\u0026#34;auth_db\u0026#34;, \u0026#34;use_domain\u0026#34;, MULTIDOMAIN) # ----- permissions params ----- #!ifdef WITH_IPAUTH modparam(\u0026#34;permissions\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;permissions\u0026#34;, \u0026#34;load_backends\u0026#34;, 1) #!endif #!endif ... request_route { ... route(AUTH); ... } route[AUTH] { #!ifdef WITH_AUTH #!ifdef WITH_IPAUTH if((!is_method(\u0026#34;REGISTER\u0026#34;)) \u0026amp;\u0026amp; allow_source_address()) { # source IP allowed return; } #!endif if (is_method(\u0026#34;REGISTER\u0026#34;) || from_uri==myself) { # authenticate requests if (!auth_check(\u0026#34;$fd\u0026#34;, \u0026#34;subscriber\u0026#34;, \u0026#34;1\u0026#34;)) { auth_challenge(\u0026#34;$fd\u0026#34;, \u0026#34;0\u0026#34;); exit; } # user authenticated - remove auth header if(!is_method(\u0026#34;REGISTER|PUBLISH\u0026#34;)) consume_credentials(); } # if caller is not local subscriber, then check if it calls # a local destination, otherwise deny, not an open relay here if (from_uri!=myself \u0026amp;\u0026amp; uri!=myself) { sl_send_reply(\u0026#34;403\u0026#34;, \u0026#34;Not relaying\u0026#34;); exit; } #!else # authentication not enabled - do not relay at all to foreign networks if(uri!=myself) { sl_send_reply(\u0026#34;403\u0026#34;, \u0026#34;Not relaying\u0026#34;); exit; } #!endif return; } 官方使用的是auth_check, 由于数据表subscriber没有数据, 直接注册坐席会报错\n输出结果: sip信令图: 可以看到,当REGISTER第一次请求时,会返回401错误,并且WWW-Authenticate头部包含realm和nonce. 软电话收到401之后，再次请求REGISTER时，由于subscriber没有用户，所以还是会返回401.\n表subscriber的结构为: 新增用户:\n1 insert into `subscriber`(\u0026#39;username\u0026#39;,\u0026#39;password\u0026#39;)values(\u0026#39;1004\u0026#39;,\u0026#39;1234\u0026#39;); 再次注册电话成功: 自定义配置 配置文件:\n1 2 3 4 5 6 7 8 9 10 modparam(\u0026#34;auth\u0026#34;, \u0026#34;auth_checks_in_dlg\u0026#34;, 15) modparam(\u0026#34;auth\u0026#34;, \u0026#34;auth_checks_no_dlg\u0026#34;, 9) modparam(\u0026#34;auth\u0026#34;, \u0026#34;auth_checks_register\u0026#34;, 11) modparam(\u0026#34;auth\u0026#34;, \u0026#34;qop\u0026#34;, \u0026#34;auth\u0026#34;) # set qop=auth modparam(\u0026#34;auth\u0026#34;, \u0026#34;nonce_count\u0026#34;, 1) # enable nonce_count support modparam(\u0026#34;auth\u0026#34;, \u0026#34;nonce_expire\u0026#34;, 600) # Set nonce_expire to 600s modparam(\u0026#34;auth\u0026#34;, \u0026#34;use_domain\u0026#34;, 1) modparam(\u0026#34;auth\u0026#34;, \u0026#34;algorithm\u0026#34;, \u0026#34;SHA-256\u0026#34;) modparam(\u0026#34;auth\u0026#34;, \u0026#34;add_authinfo_hdr\u0026#34;, yes) modparam(\u0026#34;auth\u0026#34;, \u0026#34;realm_prefix\u0026#34;, \u0026#34;sip.\u0026#34;) 使用pv_www_authenticate 在 route(AUTH)路由中,修改：\n1 2 3 4 if (!auth_check(\u0026#34;$fd\u0026#34;, \u0026#34;subscriber\u0026#34;, \u0026#34;1\u0026#34;)) { auth_challenge(\u0026#34;$fd\u0026#34;, \u0026#34;0\u0026#34;); exit; } 为:\n1 2 3 4 5 6 7 $var(passwd)=\u0026#34;1234\u0026#34;; xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;------$pr|$rm|$td------\\n\u0026#34;); if(!pv_www_authenticate(\u0026#34;$td\u0026#34;,\u0026#34;$var(passwd)\u0026#34;, 4)) { www_challenge(\u0026#34;$td\u0026#34;, \u0026#34;1\u0026#34;); xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;------authenticate failed.\\n\u0026#34;); exit; } 输出的syslog:\n1 2 3 4 5(3398) INFO: |25-05-22 15:16:31|b68c22b49064436190e4062acac56d5f| \u0026lt;script\u0026gt;: ------udp|REGISTER|172.16.4.111------ 5(3398) INFO: |25-05-22 15:16:31|b68c22b49064436190e4062acac56d5f| \u0026lt;script\u0026gt;: ------authenticate failed. 6(3399) INFO: |25-05-22 15:16:31|b68c22b49064436190e4062acac56d5f| \u0026lt;script\u0026gt;: ------172.16.80.13:56001|172.16.4.111:5460|udp|REGISTER 6(3399) INFO: |25-05-22 15:16:31|b68c22b49064436190e4062acac56d5f| \u0026lt;script\u0026gt;: ------udp|REGISTER|172.16.4.111------ 返回的401 sip图: 可以看到,由于配置参数设置了qop和algorithm, 所以返回的WWW-Authenticate头部包含qop和algorithm。\n软电话再次REGISTER的sip信令图: 可以看到,Authorization头部包含qop和algorithm。\n这种方式好处就是不用请求数据库,但是密码是存变量里，需要单独维护.\n使用pv_proxy_authenticate 1 2 3 4 5 6 7 $var(passwd)=\u0026#34;1234\u0026#34;; xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;------$pr|$rm|$td------\\n\u0026#34;); if(!pv_www_authenticate(\u0026#34;$td\u0026#34;,\u0026#34;$var(passwd)\u0026#34;, 4)) { www_challenge(\u0026#34;$td\u0026#34;, \u0026#34;1\u0026#34;); xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;------authenticate failed.\\n\u0026#34;); exit; } 修改为:\n1 2 3 4 5 6 7 $var(passwd)=\u0026#34;1234\u0026#34;; xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;------$pr|$rm|$td------\\n\u0026#34;); if(!pv_proxy_authenticate(\u0026#34;$td\u0026#34;,\u0026#34;$var(passwd)\u0026#34;, 4)) { proxy_challenge(\u0026#34;$td\u0026#34;, \u0026#34;1\u0026#34;); xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;------authenticate failed.\\n\u0026#34;); exit; } 返回407 sip图: 可以看到此时返回的是407, Proxy-Authenticate头部包含qop和algorithm。\n软电话再次REGISTER的sip信令图: Proxy-Authorization头部包含qop和algorithm。\n总结 如果不想用数据库,单独使用auth,不过密码需要维护 如果想使用数据库,就使用auth_db和auth 如果想返回401,就用pv_www_authenticate,www_authenticate和pv_auth_check 如果想返回407,就用pv_proxy_authenticate,proxy_authenticate和auth_check ","date":"2025-05-22T10:02:41+08:00","image":"https://QuincyGao.github.io/p/kamailio-auth%E5%92%8Cauth_db%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/backup_hu3424222680422407341.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-auth%E5%92%8Cauth_db%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","title":"kamailio auth和auth_db模块介绍"},{"content":"背景介绍 opensips的exec模块用于执行外部命令,可以用于执行脚本，和上章介绍的kamailio的exec模块类似。\n官方文档地址: exec,本次测试的opensips版本是:\nversion: opensips 3.3.10 (x86_64/linux)\n配置解析 1 2 3 4 # 是否打开执行脚本来设置环境变量,默认:0 modparam(\u0026#34;exec\u0026#34;, \u0026#34;setvars\u0026#34;, 1) # 设置最长的执行时间,单位s,默认:0,如果超过这个时间,就会被杀死 modparam(\u0026#34;exec\u0026#34;, \u0026#34;time_to_kill\u0026#34;, 20) 重要函数 exec(command, [stdin], [stdout], [stderr], [envavp]) command: 要执行的命令 stdin: 输入参数,默认为空 stdout: 输出参数,默认为空 stderr: 错误输出参数,默认为空 envavp: 环境变量,默认为空,环境变量名为: OSIPS_EXEC_#,#为环境变量的索引,从0开始。比如: OSIPS_EXEC_0 async(exec(command)) 可以异步执行命令.\n实战 配置文件: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 loadmodule \u0026#34;exec.so\u0026#34; modparam(\u0026#34;exec\u0026#34;,\u0026#34;setvars\u0026#34;, 1) modparam(\u0026#34;exec\u0026#34;,\u0026#34;time_to_kill\u0026#34;, 20) ... route { ... $avp(env) = \u0026#34;a\u0026#34;; $avp(env) = \u0026#34;b\u0026#34;; exec(\u0026#34;pwd \u0026#34;, , $var(out), $var(err), $avp(env)); xlog(\u0026#34;The output is $var(out)\\n\u0026#34;); xlog(\u0026#34;Received the following error:$var(err)\\n\u0026#34;); ... } 输出结果:\nsyslog日志:\n1 2 May 20 11:44:27 [1492] The output is / May 20 11:44:27 [1492] Received the following error:\u0026lt;null\u0026gt; ","date":"2025-05-20T10:28:31+08:00","image":"https://QuincyGao.github.io/p/opensips-exec%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/backup_hu3016105993861849133.jpg","permalink":"https://QuincyGao.github.io/p/opensips-exec%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","title":"opensips exec模块介绍"},{"content":"背景介绍 exec和evrexec模块比较简单，所以就放在一章介绍。\nexec 模块：用于执行外部命令。 evrexec 模块：用于执行event_route事件,比如:进程启动,收到RPC命令或者从udp端口收到数据。 官方文档地址:\nexec evrexec 本次测试的kamailio版本是:\nversion: kamailio 5.8.5 (x86_64/linux)\nexec模块 参数解析 1 2 3 4 5 # 是否打开执行脚本来设置环境变量,默认:1 modparam(\u0026#34;exec\u0026#34;, \u0026#34;setvars\u0026#34;, 1) # 设置最长的执行时间,单位s,默认:0,如果超过这个时间,就会被杀死 modparam(\u0026#34;exec\u0026#34;, \u0026#34;time_to_kill\u0026#34;, 20) 重要函数 exec_dset(command) 执行外部命令,并返回执行结果。当前的URI作为参数传递，返回的是设置后的URI.\n只能用在: REQUEST_ROUTE, FAILURE_ROUTE\nexec_msg(command) 执行外部命令,整个message作为参数传递,没有其他命令行参数添加.\n只能用在: REQUEST_ROUTE, FAILURE_ROUTE\nexec_avp(command [, avplist]) 执行外部命令,每个输出结果存储在avplist中.\n只能用在: REQUEST_ROUTE, FAILURE_ROUTE\nexec_cmd(command) 执行外部命令,轻量版本,不传递SIP消息做参数,也不设置环境变量,也不使用输出的命令.\n可以用在: ANY ROUTE\n实战 配置文件: 1 2 3 4 5 6 7 8 9 10 11 12 13 loadmodule \u0026#34;exec.so\u0026#34; modparam(\u0026#34;exec\u0026#34;,\u0026#34;setvars\u0026#34;, 1) modparam(\u0026#34;exec\u0026#34;, \u0026#34;time_to_kill\u0026#34;,20) ... request_route { ... $var(text) = exec_dset(\u0026#34;echo TEST \u0026gt; /tmp/test.txt\u0026#34;); xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;---$si---$fU--$var(text)--\\n\u0026#34;); exec_msg(\u0026#34;echo test222 \u0026gt; /tmp/$(fU).txt\u0026#34;); exec_cmd(\u0026#34;echo abc \u0026gt; /tmp/abc.txt\u0026#34;); ... } 输出结果:\nsyslog日志:\n1 2 3(1728) ERROR: |25-05-19 11:40:08|a2615f4bd775445386f2123bc458b299| exec [exec.c:190]: exec_str(): no uri from echo TEST \u0026gt; /tmp/test.txt \u0026#39;sip:172.16.4.111:5460\u0026#39; 3(1728) INFO: |25-05-19 11:40:08|a2615f4bd775445386f2123bc458b299| \u0026lt;script\u0026gt;: ---172.16.80.13---1004---1-- tmp下的文件:\n1 2 3 4 5 6 [root@localhost tmp]# cat abc.txt abc [root@localhost tmp]# cat 1004.txt test222 [root@localhost tmp]# cat test.txt TEST sip:172.16.4.111:5460 可以看到,exec_cmd和exec_msg都成功了,exec_dset有错误日志,但是脚本执行成功了。\nevrexec模块 参数解析 1 2 3 4 5 name: event_route执行名字 wait: 等待时间,单位ms,默认:1000 workers: 执行线程数,默认:1 sockaddr: udp socket addr modparam(\u0026#34;evrexec\u0026#34;, \u0026#34;exec\u0026#34;, \u0026#34;name=evrexec:timer;wait=1000;workers=1;\u0026#34;) 实战 配置文件: 1 2 3 4 5 6 7 8 9 10 11 12 13 loadmodule \u0026#34;evrexec.so\u0026#34; modparam(\u0026#34;evrexec\u0026#34;, \u0026#34;exec\u0026#34;, \u0026#34;name=evrexec:timer;wait=1000;workers=1;\u0026#34;) modparam(\u0026#34;evrexec\u0026#34;, \u0026#34;exec\u0026#34;, \u0026#34;name=evrexec:udp;sockaddr=udp:127.0.0.1:4444;workers=1;\u0026#34;) ... event_route[evrexec:timer] { $var(x) = 0; xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;evrexectimer run...\\n\u0026#34;); } event_route[evrexec:udp] { xinfo(\u0026#34;udp socket data: [$evr(data)] from [$evr(srcip)]\\n\u0026#34;); } 输出结果:\nsyslog日志:\n1 2 3 37(2902) INFO: jsonrpcs [jsonrpcs_sock.c:471]: jsonrpc_dgram_process(): a new child 0/2902 39(2904) INFO: ctl [io_listener.c:215]: io_listen_loop(): using epoll_lt io watch method (config) 45(2910) INFO: \u0026lt;script\u0026gt;: evrexectimer run.... evrexec:timer: 还是比较有用的，可以执行服务启动时就运行脚本的功能。 evrexec:udp: 可以监听udp端口,但是不能是listen的端口,要使用未监听的端口。\nevrexec的参数有:\n$evr(data): udp端口收到的数据 $evr(srcip): udp源ip $evr(srcport): udp源端口的字符串值 $evr(srcportno): udp源端口整形值 ","date":"2025-05-19T14:11:18+08:00","image":"https://QuincyGao.github.io/p/kamailio-exec%E5%92%8Cevrexec%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/backup_hu2980080515255046273.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-exec%E5%92%8Cevrexec%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","title":"kamailio exec和evrexec模块介绍"},{"content":"背景 acc 模块用来记录会话信息到syslog,数据库, AAA和EVENTS中，do_accounting()函数并不是记录信息，只是标记会话信息，当会话完成时才去记录。\n最小的记录信息包括:\n请求method From 头的tag To 头的tag Call-ID 响应的code 响应的reason 会话完成的时间戳 官方文档地址: acc,本次测试的opensips版本是:\nversion: opensips 3.3.10 (x86_64/linux)\n重要参数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 记录响铃 modparam(\u0026#34;acc\u0026#34;, \u0026#34;early_media\u0026#34;, 1) # 上报CANCEL消息 modparam(\u0026#34;acc\u0026#34;, \u0026#34;report_cancels\u0026#34;, 1) # 控制请求方向 modparam(\u0026#34;acc\u0026#34;, \u0026#34;detect_direction\u0026#34;, 1) # 定义额外的参数 modparam(\u0026#34;acc\u0026#34;, \u0026#34;extra_fields\u0026#34;, \u0026#34;log: a-\u0026gt;My_a_Field; b\u0026#34;) # 定义多条腿的参数 modparam(\u0026#34;acc\u0026#34;, \u0026#34;leg_fields\u0026#34;, \u0026#34;log: a-\u0026gt;My_a_Field; b\u0026#34;) # 定义日志级别 modparam(\u0026#34;acc\u0026#34;, \u0026#34;log_level\u0026#34;, 2) # 定义数据表名 modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_table_acc\u0026#34;, \u0026#34;acc\u0026#34;) # 定义失败的数据表名 modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_table_missed_calls\u0026#34;, \u0026#34;missed_calls\u0026#34;) # 数据库地址 modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_url\u0026#34;, \u0026#34;DBURL\u0026#34;) 重要函数解析 do_accounting(type, [flags], [table]) type: 类型，有以下几种类型:\nlog: syslog db: database aaa: aaa evi: event flags: 标志位，有以下几种标志位:\ncdr: 记录CDR missed: 记录未接电话 failed: 当状态码\u0026gt;=300,记录失败信息 table: 数据表名\ndrop_accounting([type], [flags]) 重置flag和types, 参数和do_accounting函数一样。\n不带参数时，所有的记录都会停止。 带一个参数时，只会停止指定的类型。 带两个参数时，只会停止指定的类型和标志位。 acc_log_request(comment) 上报请求到日志,comment 必须是带有错误码的字符串,例如:480 NoBody Home\nacc_db_request(comment, table) 上报请求到数据库,comment和acc_log_request一样\nacc_aaa_request(comment) 上报请求到AAA,comment和acc_log_request一样\nacc_evi_request(comment) 上报请求到EVENTS,comment和acc_log_request一样\nacc_new_leg() 创建一个新腿,所有的参数为null.\nacc_load_ctx_from_dlg() 加载和导出当前在用的dialog的accouting context. 必须和load_dialog_ctx()一起使用\nacc_unload_ctx_from_dlg() 卸载accouting context\nEVENTS事件 E_ACC_CDR cdr事件,参数:\nmethod from_tag to_tag callid sip_code sip_reason time evi_extra evi_extra_bye multi_leg_info multi_leg_bye_info duration ms_duration setuptime created E_ACC_EVENT method from_tag to_tag callid sip_code sip_reason time evi_extra multi_leg_info E_ACC_MISSED_EVENT method from_tag to_tag callid sip_code sip_reason time evi_extra multi_leg_info created setuptime 实战 输出到syslog 使用官方配置：\n配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 # # OpenSIPS residential configuration script # by OpenSIPS Solutions \u0026lt;team@opensips-solutions.com\u0026gt; # # This script was generated via \u0026#34;make menuconfig\u0026#34;, from # the \u0026#34;Residential\u0026#34; scenario. # You can enable / disable more features / functionalities by # re-generating the scenario with different options.# # # Please refer to the Core CookBook at: # https://opensips.org/Resources/DocsCookbooks # for a explanation of possible statements, functions and parameters. # ####### Global Parameters ######### /* uncomment the following lines to enable debugging */ #debug_mode=yes log_level=3 xlog_level=3 log_stderror=no log_facility=LOG_LOCAL0 udp_workers=4 /* uncomment the next line to enable the auto temporary blacklisting of not available destinations (default disabled) */ #disable_dns_blacklist=no /* uncomment the next line to enable IPv6 lookup after IPv4 dns lookup failures (default disabled) */ #dns_try_ipv6=yes socket=udp:172.16.4.111:5261 # CUSTOMIZE ME ####### Modules Section ######## #set module path mpath=\u0026#34;/usr/local/lib/opensips/modules/\u0026#34; #### SIGNALING module loadmodule \u0026#34;signaling.so\u0026#34; #### StateLess module loadmodule \u0026#34;sl.so\u0026#34; #### Transaction Module loadmodule \u0026#34;tm.so\u0026#34; modparam(\u0026#34;tm\u0026#34;, \u0026#34;fr_timeout\u0026#34;, 5) modparam(\u0026#34;tm\u0026#34;, \u0026#34;fr_inv_timeout\u0026#34;, 30) modparam(\u0026#34;tm\u0026#34;, \u0026#34;restart_fr_on_each_reply\u0026#34;, 0) modparam(\u0026#34;tm\u0026#34;, \u0026#34;onreply_avp_mode\u0026#34;, 1) #### Record Route Module loadmodule \u0026#34;rr.so\u0026#34; /* do not append from tag to the RR (no need for this script) */ modparam(\u0026#34;rr\u0026#34;, \u0026#34;append_fromtag\u0026#34;, 0) #### MAX ForWarD module loadmodule \u0026#34;maxfwd.so\u0026#34; #### SIP MSG OPerationS module loadmodule \u0026#34;sipmsgops.so\u0026#34; #### FIFO Management Interface loadmodule \u0026#34;mi_fifo.so\u0026#34; modparam(\u0026#34;mi_fifo\u0026#34;, \u0026#34;fifo_name\u0026#34;, \u0026#34;/run/opensips/opensips_fifo\u0026#34;) modparam(\u0026#34;mi_fifo\u0026#34;, \u0026#34;fifo_mode\u0026#34;, 0666) #### USeR LOCation module loadmodule \u0026#34;usrloc.so\u0026#34; modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;nat_bflag\u0026#34;, \u0026#34;NAT\u0026#34;) modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;working_mode_preset\u0026#34;, \u0026#34;single-instance-no-db\u0026#34;) #### REGISTRAR module loadmodule \u0026#34;registrar.so\u0026#34; modparam(\u0026#34;registrar\u0026#34;, \u0026#34;tcp_persistent_flag\u0026#34;, \u0026#34;TCP_PERSISTENT\u0026#34;) /* uncomment the next line not to allow more than 10 contacts per AOR */ #modparam(\u0026#34;registrar\u0026#34;, \u0026#34;max_contacts\u0026#34;, 10) #### ACCounting module loadmodule \u0026#34;acc.so\u0026#34; /* what special events should be accounted ? */ modparam(\u0026#34;acc\u0026#34;, \u0026#34;early_media\u0026#34;, 1) modparam(\u0026#34;acc\u0026#34;, \u0026#34;report_cancels\u0026#34;, 1) /* by default we do not adjust the direct of the sequential requests. if you enable this parameter, be sure to enable \u0026#34;append_fromtag\u0026#34; in \u0026#34;rr\u0026#34; module */ modparam(\u0026#34;acc\u0026#34;, \u0026#34;detect_direction\u0026#34;, 0) modparam(\u0026#34;acc\u0026#34;, \u0026#34;extra_fields\u0026#34;, \u0026#34;log: a-\u0026gt;$ci; b\u0026#34;) loadmodule \u0026#34;proto_udp.so\u0026#34; ####### Routing Logic ######## # main request routing logic route{ if (!mf_process_maxfwd_header(10)) { send_reply(483,\u0026#34;Too Many Hops\u0026#34;); exit; } if (has_totag()) { # handle hop-by-hop ACK (no routing required) if ( is_method(\u0026#34;ACK\u0026#34;) \u0026amp;\u0026amp; t_check_trans() ) { t_relay(); exit; } # sequential request within a dialog should # take the path determined by record-routing if ( !loose_route() ) { # we do record-routing for all our traffic, so we should not # receive any sequential requests without Route hdr. send_reply(404,\u0026#34;Not here\u0026#34;); exit; } if (is_method(\u0026#34;BYE\u0026#34;)) { # do accounting even if the transaction fails do_accounting(\u0026#34;log\u0026#34;,\u0026#34;failed\u0026#34;); } # route it out to whatever destination was set by loose_route() # in $du (destination URI). route(relay); exit; } # CANCEL processing if (is_method(\u0026#34;CANCEL\u0026#34;)) { if (t_check_trans()) t_relay(); exit; } # absorb retransmissions, but do not create transaction t_check_trans(); if ( !(is_method(\u0026#34;REGISTER\u0026#34;) ) ) { if (is_myself(\u0026#34;$fd\u0026#34;)) { } else { # if caller is not local, then called number must be local if (!is_myself(\u0026#34;$rd\u0026#34;)) { send_reply(403,\u0026#34;Relay Forbidden\u0026#34;); exit; } } } # preloaded route checking if (loose_route()) { xlog(\u0026#34;L_ERR\u0026#34;, \u0026#34;Attempt to route with preloaded Route\u0026#39;s [$fu/$tu/$ru/$ci]\u0026#34;); if (!is_method(\u0026#34;ACK\u0026#34;)) send_reply(403,\u0026#34;Preload Route denied\u0026#34;); exit; } # record routing if (!is_method(\u0026#34;REGISTER|MESSAGE\u0026#34;)) record_route(); # account only INVITEs if (is_method(\u0026#34;INVITE\u0026#34;)) { do_accounting(\u0026#34;log\u0026#34;); $acc_extra(a)=$ci; } if (!is_myself(\u0026#34;$rd\u0026#34;)) { append_hf(\u0026#34;P-hint: outbound\\r\\n\u0026#34;); route(relay); } # requests for my domain if (is_method(\u0026#34;PUBLISH|SUBSCRIBE\u0026#34;)) { send_reply(503, \u0026#34;Service Unavailable\u0026#34;); exit; } if (is_method(\u0026#34;REGISTER\u0026#34;)) { # store the registration and generate a SIP reply if (!save(\u0026#34;location\u0026#34;)) xlog(\u0026#34;failed to register AoR $tu\\n\u0026#34;); exit; } if ($rU==NULL) { # request with no Username in RURI send_reply(484,\u0026#34;Address Incomplete\u0026#34;); exit; } # do lookup with method filtering if (!lookup(\u0026#34;location\u0026#34;,\u0026#34;m\u0026#34;)) { t_reply(404, \u0026#34;Not Found\u0026#34;); exit; } # when routing via usrloc, log the missed calls also do_accounting(\u0026#34;log\u0026#34;,\u0026#34;missed\u0026#34;); route(relay); } route[relay] { # for INVITEs enable some additional helper routes if (is_method(\u0026#34;INVITE\u0026#34;)) { t_on_branch(\u0026#34;per_branch_ops\u0026#34;); t_on_reply(\u0026#34;handle_nat\u0026#34;); t_on_failure(\u0026#34;missed_call\u0026#34;); } if (!t_relay()) { send_reply(500,\u0026#34;Internal Error\u0026#34;); } exit; } branch_route[per_branch_ops] { xlog(\u0026#34;new branch at $ru\\n\u0026#34;); } onreply_route[handle_nat] { xlog(\u0026#34;incoming reply\\n\u0026#34;); } failure_route[missed_call] { if (t_was_cancelled()) { exit; } # uncomment the following lines if you want to block client # redirect based on 3xx replies. ##if (t_check_status(\u0026#34;3[0-9][0-9]\u0026#34;)) { ##t_reply(404,\u0026#34;Not found\u0026#34;); ##\texit; ##} } 配置文件解析：\nmodparam(\u0026quot;acc\u0026quot;, \u0026quot;extra_fields\u0026quot;, \u0026quot;log: a-\u0026gt;$ci; b\u0026quot;), 这里只是定义了a的key为$ci, 要使用$acc_extra(a)来设置value。通过这种方式，我们可以设置一些额外的参数输出到日志中。\n输出的结果 正常接通挂断 sip信令图: syslog输出:\n1 2 3 4 5 6 7 May 13 10:07:20 [349] [130][23d4df0d6efe4cd481a6f4e29ca82f9b]---main--:INVITE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 10:07:22 [352] ACC: transaction answered: timestamp=1747102042;created=0;setuptime=1747102042;method=INVITE;from_tag=e2ff73efbd8242208c88592bda1d8d02;to_tag=06127b55;call_id=23d4df0d6efe4cd481a6f4e29ca82f9b;code=200;reason=OK;$ci=23d4df0d6efe4cd481a6f4e29ca82f9b;b= May 13 10:07:22 [352] [130][23d4df0d6efe4cd481a6f4e29ca82f9b]---main--:ACK|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 10:07:22 [351] [130][23d4df0d6efe4cd481a6f4e29ca82f9b]---main--:INVITE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 10:07:22 [352] [130][23d4df0d6efe4cd481a6f4e29ca82f9b]---main--:ACK|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 10:07:24 [353] [130][23d4df0d6efe4cd481a6f4e29ca82f9b]---main--:BYE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 10:07:24 [351] ACC: transaction answered: timestamp=1747102044;created=0;setuptime=1747102044;method=BYE;from_tag=e2ff73efbd8242208c88592bda1d8d02;to_tag=06127b55;call_id=23d4df0d6efe4cd481a6f4e29ca82f9b;code=200;reason=OK;$ci=;b= 使用官方的配置，可以看到只有两个记录了INVITE和BYE，没有响铃。另外,在BYE时，$acc_extra(a)的值为空。\n现在修改INVITE处的do_accounting(\u0026quot;log\u0026quot;);为do_accounting(\u0026quot;log\u0026quot;, \u0026quot;cdr|missed|failed\u0026quot;);,再次测试,syslog输出如下:\n1 2 3 4 5 6 7 May 13 10:36:06 [535] NOTICE:signaling:mod_init: initializing module ... May 13 10:36:14 [550] [132][ec40d522330f4171866f26f9bd1a1499]---main--:INVITE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 10:36:15 [550] [132][ec40d522330f4171866f26f9bd1a1499]---main--:ACK|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 10:36:15 [550] [132][ec40d522330f4171866f26f9bd1a1499]---main--:INVITE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 10:36:15 [550] [132][ec40d522330f4171866f26f9bd1a1499]---main--:ACK|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 10:36:17 [550] [132][ec40d522330f4171866f26f9bd1a1499]---main--:BYE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 10:36:17 [553] ACC: call ended: created=1747103774;call_start_time=1747103775;duration=3;ms_duration=2455;setuptime=1;method=INVITE;from_tag=82c34d97660b4e6fb6c1d8ccf04c194d;to_tag=7f0a2548;call_id=ec40d522330f4171866f26f9bd1a1499;code=200;reason=OK;$ci=ec40d522330f4171866f26f9bd1a1499;b= 只有一个记录，但是带了其他信息：call_start_time:电话接通的时间戳、duration:通话时长s、ms_duration:通话时长ms,setuptime:电话建立的时间，可以认为是响铃时长s,created:此记录开始的时间.\n未接电话 sip信令图: syslog输出:\n1 2 3 4 May 13 10:50:51 [622] [132][67abdb49d25f4d579670b78b56d4f0a3]---main--:INVITE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 10:50:52 [622] ACC: call missed: timestamp=1747104652;created=1747104651;setuptime=1;method=INVITE;from_tag=2cf172b645e04628a1ace902e877512b;to_tag=7f10ee66;call_id=67abdb49d25f4d579670b78b56d4f0a3;code=480;reason=Temporarily Unavailable;$ci=67abdb49d25f4d579670b78b56d4f0a3;b= May 13 10:50:52 [622] [312][67abdb49d25f4d579670b78b56d4f0a3]---missed_call----:INVITE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261 May 13 10:50:52 [622] [132][67abdb49d25f4d579670b78b56d4f0a3]---main--:ACK|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; 可以看到记录了missed_call\n主叫CANCEL sip信令图: syslog输出:\n1 2 3 4 May 13 10:57:39 [685] [132][7b53a5cf8c9741db9eccc429e719a7b1]---main--:CANCEL|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 10:57:39 [686] ACC: call missed: timestamp=1747105059;created=1747105057;setuptime=2;method=INVITE;from_tag=52d3da242e4f47e0ab21cbb95afc715c;to_tag=8f3e627c;call_id=7b53a5cf8c9741db9eccc429e719a7b1;code=487;reason=Request Terminated;$ci=7b53a5cf8c9741db9eccc429e719a7b1;b= May 13 10:57:39 [686] [312][7b53a5cf8c9741db9eccc429e719a7b1]---missed_call----:INVITE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261 May 13 10:57:39 [685] [132][7b53a5cf8c9741db9eccc429e719a7b1]---main--:ACK|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; 可以看到记录了missed_call, 但是应该是487信令的，而不是CANCEL.\n输出到数据库 配置文件 在syslog输出的基础上，修改配置文件：\n1 2 modparam(\u0026#34;acc\u0026#34;, \u0026#34;extra_fields\u0026#34;, \u0026#34;log: a-\u0026gt;$ci; b\u0026#34;) modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_url\u0026#34;, \u0026#34;DBURL\u0026#34;) 把所有的do_accounting(\u0026quot;log\u0026quot;,\u0026quot;xxx\u0026quot;)改成do_accounting(\u0026quot;log|db\u0026quot;,\u0026quot;xxx\u0026quot;),再次测试。\n输出的结果 正常接通挂断 数据表记录: 相对于kamailio,opensips的数据库记录更加详细,把CDR的信息一起记录到了acc表。\n未接电话 数据表记录: 数据记录在missed_call表\n主叫CANCEL 数据表记录: 数据记录在missed_call表\n输出到EVENTS 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 loadmodule \u0026#34;event_route.so\u0026#34; ... event_route[E_ACC_CDR]{ xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line]---event_route[E_ACC_CDR]----:$param(method)|$param(from_tag)|$param(to_tag)|$param(callid)|$param(sip_code)|$param(sip_reason)|$param(time)|$param(duration)|$param(ms_duration)|$param(created)|$param(setuptime)\\n\u0026#34;); } event_route[E_ACC_EVENT]{ xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line]---event_route[E_ACC_EVENT]----:$param(method)|$param(from_tag)|$param(to_tag)|$param(callid)|$param(sip_code)|$param(sip_reason)|$param(time)\\n\u0026#34;); } event_route[E_ACC_MISSED_EVENT]{ xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line]---event_route[E_ACC_MISSED_EVENT]----:$param(method)|$param(from_tag)|$param(to_tag)|$param(callid)|$param(sip_code)|$param(sip_reason)|$param(time)|$param(created)|$param(setuptime)\\n\u0026#34;); } 把do_accounting(\u0026quot;log|db\u0026quot;,\u0026quot;xxxx\u0026quot;); 全部替换为do_accounting(\u0026quot;log|db|evi\u0026quot;,\u0026quot;xxxx\u0026quot;);\n输出结果 正常接通挂断 event_route输出:\n1 2 3 4 5 6 7 May 13 11:42:32 [959] [137][8b8ae3d6728a4b04bf6875f005730039]---main--:INVITE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 11:42:33 [959] [137][8b8ae3d6728a4b04bf6875f005730039]---main--:ACK|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 11:42:33 [961] [137][8b8ae3d6728a4b04bf6875f005730039]---main--:INVITE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 11:42:34 [957] [137][8b8ae3d6728a4b04bf6875f005730039]---main--:ACK|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 11:42:36 [959] [137][8b8ae3d6728a4b04bf6875f005730039]---main--:BYE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 11:42:36 [959] ACC: call ended: created=1747107752;call_start_time=1747107753;duration=3;ms_duration=2446;setuptime=1;method=INVITE;from_tag=5af280175d2f4bb8b32d883e3286cc4a;to_tag=897c787b;call_id=8b8ae3d6728a4b04bf6875f005730039;code=200;reason=OK;$ci=8b8ae3d6728a4b04bf6875f005730039;b= May 13 11:42:36 [957] [333]---event_route[E_ACC_CDR]----:INVITE|5af280175d2f4bb8b32d883e3286cc4a|897c787b|8b8ae3d6728a4b04bf6875f005730039|200|OK|1747107753|3|2446|1747107752|1 可以看到在E_ACC_CDR的信息和syslog的一致.\n未接电话 event_route输出:\n1 2 3 4 5 May 13 11:45:40 [959] [137][cfb5b5aa7a4f4ed081ced6764ae58867]---main--:INVITE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 11:45:43 [959] [343]---event_route[E_ACC_MISSED_EVENT]----:INVITE|67c43acbbb68485e8437d660ab210df3|ba1cbf25|cfb5b5aa7a4f4ed081ced6764ae58867|480|Temporarily Unavailable|1747107943|1747107940|3 May 13 11:45:43 [958] ACC: call missed: timestamp=1747107943;created=1747107940;setuptime=3;method=INVITE;from_tag=67c43acbbb68485e8437d660ab210df3;to_tag=ba1cbf25;call_id=cfb5b5aa7a4f4ed081ced6764ae58867;code=480;reason=Temporarily Unavailable;$ci=cfb5b5aa7a4f4ed081ced6764ae58867;b= May 13 11:45:43 [958] [317][cfb5b5aa7a4f4ed081ced6764ae58867]---missed_call----:INVITE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261 May 13 11:45:43 [957] [137][cfb5b5aa7a4f4ed081ced6764ae58867]---main--:ACK|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; 可以看到数据输出到E_ACC_MISSED_EVENT, 在E_ACC_MISSED_EVENT的信息和syslog的一致.\n主叫CANCEL event_route输出:\n1 2 3 4 5 6 May 13 11:46:47 [958] [137][df003e31dace43b298e30ef175d99343]---main--:INVITE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 11:46:48 [957] [137][df003e31dace43b298e30ef175d99343]---main--:CANCEL|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; May 13 11:46:49 [957] [343]---event_route[E_ACC_MISSED_EVENT]----:INVITE|bd65219bbfb74f5a859fca3126483d6e|e11fff0b|df003e31dace43b298e30ef175d99343|487|Request Terminated|1747108009|1747108007|2 May 13 11:46:49 [960] ACC: call missed: timestamp=1747108009;created=1747108007;setuptime=2;method=INVITE;from_tag=bd65219bbfb74f5a859fca3126483d6e;to_tag=e11fff0b;call_id=df003e31dace43b298e30ef175d99343;code=487;reason=Request Terminated;$ci=df003e31dace43b298e30ef175d99343;b= May 13 11:46:49 [960] [317][df003e31dace43b298e30ef175d99343]---missed_call----:INVITE|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261 May 13 11:46:49 [957] [137][df003e31dace43b298e30ef175d99343]---main--:ACK|\u0026lt;null\u0026gt;|sip:1009@172.16.4.111|5261|\u0026lt;null\u0026gt; 可以看到数据输出到E_ACC_MISSED_EVENT, 在E_ACC_MISSED_EVENT的信息和syslog的一致.\n总结 opensips的extra_fields设置没有kamailio的方便。 180响铃,opensips和kamailio一样，都未上报，183可能会上报。 使用数据库时，opensips只用到两个表，kamailio用到了三个表。 opensips的上报方式更丰富些. ","date":"2025-05-13T13:01:51+08:00","image":"https://QuincyGao.github.io/p/opensips-acc%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/backup_hu7415644743634218858.jpg","permalink":"https://QuincyGao.github.io/p/opensips-acc%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","title":"opensips acc模块介绍"},{"content":"背景 acc 模块用来记录会话信息到syslog或者数据库中，最小的记录信息包括:\n请求method From 头的tag To 头的tag Call-ID 响应的code 响应的reason 会话完成的时间戳 官方文档地址: acc,本次测试的kamailio版本是:\nversion: kamailio 5.8.5 (x86_64/linux)\n重要参数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # 响铃事件是否记录,默认是0, 0:不记录, 1:记录 modparam(\u0026#34;acc\u0026#34;, \u0026#34;early_media\u0026#34;, 1) # 当整个会话失败后记录的标志,默认不设置。 modparam(\u0026#34;acc\u0026#34;, \u0026#34;failed_transaction_flag\u0026#34;, 4) # 失败的响应码不记录,默认不设置,区间是[300,999] modparam(\u0026#34;acc\u0026#34;, \u0026#34;failed_filter\u0026#34;, \u0026#34;404,407\u0026#34;) # 是否记录ACK,默认是0, 0:不记录, 1:记录 modparam(\u0026#34;acc\u0026#34;, \u0026#34;report_ack\u0026#34;, 1) # 是否记录CANCEL,默认是0, 0:不记录, 1:记录 modparam(\u0026#34;acc\u0026#34;, \u0026#34;report_cancels\u0026#34;, 1) # 控制检查请求方向 modparam(\u0026#34;acc\u0026#34;, \u0026#34;detect_direction\u0026#34;, 1) # 是否事务记录延后标志 modparam(\u0026#34;acc\u0026#34;, \u0026#34;acc_prepare_flag\u0026#34;, 5) # 所有的请求事务延后标记的标志 modparam(\u0026#34;acc\u0026#34;, \u0026#34;acc_prepare_always\u0026#34;, 1) # 设置为1, 表acc中的extra字段如果没值会被设置成NULL;设置为0,该字段为空. modparam(\u0026#34;acc\u0026#34;, \u0026#34;acc_extra_nullable\u0026#34;, 1) # 是否通过syslog记录事务标志,默认是不设置,其他:记录 modparam(\u0026#34;acc\u0026#34;, \u0026#34;log_flag\u0026#34;, 2) # 是否通过syslog记录未接来电标志,默认是不设置,其他:记录 modparam(\u0026#34;acc\u0026#34;, \u0026#34;log_missed_flag\u0026#34;, 3) # 输出到syslog的日志等级 modparam(\u0026#34;acc\u0026#34;, \u0026#34;log_level\u0026#34;, 2) # Set log_level to 2 (L_INFO) # 存到数据库的标志 modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_flag\u0026#34;, 2) # 未接来电存储数据库的标志 modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_missed_flag\u0026#34;, 3) # 成功拨打电话存储的数据表名,默认是acc modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_table_acc\u0026#34;, \u0026#34;acc\u0026#34;) # 未接电话存储的数据表名,默认是missed_calls modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_table_missed_calls\u0026#34;, \u0026#34;missed_calls\u0026#34;) # 数据库连接地址 modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_url\u0026#34;, \u0026#34;DBURL\u0026#34;) # 1,INSERT DELAYED; 2,ASYNC INSERT; 0,INSERT modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_insert_mode\u0026#34;, 1) # 是否开启cdr功能,记录数据到acc_cdrs表 modparam(\u0026#34;acc\u0026#34;, \u0026#34;cdr_enable\u0026#34;, 1) # dialog过期,是否打印CDR-based modparam(\u0026#34;acc\u0026#34;, \u0026#34;cdr_expired_dlg_enable\u0026#34;, 1) # 开始计算时间从dialog创建还是接通? 0:dialog创建, 1:接通 modparam(\u0026#34;acc\u0026#34;, \u0026#34;cdr_start_on_confirmed\u0026#34;, 1) # 是否打印CDR-based到syslog,默认1,打印。0:不打印 modparam(\u0026#34;acc\u0026#34;, \u0026#34;cdr_log_enable\u0026#34;, 0) # 存储CDRs的表名,默认为\u0026#34;\u0026#34;,即不存储到数据库 modparam(\u0026#34;acc\u0026#34;, \u0026#34;cdrs_table\u0026#34;, \u0026#34;acc_cdrs\u0026#34;) # 设置时间的模式 默认0, # 0:保存unix时间戳到syslog, datetime到数据库; # 1:保存second到time_attr,microseconds到time_exten. # 2:保存second.milliseconds到time_attr # 3:保存格式化的时间到time_format,使用localtime()输出 # 4:保存格式化的时间到time_format,使用gmtime()输出 modparam(\u0026#34;acc\u0026#34;, \u0026#34;time_mode\u0026#34;, 1) # 命名syslog的attribute和数据库存储attribute值的时间事件 modparam(\u0026#34;acc\u0026#34;, \u0026#34;time_attr\u0026#34;, \u0026#34;seconds\u0026#34;) ... 重要函数 acc_log_request(comment) 主动上报请求到syslog,可以用在ANY_ROUTE中\nacc_db_request(comment, table) 主动上报请求到数据库,可以用在ANY_ROUTE中\nacc_request(comment, table) 主动上报请求到syslog和数据库,如果db_url没有设置，那么就输出到日志.可以用在ANY_ROUTE中\n实战 输出到日志 官方的示例配置基本上都是输出到日志,这里做一些简单的修改。\n配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #!define FLT_ACC 1 #!define FLT_ACCMISSED 2 #!define FLT_ACCFAILED 3 #!define FLT_NATS 5 loadmodule \u0026#34;dialog.so\u0026#34; loadmodule \u0026#34;acc.so\u0026#34; modparam(\u0026#34;acc\u0026#34;, \u0026#34;early_media\u0026#34;, 0) modparam(\u0026#34;acc\u0026#34;, \u0026#34;report_ack\u0026#34;, 0) modparam(\u0026#34;acc\u0026#34;, \u0026#34;report_cancels\u0026#34;, 0) /* by default we do not adjust the direct of the sequential requests. * if you enable this parameter, be sure the enable \u0026#34;append_fromtag\u0026#34; * in \u0026#34;rr\u0026#34; module */ modparam(\u0026#34;acc\u0026#34;, \u0026#34;detect_direction\u0026#34;, 0) /* account triggers (flags) */ modparam(\u0026#34;acc\u0026#34;, \u0026#34;log_flag\u0026#34;, FLT_ACC) modparam(\u0026#34;acc\u0026#34;, \u0026#34;log_missed_flag\u0026#34;, FLT_ACCMISSED) modparam(\u0026#34;acc\u0026#34;, \u0026#34;log_extra\u0026#34;, \u0026#34;src_user=$fU;src_domain=$fd;src_ip=$si;\u0026#34; \u0026#34;dst_ouser=$tU;dst_user=$rU;dst_domain=$rd\u0026#34;) modparam(\u0026#34;acc\u0026#34;, \u0026#34;failed_transaction_flag\u0026#34;, FLT_ACCFAILED) #!ifdef WITH_ACCDB modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_flag\u0026#34;, FLT_ACC) modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_missed_flag\u0026#34;, FLT_ACCMISSED) modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_extra\u0026#34;, \u0026#34;src_user=$fU;src_domain=$fd;src_ip=$si;\u0026#34; \u0026#34;dst_ouser=$tU;dst_user=$rU;dst_domain=$rd\u0026#34;) #!endif request_route { xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;$si:$sp|$Ri:$Rp|$pr|$rm\\n\u0026#34;); ... route(WITHINDLG); route(AUTH); if(is_method(\u0026#34;INVITE\u0026#34;)) { dlg_manage(); setflag(FLT_ACC); } ... route(LOCATION); return; } route[WITHINDLG] { if (!has_totag()) return; if (loose_route()) { route(DLGURI); if (is_method(\u0026#34;BYE\u0026#34;)) { setflag(FLT_ACC); setflag(FLT_ACCFAILED); } else if ( is_method(\u0026#34;ACK)) { route(NATMANAGE); } else if (is_method(\u0026#34;NOTIFY|REFER\u0026#34;)) { record_route(); } route(RELAY); exit; } ... } route[LOCATION] { if (!lookup(\u0026#34;location\u0026#34;)) { ... } if (is_method(\u0026#34;INVITE\u0026#34;)) { setflag(FLT_ACCMISSED); } route(RELAY); exit; } 官方配置解析：\nFLT_ACC: 表示记录成功的请求,在第一次收到INVITE请求和BYE时设置。 FLT_ACCMISSED: 表示记录未接来电,在LOCATION路由中设置。 FLT_ACCFAILED: 表示记录失败的请求,在BYE请求时设置。 输出的结果 正常接通挂断 sip信令图: 日志输出内容：\n1 2 3 4 5 6 7 (234) INFO: |25-05-09 13:37:17|2bc344935b9f4996abde8a19388967af| \u0026lt;script\u0026gt;: 172.16.80.13:62759|172.16.4.111:5460|udp|INVITE 5(237) NOTICE: |25-05-09 13:37:19|2bc344935b9f4996abde8a19388967af| acc [acc.c:288]: acc_log_request(): ACC: transaction answered: timestamp=1746769039;method=INVITE;from_tag=7c34d89688d9462ba511a1bdb2d21295;to_tag=e43d4609;call_id=2bc344935b9f4996abde8a19388967af;code=200;reason=OK;src_user=1004;src_domain=172.16.4.111;src_ip=172.16.80.13;dst_ouser=1009;dst_user=1009;dst_domain=172.16.80.13 6(238) INFO: |25-05-09 13:37:19|2bc344935b9f4996abde8a19388967af| \u0026lt;script\u0026gt;: 172.16.80.13:62759|172.16.4.111:5460|udp|ACK 1(233) INFO: |25-05-09 13:37:19|2bc344935b9f4996abde8a19388967af| \u0026lt;script\u0026gt;: 172.16.80.13:62759|172.16.4.111:5460|udp|INVITE 8(240) INFO: |25-05-09 13:37:19|2bc344935b9f4996abde8a19388967af| \u0026lt;script\u0026gt;: 172.16.80.13:62759|172.16.4.111:5460|udp|ACK 3(235) INFO: |25-05-09 13:37:25|2bc344935b9f4996abde8a19388967af| \u0026lt;script\u0026gt;: 172.16.80.13:62759|172.16.4.111:5460|udp|BYE 2(234) NOTICE: |25-05-09 13:37:25|2bc344935b9f4996abde8a19388967af| acc [acc.c:288]: acc_log_request(): ACC: transaction answered: timestamp=1746769045;method=BYE;from_tag=7c34d89688d9462ba511a1bdb2d21295;to_tag=e43d4609;call_id=2bc344935b9f4996abde8a19388967af;code=200;reason=OK;src_user=1004;src_domain=172.16.4.111;src_ip=172.16.80.13;dst_ouser=1009;dst_user=1009;dst_domain=172.16.80.13 可以看到acc_log_request有INVITE和BYE两条记录,分别表示接通时和挂断时的信息。\n被叫未接挂断 sip信令图: 日志输出内容：\n1 2 3 4 1(233) INFO: |25-05-09 13:49:54|e9c569bdad5c48829b9554b501e193de| \u0026lt;script\u0026gt;: 172.16.80.13:62759|172.16.4.111:5460|udp|INVITE 7(239) NOTICE: |25-05-09 13:49:57|e9c569bdad5c48829b9554b501e193de| acc [acc.c:288]: acc_log_request(): ACC: call missed: timestamp=1746769797;method=INVITE;from_tag=0dcc6761a39f4e0ea7c665f374c3c0b4;to_tag=fc7fe45d;call_id=e9c569bdad5c48829b9554b501e193de;code=480;reason=Temporarily Unavailable;src_user=1004;src_domain=172.16.4.111;src_ip=172.16.80.13;dst_ouser=1009;dst_user=1009;dst_domain=172.16.80.13 8(240) INFO: |25-05-09 13:49:57|e9c569bdad5c48829b9554b501e193de| \u0026lt;script\u0026gt;: 172.16.80.13:62759|172.16.4.111:5460|udp|ACK 6(238) INFO: |25-05-09 13:50:40|39a979acab324160b76e70dda10bdcf9| \u0026lt;script\u0026gt;: 172.16.80.13:62759|172.16.4.111:5460|udp|REGISTER acc_log_request打印了被叫挂断时的信息。\n主叫CANCEL sip信令图: 日志输出内容：\n1 2 3 4 3(235) INFO: |25-05-09 13:57:51|eb0b9b1788994cad83d720f4bd91b1e9| \u0026lt;script\u0026gt;: 172.16.80.13:62759|172.16.4.111:5460|udp|INVITE 1(233) INFO: |25-05-09 13:57:55|eb0b9b1788994cad83d720f4bd91b1e9| \u0026lt;script\u0026gt;: 172.16.80.13:62759|172.16.4.111:5460|udp|CANCEL 6(238) NOTICE: |25-05-09 13:57:55|eb0b9b1788994cad83d720f4bd91b1e9| acc [acc.c:288]: acc_log_request(): ACC: call missed: timestamp=1746770275;method=INVITE;from_tag=eb2b4f6fedae413da47d27b7561b6a16;to_tag=ef67ee5d;call_id=eb0b9b1788994cad83d720f4bd91b1e9;code=487;reason=Request Terminated;src_user=1004;src_domain=172.16.4.111;src_ip=172.16.80.13;dst_ouser=1009;dst_user=1009;dst_domain=172.16.80.13 7(239) INFO: |25-05-09 13:57:55|eb0b9b1788994cad83d720f4bd91b1e9| \u0026lt;script\u0026gt;: 172.16.80.13:62759|172.16.4.111:5460|udp|ACK acc_log_request打印了一些信息，method是INVITE,确认是487这个响应产生的，也就是miss_calls.\n上报完整数据 配置放开:\n1 2 3 4 modparam(\u0026#34;acc\u0026#34;, \u0026#34;early_media\u0026#34;, 1) modparam(\u0026#34;acc\u0026#34;, \u0026#34;report_ack\u0026#34;, 1) modparam(\u0026#34;acc\u0026#34;, \u0026#34;report_cancels\u0026#34;, 1) modparam(\u0026#34;acc\u0026#34;, \u0026#34;cdr_enable\u0026#34;, 1) 被叫接通挂断： sip 信令图： 日志输出内容：\n1 2 3 4 5 6 7 8 9 1(348) INFO: |25-05-09 14:10:28|3f0f993e4f04443ab3db388d52eb09e4| \u0026lt;script\u0026gt;: 172.16.80.13:62759|172.16.4.111:5460|udp|INVITE 8(355) NOTICE: |25-05-09 14:10:36|3f0f993e4f04443ab3db388d52eb09e4| acc [acc.c:288]: acc_log_request(): ACC: transaction answered: timestamp=1746771036;method=INVITE;from_tag=477742ca66494db89925be1add2d306d;to_tag=4758cb30;call_id=3f0f993e4f04443ab3db388d52eb09e4;code=200;reason=OK;src_user=1004;src_domain=172.16.4.111;src_ip=172.16.80.13;dst_ouser=1009;dst_user=1009;dst_domain=172.16.80.13 7(354) INFO: |25-05-09 14:10:36|3f0f993e4f04443ab3db388d52eb09e4| \u0026lt;script\u0026gt;: 172.16.80.13:62759|172.16.4.111:5460|udp|ACK 2(349) INFO: |25-05-09 14:10:36|3f0f993e4f04443ab3db388d52eb09e4| \u0026lt;script\u0026gt;: 172.16.80.13:62759|172.16.4.111:5460|udp|INVITE 7(354) NOTICE: |25-05-09 14:10:36|3f0f993e4f04443ab3db388d52eb09e4| acc [acc.c:288]: acc_log_request(): ACC: request acknowledged: timestamp=1746771036;method=ACK;from_tag=477742ca66494db89925be1add2d306d;to_tag=4758cb30;call_id=3f0f993e4f04443ab3db388d52eb09e4;code=200;reason=OK;src_user=1004;src_domain=172.16.4.111;src_ip=172.16.80.13;dst_ouser=1009;dst_user=1009;dst_domain=172.16.80.13 4(351) INFO: |25-05-09 14:10:36|3f0f993e4f04443ab3db388d52eb09e4| \u0026lt;script\u0026gt;: 172.16.80.13:62759|172.16.4.111:5460|udp|ACK 1(348) INFO: |25-05-09 14:10:46|3f0f993e4f04443ab3db388d52eb09e4| \u0026lt;script\u0026gt;: 172.16.80.13:35030|172.16.4.111:5460|udp|BYE 6(353) NOTICE: |25-05-09 14:10:46|3f0f993e4f04443ab3db388d52eb09e4| acc [acc.c:288]: acc_log_request(): ACC: transaction answered: timestamp=1746771046;method=BYE;from_tag=477742ca66494db89925be1add2d306d;to_tag=4758cb30;call_id=3f0f993e4f04443ab3db388d52eb09e4;code=200;reason=OK;src_user=1009;src_domain=172.16.4.111;src_ip=172.16.80.13;dst_ouser=1004;dst_user=1004;dst_domain=172.16.80.13 6(353) NOTICE: |25-05-09 14:10:46|3f0f993e4f04443ab3db388d52eb09e4| acc [acc_cdr.c:371]: log_write_cdr(): start_time=1746771028.010; end_time=1746771046.351; duration=18.341 可以看到有4个事件被记录了:\n被叫坐席接通200OK ACK 主叫BYE时 打印CDR 目前来看,180响铃这个上报没生效。\n主叫CANCEL: sip 信令图： 日志输出内容：\n1 2 3 4 5 5(352) INFO: |25-05-09 14:25:55|NmU5MmY1ZTVmMjE4MzZiODVjOGQ2NWNhMWI2ODY4Mzc.| \u0026lt;script\u0026gt;: 172.16.80.13:35030|172.16.4.111:5460|udp|INVITE 8(355) INFO: |25-05-09 14:26:00|NmU5MmY1ZTVmMjE4MzZiODVjOGQ2NWNhMWI2ODY4Mzc.| \u0026lt;script\u0026gt;: 172.16.80.13:35030|172.16.4.111:5460|udp|CANCEL 2(349) NOTICE: |25-05-09 14:26:00|NmU5MmY1ZTVmMjE4MzZiODVjOGQ2NWNhMWI2ODY4Mzc.| acc [acc.c:288]: acc_log_request(): ACC: call missed: timestamp=1746771960;method=INVITE;from_tag=9e3d6277;to_tag=f6895a68c2a1431884fa58987098321f;call_id=NmU5MmY1ZTVmMjE4MzZiODVjOGQ2NWNhMWI2ODY4Mzc.;code=487;reason=Request Terminated;src_user=1009;src_domain=172.16.4.111;src_ip=172.16.80.13;dst_ouser=1004;dst_user=1004;dst_domain=172.16.80.13 2(349) NOTICE: acc [acc_cdr.c:371]: log_write_cdr(): start_time=1746771955.753; end_time=1746771955.753; duration=0 3(350) INFO: |25-05-09 14:26:00|NmU5MmY1ZTVmMjE4MzZiODVjOGQ2NWNhMWI2ODY4Mzc.| \u0026lt;script\u0026gt;: 172.16.80.13:35030|172.16.4.111:5460|udp|ACK CANCEL这个事件上报没生效， 在request_route中,添加以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 ... route(NATDETECT); if (is_method(\u0026#34;CANCEL\u0026#34;)) { xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;is cancel.\\n\u0026#34;); setflag(FLT_ACC); if (t_check_trans()) { route(RELAY); } exit; } if (!is_method(\u0026#34;ACK\u0026#34;)) { ... } 日志输出内容：\n1 2 3 4 5 6 7 1(623) INFO: |25-05-09 14:48:23|NDBlOTdhZThmNDdiNjZiZWY1NjAxNWY4MzQxNmE0MDc.| \u0026lt;script\u0026gt;: ------172.16.80.13:1352|172.16.4.111:5460|udp|INVITE 8(630) INFO: |25-05-09 14:48:26|NDBlOTdhZThmNDdiNjZiZWY1NjAxNWY4MzQxNmE0MDc.| \u0026lt;script\u0026gt;: ------172.16.80.13:1352|172.16.4.111:5460|udp|CANCEL 8(630) INFO: |25-05-09 14:48:26|NDBlOTdhZThmNDdiNjZiZWY1NjAxNWY4MzQxNmE0MDc.| \u0026lt;script\u0026gt;: is cancel. 8(630) NOTICE: |25-05-09 14:48:26|NDBlOTdhZThmNDdiNjZiZWY1NjAxNWY4MzQxNmE0MDc.| acc [acc.c:288]: acc_log_request(): ACC: transaction answered: timestamp=1746773306;method=CANCEL;from_tag=e50e6473;to_tag=;call_id=NDBlOTdhZThmNDdiNjZiZWY1NjAxNWY4MzQxNmE0MDc.;code=200;reason=OK;src_user=1009;src_domain=172.16.4.111;src_ip=172.16.80.13;dst_ouser=1004;dst_user=1004;dst_domain=172.16.4.111 3(625) NOTICE: |25-05-09 14:48:26|NDBlOTdhZThmNDdiNjZiZWY1NjAxNWY4MzQxNmE0MDc.| acc [acc.c:288]: acc_log_request(): ACC: call missed: timestamp=1746773306;method=INVITE;from_tag=e50e6473;to_tag=6dc3d5effba74226bb9212dbb7f2452b;call_id=NDBlOTdhZThmNDdiNjZiZWY1NjAxNWY4MzQxNmE0MDc.;code=487;reason=Request Terminated;src_user=1009;src_domain=172.16.4.111;src_ip=172.16.80.13;dst_ouser=1004;dst_user=1004;dst_domain=172.16.80.13 3(625) NOTICE: acc [acc_cdr.c:371]: log_write_cdr(): start_time=1746773303.836; end_time=1746773303.836; duration=0 4(626) INFO: |25-05-09 14:48:26|NDBlOTdhZThmNDdiNjZiZWY1NjAxNWY4MzQxNmE0MDc.| \u0026lt;script\u0026gt;: ------172.16.80.13:1352|172.16.4.111:5460|udp|ACK 可以看到CANCEL事件上报生效了。\n所以如果想上报CANCEL,需要两个条件：\nreport_cancels=1 主路由中在方法为CANCEL的地方，添加setflag(FLT_ACC) 输出到数据库 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #!define WITH_ACCDB #!define FLT_ACC 1 #!define FLT_ACCMISSED 2 #!define FLT_ACCFAILED 3 #!define FLT_NATS 5 loadmodule \u0026#34;dialog.so\u0026#34; loadmodule \u0026#34;acc.so\u0026#34; modparam(\u0026#34;acc\u0026#34;, \u0026#34;early_media\u0026#34;, 1) modparam(\u0026#34;acc\u0026#34;, \u0026#34;report_ack\u0026#34;, 1) modparam(\u0026#34;acc\u0026#34;, \u0026#34;report_cancels\u0026#34;, 1) /* by default we do not adjust the direct of the sequential requests. * if you enable this parameter, be sure the enable \u0026#34;append_fromtag\u0026#34; * in \u0026#34;rr\u0026#34; module */ modparam(\u0026#34;acc\u0026#34;, \u0026#34;detect_direction\u0026#34;, 0) modparam(\u0026#34;acc\u0026#34;, \u0026#34;cdr_enable\u0026#34;, 1) /* account triggers (flags) */ modparam(\u0026#34;acc\u0026#34;, \u0026#34;log_flag\u0026#34;, FLT_ACC) modparam(\u0026#34;acc\u0026#34;, \u0026#34;log_missed_flag\u0026#34;, FLT_ACCMISSED) modparam(\u0026#34;acc\u0026#34;, \u0026#34;log_extra\u0026#34;, \u0026#34;src_user=$fU;src_domain=$fd;src_ip=$si;\u0026#34; \u0026#34;dst_ouser=$tU;dst_user=$rU;dst_domain=$rd\u0026#34;) modparam(\u0026#34;acc\u0026#34;, \u0026#34;failed_transaction_flag\u0026#34;, FLT_ACCFAILED) #!ifdef WITH_ACCDB modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_flag\u0026#34;, FLT_ACC) modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_missed_flag\u0026#34;, FLT_ACCMISSED) modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;acc\u0026#34;, \u0026#34;db_extra\u0026#34;, \u0026#34;src_user=$fU;src_domain=$fd;src_ip=$si;\u0026#34; \u0026#34;dst_ouser=$tU;dst_user=$rU;dst_domain=$rd\u0026#34;) modparam(\u0026#34;acc\u0026#34;, \u0026#34;cdrs_table\u0026#34;, \u0026#34;acc_cdrs\u0026#34;) #!endif request_route { xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;$si:$sp|$Ri:$Rp|$pr|$rm\\n\u0026#34;); ... if (is_method(\u0026#34;CANCEL\u0026#34;)) { xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;is cancel.\\n\u0026#34;); setflag(FLT_ACC); if (t_check_trans()) { route(RELAY); } exit; } route(WITHINDLG); route(AUTH); if(is_method(\u0026#34;INVITE\u0026#34;)) { dlg_manage(); setflag(FLT_ACC); } ... route(LOCATION); return; } route[WITHINDLG] { if (!has_totag()) return; if (loose_route()) { route(DLGURI); if (is_method(\u0026#34;BYE\u0026#34;)) { setflag(FLT_ACC); setflag(FLT_ACCFAILED); } else if ( is_method(\u0026#34;ACK)) { route(NATMANAGE); } else if (is_method(\u0026#34;NOTIFY|REFER\u0026#34;)) { record_route(); } route(RELAY); exit; } ... } route[LOCATION] { if (!lookup(\u0026#34;location\u0026#34;)) { ... } if (is_method(\u0026#34;INVITE\u0026#34;)) { setflag(FLT_ACCMISSED); } route(RELAY); exit; } 目前因为是测试，所以输出到syslog不去掉，在测试过程中会既打印日志又写数据库.\n在运行之前，还要手动为表添加一些字段：\n1 2 3 4 5 6 7 8 9 10 11 12 ALTER TABLE acc ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE acc ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE acc ADD COLUMN src_ip varchar(64) NOT NULL default \u0026#39;\u0026#39;; ALTER TABLE acc ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE acc ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE acc ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE missed_calls ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE missed_calls ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE missed_calls ADD COLUMN src_ip varchar(64) NOT NULL default \u0026#39;\u0026#39;; ALTER TABLE missed_calls ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE missed_calls ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT \u0026#39;\u0026#39;; ALTER TABLE missed_calls ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT \u0026#39;\u0026#39;; 输出结果 被叫接通并挂断: sip信令图: acc表记录： acc_cdrs表数据： 主叫CANCEL sip信令图: acc表记录： miss_calls表记录： acc_cdrs表数据： 总结 CANCEL生效的条件有两个: report_cancels=1和setflag(FLT_ACC) 使用数据库的话，总共要用到acc,miss_calls,acc_cdrs三张表。 180响铃目前看是没记录的，183也许可行，但是没测试过。 ACK也不是所有的都记录, 200OK的ACK记录了。 ","date":"2025-05-09T15:55:02+08:00","image":"https://QuincyGao.github.io/p/kamailio-acc%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/backup_hu11199452135460426606.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-acc%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","title":"kamailio acc模块介绍"},{"content":"前言 初次接触前端开发还是2017年,那时还是vue2和js, 换过工作之后，前端就没有再开发了。 现在vue3和ts大行其道, 随着AI浪潮的到来, 可以结合前端做一些有意思的工具,所以需要重新学习前端。\n目前正在学习vue-vben-admin框架, 记录一下学习过程。本章主要介绍package.json\n官方代码地址:vue-vben-admin\n代码结构 package.json vue-vben-admin框架的package.json如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 { \u0026#34;name\u0026#34;: \u0026#34;vben-admin-monorepo\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;5.5.5\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;keywords\u0026#34;: [ \u0026#34;monorepo\u0026#34;, \u0026#34;turbo\u0026#34;, \u0026#34;vben\u0026#34;, \u0026#34;vben admin\u0026#34;, \u0026#34;vben pro\u0026#34;, \u0026#34;vue\u0026#34;, \u0026#34;vue admin\u0026#34;, \u0026#34;vue vben admin\u0026#34;, \u0026#34;vue vben admin pro\u0026#34;, \u0026#34;vue3\u0026#34; ], \u0026#34;homepage\u0026#34;: \u0026#34;https://github.com/vbenjs/vue-vben-admin\u0026#34;, \u0026#34;bugs\u0026#34;: \u0026#34;https://github.com/vbenjs/vue-vben-admin/issues\u0026#34;, \u0026#34;repository\u0026#34;: \u0026#34;vbenjs/vue-vben-admin.git\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;vben\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;ann.vben@gmail.com\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://github.com/anncwb\u0026#34; }, \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;cross-env NODE_OPTIONS=--max-old-space-size=8192 turbo build\u0026#34;, \u0026#34;build:analyze\u0026#34;: \u0026#34;turbo build:analyze\u0026#34;, \u0026#34;build:antd\u0026#34;: \u0026#34;pnpm run build --filter=@vben/web-antd\u0026#34;, \u0026#34;build:docker\u0026#34;: \u0026#34;./scripts/deploy/build-local-docker-image.sh\u0026#34;, \u0026#34;build:docs\u0026#34;: \u0026#34;pnpm run build --filter=@vben/docs\u0026#34;, \u0026#34;build:ele\u0026#34;: \u0026#34;pnpm run build --filter=@vben/web-ele\u0026#34;, \u0026#34;build:naive\u0026#34;: \u0026#34;pnpm run build --filter=@vben/web-naive\u0026#34;, \u0026#34;build:play\u0026#34;: \u0026#34;pnpm run build --filter=@vben/playground\u0026#34;, \u0026#34;changeset\u0026#34;: \u0026#34;pnpm exec changeset\u0026#34;, \u0026#34;check\u0026#34;: \u0026#34;pnpm run check:circular \u0026amp;\u0026amp; pnpm run check:dep \u0026amp;\u0026amp; pnpm run check:type \u0026amp;\u0026amp; pnpm check:cspell\u0026#34;, \u0026#34;check:circular\u0026#34;: \u0026#34;vsh check-circular\u0026#34;, \u0026#34;check:cspell\u0026#34;: \u0026#34;cspell lint **/*.ts **/README.md .changeset/*.md --no-progress\u0026#34;, \u0026#34;check:dep\u0026#34;: \u0026#34;vsh check-dep\u0026#34;, \u0026#34;check:type\u0026#34;: \u0026#34;turbo run typecheck\u0026#34;, \u0026#34;clean\u0026#34;: \u0026#34;node ./scripts/clean.mjs\u0026#34;, \u0026#34;commit\u0026#34;: \u0026#34;czg\u0026#34;, \u0026#34;dev\u0026#34;: \u0026#34;turbo-run dev\u0026#34;, \u0026#34;dev:antd\u0026#34;: \u0026#34;pnpm -F @vben/web-antd run dev\u0026#34;, \u0026#34;dev:docs\u0026#34;: \u0026#34;pnpm -F @vben/docs run dev\u0026#34;, \u0026#34;dev:ele\u0026#34;: \u0026#34;pnpm -F @vben/web-ele run dev\u0026#34;, \u0026#34;dev:naive\u0026#34;: \u0026#34;pnpm -F @vben/web-naive run dev\u0026#34;, \u0026#34;dev:play\u0026#34;: \u0026#34;pnpm -F @vben/playground run dev\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;vsh lint --format\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;vsh lint\u0026#34;, \u0026#34;postinstall\u0026#34;: \u0026#34;pnpm -r run stub --if-present\u0026#34;, \u0026#34;preinstall\u0026#34;: \u0026#34;npx only-allow pnpm\u0026#34;, \u0026#34;prepare\u0026#34;: \u0026#34;is-ci || husky\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;turbo-run preview\u0026#34;, \u0026#34;publint\u0026#34;: \u0026#34;vsh publint\u0026#34;, \u0026#34;reinstall\u0026#34;: \u0026#34;pnpm clean --del-lock \u0026amp;\u0026amp; pnpm install\u0026#34;, \u0026#34;test:unit\u0026#34;: \u0026#34;vitest run --dom\u0026#34;, \u0026#34;test:e2e\u0026#34;: \u0026#34;turbo run test:e2e\u0026#34;, \u0026#34;update:deps\u0026#34;: \u0026#34;npx taze -r -w\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;pnpm exec changeset version \u0026amp;\u0026amp; pnpm install --no-frozen-lockfile\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@changesets/changelog-github\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;@changesets/cli\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;@playwright/test\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;@vben/commitlint-config\u0026#34;: \u0026#34;workspace:*\u0026#34;, \u0026#34;@vben/eslint-config\u0026#34;: \u0026#34;workspace:*\u0026#34;, \u0026#34;@vben/prettier-config\u0026#34;: \u0026#34;workspace:*\u0026#34;, \u0026#34;@vben/stylelint-config\u0026#34;: \u0026#34;workspace:*\u0026#34;, \u0026#34;@vben/tailwind-config\u0026#34;: \u0026#34;workspace:*\u0026#34;, \u0026#34;@vben/tsconfig\u0026#34;: \u0026#34;workspace:*\u0026#34;, \u0026#34;@vben/turbo-run\u0026#34;: \u0026#34;workspace:*\u0026#34;, \u0026#34;@vben/vite-config\u0026#34;: \u0026#34;workspace:*\u0026#34;, \u0026#34;@vben/vsh\u0026#34;: \u0026#34;workspace:*\u0026#34;, \u0026#34;@vitejs/plugin-vue\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;@vitejs/plugin-vue-jsx\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;@vue/test-utils\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;autoprefixer\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;cross-env\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;cspell\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;happy-dom\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;husky\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;is-ci\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;lint-staged\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;playwright\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;rimraf\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;tailwindcss\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;turbo\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;unbuild\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;vite\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;vitest\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;vue\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;vue-tsc\u0026#34;: \u0026#34;catalog:\u0026#34; }, \u0026#34;engines\u0026#34;: { \u0026#34;node\u0026#34;: \u0026#34;\u0026gt;=20.10.0\u0026#34;, \u0026#34;pnpm\u0026#34;: \u0026#34;\u0026gt;=9.12.0\u0026#34; }, \u0026#34;packageManager\u0026#34;: \u0026#34;pnpm@10.10.0\u0026#34;, \u0026#34;pnpm\u0026#34;: { \u0026#34;peerDependencyRules\u0026#34;: { \u0026#34;allowedVersions\u0026#34;: { \u0026#34;eslint\u0026#34;: \u0026#34;*\u0026#34; } }, \u0026#34;overrides\u0026#34;: { \u0026#34;@ast-grep/napi\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;@ctrl/tinycolor\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;clsx\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;esbuild\u0026#34;: \u0026#34;0.25.3\u0026#34;, \u0026#34;pinia\u0026#34;: \u0026#34;catalog:\u0026#34;, \u0026#34;vue\u0026#34;: \u0026#34;catalog:\u0026#34; }, \u0026#34;neverBuiltDependencies\u0026#34;: [ \u0026#34;canvas\u0026#34;, \u0026#34;node-gyp\u0026#34; ] } } 对package.json的字段需要进行说明：\nname: 项目名称,要少于214个字符,不能大写开头和使用node的核心库名, 可以使用点和下划线开头。 version: 项目版本, 和name一起确定一个项目, 不能重复。 private: 是否为私有项目, 如果为true, 则不会被发布到npm上。 keywords: 项目关键字, 用于npm search搜索。 homepage: 项目主页 bugs: 项目问题地址 repository: 项目仓库 license: 项目许可证, 可以是MIT, Apache-2.0, GPL-3.0等。许可查询地址:license author: 项目作者 type: 项目类型,可以是module, commonjs, none等。 scripts: 项目脚本 devDependencies: 项目开发依赖,不想安装额外的test或者文档框架,可以在这里添加。 engines: 项目引擎, 可以指定node和pnpm的版本。 packageManager: 项目包管理器 pnpm: 项目包管理器配置 peerDependencyRules: 项目依赖规则 overrides: 项目依赖覆盖 neverBuiltDependencies: 项目不需要构建的依赖,安装期间不会执行所列包的preinstall,install和postinstall脚本。 官方package.json文档地址:package.json 官方script脚本参数:scripts 官方pnpm文档:pnpm 工作空间 在devDependencies里, 可以看到依赖的服务版本有两种方式, 一种是catalog:的方式, 一种是workspace:*的方式。这两个依赖的具体版本是在pnpm-workspace.yaml文件中定义的。 pnpm-workspace.yaml文件如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 packages: - internal/* - internal/lint-configs/* - packages/* - packages/@core/base/* - packages/@core/ui-kit/* - packages/@core/forward/* - packages/@core/* - packages/effects/* - packages/business/* - apps/* - scripts/* - docs - playground catalog: \u0026#39;@ast-grep/napi\u0026#39;: ^0.37.0 \u0026#39;@changesets/changelog-github\u0026#39;: ^0.5.1 \u0026#39;@changesets/cli\u0026#39;: ^2.29.2 \u0026#39;@changesets/git\u0026#39;: ^3.0.4 \u0026#39;@clack/prompts\u0026#39;: ^0.10.1 \u0026#39;@commitlint/cli\u0026#39;: ^19.8.0 \u0026#39;@commitlint/config-conventional\u0026#39;: ^19.8.0 \u0026#39;@ctrl/tinycolor\u0026#39;: ^4.1.0 \u0026#39;@eslint/js\u0026#39;: ^9.25.1 \u0026#39;@faker-js/faker\u0026#39;: ^9.7.0 \u0026#39;@iconify/json\u0026#39;: ^2.2.332 \u0026#39;@iconify/tailwind\u0026#39;: ^1.2.0 \u0026#39;@iconify/vue\u0026#39;: ^4.3.0 \u0026#39;@intlify/core-base\u0026#39;: ^11.1.3 \u0026#39;@intlify/unplugin-vue-i18n\u0026#39;: ^6.0.8 \u0026#39;@jspm/generator\u0026#39;: ^2.5.1 \u0026#39;@manypkg/get-packages\u0026#39;: ^2.2.2 \u0026#39;@nolebase/vitepress-plugin-git-changelog\u0026#39;: ^2.17.0 \u0026#39;@playwright/test\u0026#39;: ^1.52.0 \u0026#39;@pnpm/workspace.read-manifest\u0026#39;: ^1000.1.4 \u0026#39;@stylistic/stylelint-plugin\u0026#39;: ^3.1.2 \u0026#39;@tailwindcss/nesting\u0026#39;: 0.0.0-insiders.565cd3e \u0026#39;@tailwindcss/typography\u0026#39;: ^0.5.16 \u0026#39;@tanstack/vue-query\u0026#39;: ^5.74.7 \u0026#39;@tanstack/vue-store\u0026#39;: ^0.7.0 \u0026#39;@types/archiver\u0026#39;: ^6.0.3 \u0026#39;@types/eslint\u0026#39;: ^9.6.1 \u0026#39;@types/html-minifier-terser\u0026#39;: ^7.0.2 \u0026#39;@types/jsonwebtoken\u0026#39;: ^9.0.9 \u0026#39;@types/lodash.clonedeep\u0026#39;: ^4.5.9 \u0026#39;@types/lodash.get\u0026#39;: ^4.4.9 \u0026#39;@types/lodash.isequal\u0026#39;: ^4.5.8 \u0026#39;@types/lodash.set\u0026#39;: ^4.3.9 \u0026#39;@types/node\u0026#39;: ^22.15.2 \u0026#39;@types/nprogress\u0026#39;: ^0.2.3 \u0026#39;@types/postcss-import\u0026#39;: ^14.0.3 \u0026#39;@types/qrcode\u0026#39;: ^1.5.5 \u0026#39;@types/qs\u0026#39;: ^6.9.18 \u0026#39;@types/sortablejs\u0026#39;: ^1.15.8 \u0026#39;@typescript-eslint/eslint-plugin\u0026#39;: ^8.31.0 \u0026#39;@typescript-eslint/parser\u0026#39;: ^8.31.0 \u0026#39;@vee-validate/zod\u0026#39;: ^4.15.0 \u0026#39;@vite-pwa/vitepress\u0026#39;: ^1.0.0 \u0026#39;@vitejs/plugin-vue\u0026#39;: ^5.2.3 \u0026#39;@vitejs/plugin-vue-jsx\u0026#39;: ^4.1.2 \u0026#39;@vue/reactivity\u0026#39;: ^3.5.13 \u0026#39;@vue/shared\u0026#39;: ^3.5.13 \u0026#39;@vue/test-utils\u0026#39;: ^2.4.6 \u0026#39;@vueuse/core\u0026#39;: ^13.1.0 \u0026#39;@vueuse/motion\u0026#39;: ^3.0.3 \u0026#39;@vueuse/integrations\u0026#39;: ^13.1.0 ant-design-vue: ^4.2.6 archiver: ^7.0.1 autoprefixer: ^10.4.21 axios: ^1.9.0 axios-mock-adapter: ^2.1.0 cac: ^6.7.14 chalk: ^5.4.1 cheerio: ^1.0.0 circular-dependency-scanner: ^2.3.0 class-variance-authority: ^0.7.1 clsx: ^2.1.1 commitlint-plugin-function-rules: ^4.0.1 consola: ^3.4.2 cross-env: ^7.0.3 cspell: ^8.19.3 cssnano: ^7.0.6 cz-git: ^1.11.1 czg: ^1.11.1 dayjs: ^1.11.13 defu: ^6.1.4 depcheck: ^1.4.7 dotenv: ^16.5.0 echarts: ^5.6.0 element-plus: ^2.9.9 eslint: ^9.25.1 eslint-config-turbo: ^2.5.2 eslint-plugin-command: ^3.2.0 eslint-plugin-eslint-comments: ^3.2.0 eslint-plugin-import-x: ^4.11.0 eslint-plugin-jsdoc: ^50.6.11 eslint-plugin-jsonc: ^2.20.0 eslint-plugin-n: ^17.17.0 eslint-plugin-no-only-tests: ^3.3.0 eslint-plugin-perfectionist: ^4.12.3 eslint-plugin-prettier: ^5.2.6 eslint-plugin-regexp: ^2.7.0 eslint-plugin-unicorn: ^59.0.0 eslint-plugin-unused-imports: ^4.1.4 eslint-plugin-vitest: ^0.5.4 eslint-plugin-vue: ^10.0.0 execa: ^9.5.2 find-up: ^7.0.0 get-port: ^7.1.0 globals: ^16.0.0 h3: ^1.15.3 happy-dom: ^17.4.4 html-minifier-terser: ^7.2.0 husky: ^9.1.7 is-ci: ^4.1.0 jsonc-eslint-parser: ^2.4.0 jsonwebtoken: ^9.0.2 lint-staged: ^15.5.1 lodash.clonedeep: ^4.5.0 lodash.get: ^4.4.2 lodash.set: ^4.3.2 lodash.isequal: ^4.5.0 lucide-vue-next: ^0.503.0 medium-zoom: ^1.1.0 naive-ui: ^2.41.0 nitropack: ^2.11.11 nprogress: ^0.2.0 ora: ^8.2.0 pinia: ^3.0.2 pinia-plugin-persistedstate: ^4.2.0 pkg-types: ^2.1.0 playwright: ^1.52.0 postcss: ^8.5.3 postcss-antd-fixes: ^0.2.0 postcss-html: ^1.8.0 postcss-import: ^16.1.0 postcss-preset-env: ^10.1.6 postcss-scss: ^4.0.9 prettier: ^3.5.3 prettier-plugin-tailwindcss: ^0.6.11 publint: ^0.3.12 qrcode: ^1.5.4 qs: ^6.14.0 radix-vue: ^1.9.17 resolve.exports: ^2.0.3 rimraf: ^6.0.1 rollup: ^4.40.0 rollup-plugin-visualizer: ^5.14.0 sass: ^1.87.0 secure-ls: ^2.0.0 sortablejs: ^1.15.6 stylelint: ^16.19.1 stylelint-config-recess-order: ^6.0.0 stylelint-config-recommended: ^16.0.0 stylelint-config-recommended-scss: ^14.1.0 stylelint-config-recommended-vue: ^1.6.0 stylelint-config-standard: ^38.0.0 stylelint-order: ^7.0.0 stylelint-prettier: ^5.0.3 stylelint-scss: ^6.11.1 tailwind-merge: ^2.6.0 tailwindcss: ^3.4.17 tailwindcss-animate: ^1.0.7 theme-colors: ^0.1.0 tippy.js: ^6.3.7 turbo: ^2.5.2 typescript: ^5.8.3 unbuild: ^3.5.0 unplugin-element-plus: ^0.10.0 vee-validate: ^4.15.0 vite: ^6.3.3 vite-plugin-compression: ^0.5.1 vite-plugin-dts: ^4.5.3 vite-plugin-html: ^3.2.2 vite-plugin-lazy-import: ^1.0.7 vite-plugin-pwa: ^1.0.0 vite-plugin-vue-devtools: ^7.7.6 vitepress: ^1.6.3 vitepress-plugin-group-icons: ^1.5.2 vitest: ^3.1.2 vue: ^3.5.13 vue-eslint-parser: ^10.1.3 vue-i18n: ^11.1.3 vue-json-viewer: ^3.0.4 vue-router: ^4.5.1 vue-tippy: ^6.7.0 vue-tsc: 2.1.10 vxe-pc-ui: ^4.5.14 vxe-table: ^4.13.14 watermark-js-plus: ^1.6.0 zod: ^3.24.3 zod-defaults: ^0.1.3 workspace:*: 用的是以@vben/开头的依赖, 这些包在internal/*和scripts/*目录下 catalog:: 用的是第三方依赖 scripts package.json里的scripts字段是项目的脚本, 可以在命令行中执行。 在本项目中, 常用的脚本有:\ndev: 启动开发服务器 build: 构建项目 test: 运行测试 lint: 检查代码格式 format: 格式化代码 version: 版本管理 commit: 提交代码 官方scripts的使用文档：scripts, 比较重要的有生命周期脚本：\npre\u0026lt;event\u0026gt;: event事件前执行的脚本, 如preinstall在安装前执行。 event: 事件脚本, 如install在安装时执行。 post\u0026lt;event\u0026gt;: event事件后执行的脚本, 如postinstall在安装后执行。 本项目中，当运行pnpm install时，具体执行顺序如下:\n执行preinstall脚本(npx only-allow pnpm)\n执行install脚本\n执行postinstall脚本(pnpm -r run stub --if-present)\npnpm -r run stub --if-present会找本项目下的所有包的package.json, 如果有stub脚本, 则执行。 stub脚本会在package.json的scripts字段中定义, 如下: 1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;stub\u0026#34;: \u0026#34;pnpm unbuild --stub\u0026#34; } 找到的包有很多，比如:internal/lint-configs/eslint-config执行pnpm unbuild --stub unbuild是打包工具,会生成cjs和mjs到dist目录下 执行prepare脚本(is-ci || husky)\nis-ci是判断是否在CI环境下 husky是git的钩子工具, 可以在git提交前执行一些脚本, 如:格式化代码. 本项目配置在.husky/*目录下, 具体有三个文件: commit-msg是在提交消息前执行的脚本: 1 2 3 4 echo Start running commit-msg hook... # Check whether the git commit information is standardized pnpm exec commitlint --edit \u0026#34;$1\u0026#34; echo Run commit-msg hook done. post-merge是在合并分支后执行的脚本, 如:检查代码格式是否正确。 1 pnpm install pre-commit是在提交前执行的脚本, 如:检查代码格式是否正确。 1 2 3 4 pnpm vsh code-workspace --auto-commit # Format and submit code according to lintstagedrc.js configuration pnpm exec lint-staged echo Run pre-commit hook done. ","date":"2025-05-07T09:48:25+08:00","image":"https://QuincyGao.github.io/p/vue-vben-admin%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%80-package.json/backup_hu14519745851058514064.jpg","permalink":"https://QuincyGao.github.io/p/vue-vben-admin%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%80-package.json/","title":"vue-vben-admin框架学习(一)-package.json"},{"content":"HTable 模块 HTable 模块是一个基于内存的键值对存储模块,用于kamailio的缓存。可以定义多个HTable,也可以从数据库中加载数据。 多节点时,也可以使用DMQ方式同步数据。\n官方文档地址:htable, 本次测试的kamailio版本是:\nversion: kamailio 5.8.5 (x86_64/linux)\n重要参数介绍 htname=\u0026gt;size=number;autoexpire=number;dbtable=string; htname: 缓存名称 size: 缓存大小:2^size, [2, 31] autoexpire: 自动过期时间,单位秒 dbtable: 从数据库中加载数据,默认为空,即不加载数据 dbmode: 0,不回写数据库;1,当服务停止时，回写数据库,默认0 initval: 初始化值,如果key不存在,则返回该值,默认是$null updateexpire: 是否更新过期时间,默认是1,即当值更新后,这个过期时间也重置。 dmqreplicate: 如果设置成1,对缓存的任何操作都会通过DMQ进行同步。默认0 coldelim: 缓存数据分隔符,默认是, timer_interval 多长时间检查一次缓存过期数据,默认20秒\nenable_dmq 是否开启dmq,默认是0,如果是1,则开启dmq,dmq必须提前加载\ndmq_init_sync 如果是1,其他节点启动时,会发出同步请求。\ntimer_procs 如果设置成1或更大, 这个模块会创建自己的定时进程扫描过期数据。默认是0,使用核心的定时进程扫描过期数据。\n重要函数介绍 sht_print() 打印所有的缓存数据到L_ERR日志\nsht_rm(htname, itname) 从htname表中删除一个itname数据, 等价于$sht(htname=\u0026gt;itname) = $null\nsht_rm_name_re(htable=\u0026gt;regexp) 删除htable表中所有名称匹配regexp的数据\nsht_rm_value_re(htable=\u0026gt;regexp) 删除htable表中所有值匹配regexp的数据\nsht_rm_name(htable,op,val) 删除htable表中所有名称和val匹配的数据\nop:\nre 作为表达式匹配val sw 前缀 sht_rm_value(htable,op,val) 删除htable表中所有值匹配regexp的数据,op和上面的一样意思。\nsht_setxs(htname, itname, itval, exval) 设置htaname表中itname的数据为itval,并设置itname的过期时间为exval字符串的过期时间\nsht_setxi(htname, itname, itval, exval) 设置htaname表中itname的数据为itval,并设置itname的过期时间为exval整形的过期时间\nsht_reset(htable) 重置htable表\nsht_lock(htable=\u0026gt;key) 加锁htable表的key\nsht_unlock(htable=\u0026gt;key) 解锁htable表的key\nsht_iterator_start(iname, hname) 迭代器开始\nsht_iterator_end(iname) 迭代器结束\nsht_iterator_next(iname) 下一个迭代器\n额外变量 $sht(htable=\u0026gt;key) 获取htable表中key的数据,可读和写 $shtex(htable=\u0026gt;key) 获取htable表中key的过期时间,可读和写 $shtcn(htable=\u0026gt;exp) 获取htable表中key匹配exp的个数 $shtcv(htable=\u0026gt;exp) 获取htable表中value匹配exp的个数 $shtinc(htable=\u0026gt;key) 自增1 $shtdec(htable=\u0026gt;key) 自减1 $shtitkey(iname) 当前迭代器的key $shtitval(iname) 当前迭代器的value $shtrecord(attribute) 获取过期的key或者value,用在event_route[htable:expired:table_name]中 实战 172.16.4.111的配置文件:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 loadmodule \u0026#34;dmq.so\u0026#34; modparam(\u0026#34;dmq\u0026#34;, \u0026#34;server_address\u0026#34;, \u0026#34;sip:172.16.4.111:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;server_socket\u0026#34;, \u0026#34;udp:172.16.4.111:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;notification_address\u0026#34;, \u0026#34;sip:172.16.4.113:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;notification_channel\u0026#34;, \u0026#34;peers\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;num_workers\u0026#34;, 4) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;ping_interval\u0026#34;, 30) loadmodule \u0026#34;htable.so\u0026#34; modparam(\u0026#34;htable\u0026#34;, \u0026#34;htable\u0026#34;, \u0026#34;a=\u0026gt;size=4;autoexpire=7200;dmqreplicate=1;\u0026#34;) modparam(\u0026#34;htable\u0026#34;, \u0026#34;enable_dmq\u0026#34;, 1) modparam(\u0026#34;htable\u0026#34;, \u0026#34;dmq_init_sync\u0026#34;, 1) modparam(\u0026#34;htable\u0026#34;, \u0026#34;timer_procs\u0026#34;, 4) request_route { ... if(is_method(\u0026#34;KDMQ\u0026#34;)) { dmq_handle_message(); } ... } event_route[htable:mod-init] { $sht(a=\u0026gt;x) = 1; $sht(a=\u0026gt;y) = 2; $sht(a=\u0026gt;z) = 4; xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;htable mod init success\\n\u0026#34;); } 172.16.4.113的配置文件:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 loadmodule \u0026#34;dmq.so\u0026#34; modparam(\u0026#34;dmq\u0026#34;, \u0026#34;server_address\u0026#34;, \u0026#34;sip:172.16.4.113:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;server_socket\u0026#34;, \u0026#34;udp:172.16.4.113:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;notification_address\u0026#34;, \u0026#34;sip:172.16.4.111:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;notification_channel\u0026#34;, \u0026#34;peers\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;num_workers\u0026#34;, 4) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;ping_interval\u0026#34;, 30) loadmodule \u0026#34;htable.so\u0026#34; modparam(\u0026#34;htable\u0026#34;, \u0026#34;htable\u0026#34;, \u0026#34;b=\u0026gt;size=4;autoexpire=7200;dmqreplicate=1;\u0026#34;) request_route { ... if(is_method(\u0026#34;KDMQ\u0026#34;)) { dmq_handle_message(); } ... } 如果同步的113机器上没有a的表,那么111机器上同步数据报错: 修改113上的htable为:\n1 2 3 4 modparam(\u0026#34;htable\u0026#34;, \u0026#34;htable\u0026#34;, \u0026#34;a=\u0026gt;size=4;autoexpire=7200;dmqreplicate=1;\u0026#34;) modparam(\u0026#34;htable\u0026#34;, \u0026#34;enable_dmq\u0026#34;, 1) modparam(\u0026#34;htable\u0026#34;, \u0026#34;dmq_init_sync\u0026#34;, 1) modparam(\u0026#34;htable\u0026#34;, \u0026#34;timer_procs\u0026#34;, 4) 同步成功: ","date":"2025-04-28T09:38:39+08:00","image":"https://QuincyGao.github.io/p/kamailio%E7%9A%84%E7%BC%93%E5%AD%98htable/backup_hu10069223333161384786.jpg","permalink":"https://QuincyGao.github.io/p/kamailio%E7%9A%84%E7%BC%93%E5%AD%98htable/","title":"kamailio的缓存HTable"},{"content":"问题描述 在使用golang 写websocket服务时，不可避免需要使用gorilla/websocket包.\n在官方提供的example示例中,监听的ip都是localhost, 但是当需要对外提供服务时, 我们需要把ip改为0.0.0.0或者具体的ip。 此时如果使用gorilla/websocket包写客户端的话，使用默认的DefaultDialer去连接具体的ip, 客户端报错Forbidden\n解决办法 通过查看gorilla/websocket包源码, 发现DefaultDialer的结构为\n1 2 3 4 var DefaultDialer = \u0026amp;Dialer{ Proxy: http.ProxyFromEnvironment, HandshakeTimeout: 45 * time.Second, } ProxyFromEnvironment函数会读取环境变量里的http_proxy和https_proxy代理, 我的测试环境是设置了代理，所以会报错。\n解决方法是不使用DefaultDialer，而是使用Dialer结构体.\n1 2 3 4 5 6 dialer := websocket.Dialer{ ReadBufferSize: 2048, WriteBufferSize: 2048, HandshakeTimeout: 45 * time.Second, } dialer.Dial(\u0026#34;ws://127.0.0.1:8080/ws\u0026#34;, nil) ","date":"2025-04-27T09:25:32+08:00","image":"https://QuincyGao.github.io/p/gorilla/websocket-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8A%A5%E9%94%99forbidden/backup_hu15738836983696457870.jpg","permalink":"https://QuincyGao.github.io/p/gorilla/websocket-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8A%A5%E9%94%99forbidden/","title":"gorilla/websocket 客户端报错Forbidden"},{"content":"背景 sipcapture用来存储进来和出去的sip消息,还可以存储HEP协议的数据。\n相比siptrace,sipcapture只能存储到数据库中，不能发送到第三方存储。\n官方文档地址:sipcapture, 本次测试的kamailio版本是:\nversion: kamailio 5.8.5 (x86_64/linux)\n重要参数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 数据库连接地址 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) # 表名, 多个表使用|隔开 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;table_name\u0026#34;, \u0026#34;homer_capture1|homer_capture2\u0026#34;); # 存储数据到多个表的模式, rand:随机; round_robin:轮询; hash:哈希 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;mt_mode\u0026#34;, \u0026#34;hash\u0026#34;) # 当mt_mode为hash时, hash_source为hash的key,可以为call_id,to_user,from_user.默认call_id modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;hash_source\u0026#34;, \u0026#34;to_user\u0026#34;) # 存储到数据库的模式, 1,INSERT DELAYED; 2,ASYNC INSERT; 0,INSERT modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;db_insert_mode\u0026#34;, 1) # 设置抓包模式 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;capture_mode\u0026#34;, \u0026#34;mode1=\u0026gt;db_url=mysql://user:passwd@host/dbname1;table_name=homer_capture1|homer_capture2;mt_mode=hash;hash_source=call_id;\u0026#34;) # 是否开启sipcapture功能 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;capture_on\u0026#34;, 1) # 实时开启抓hep功能 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;hep_capture_on\u0026#34;, 1) # 是否开启抓ipip功能 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;raw_ipip_capture_on\u0026#34;, 1) # 是否开启监控/镜像端口功能 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;raw_moni_capture_on\u0026#34;, 1) # 监听ip地址 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;raw_socket_listen\u0026#34;, \u0026#34;10.0.0.1:5060-5090\u0026#34;) # 监听网卡 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;raw_interface\u0026#34;, \u0026#34;eth0\u0026#34;) # 监听子进程数量 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;raw_sock_children\u0026#34;, 6) # 是否开启混杂模式 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;promiscuous_on\u0026#34;, 1) # 是否开启bpf过滤 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;raw_moni_bpf_on\u0026#34;, 1) # 设置节点名称 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;capture_node\u0026#34;, \u0026#34;homer01\u0026#34;) # 写入数据库失败重试次数 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;insert_retries\u0026#34;, 5) # 写入数据库失败重试间隔 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;insert_retry_timeout\u0026#34;, 10) # 设置为1,当Hep消息到达时,event_route[sipcapture:siprequest]生效. modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;nonsip_hook\u0026#34;, 1) # 是否抓 broken的sip消息 modparam(\u0026#34;sipcapture\u0026#34;, \u0026#34;capture_bad_msgs\u0026#34;, 1) 重要函数 sip_capture([table], [cmode]) 存储当前的HEP/IPIP SIP消息到数据库\ntable 表名,可以为\u0026quot;\u0026quot;,也可以sip_capture_call_%Y%m%d cmode 和上面的capture_mode参数一样 report_capture([table], [cid], [data]) 存储HEP REPORT消息到数据库\ntable 表名 cid 关联id data json格式的数据 float2int(fval, ival) 返回乘积,atof(fval)*atoi(ival)\nsip_capture_forward(uri) 转发HEP包到到指定的uri,uri是sip uri格式，主要用在event_route[sipcapture:siprequest]中\n实战 sip_capture 数据表 sip_capture数据表默认是没有创建的，需要手动创建。\n其脚本路径在源码:src/modules/sipcapture/sql/.\ncreate_sipcapture_postgress.sql 是表sip_capture的创建脚本 schema_data.sql其中的report_capture和sip_capture_call_20150407可用 sip_capture的mysql脚本为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 CREATE TABLE sip_capture ( id INT NOT NULL AUTO_INCREMENT, date DATETIME NOT NULL DEFAULT \u0026#39;1900-01-01 00:00:01\u0026#39;, micro_ts BIGINT NOT NULL DEFAULT 0, method VARCHAR(50) NOT NULL DEFAULT \u0026#39;\u0026#39;, reply_reason VARCHAR(100) NOT NULL, ruri VARCHAR(200) NOT NULL DEFAULT \u0026#39;\u0026#39;, ruri_user VARCHAR(100) NOT NULL DEFAULT \u0026#39;\u0026#39;, from_user VARCHAR(100) NOT NULL DEFAULT \u0026#39;\u0026#39;, from_tag VARCHAR(64) NOT NULL DEFAULT \u0026#39;\u0026#39;, to_user VARCHAR(100) NOT NULL DEFAULT \u0026#39;\u0026#39;, to_tag VARCHAR(64) NOT NULL DEFAULT \u0026#39;\u0026#39;, pid_user VARCHAR(100) NOT NULL DEFAULT \u0026#39;\u0026#39;, contact_user VARCHAR(120) NOT NULL DEFAULT \u0026#39;\u0026#39;, auth_user VARCHAR(120) NOT NULL DEFAULT \u0026#39;\u0026#39;, callid VARCHAR(100) NOT NULL DEFAULT \u0026#39;\u0026#39;, callid_aleg VARCHAR(100) NOT NULL DEFAULT \u0026#39;\u0026#39;, via_1 VARCHAR(256) NOT NULL DEFAULT \u0026#39;\u0026#39;, via_1_branch VARCHAR(80) NOT NULL DEFAULT \u0026#39;\u0026#39;, cseq VARCHAR(25) NOT NULL DEFAULT \u0026#39;\u0026#39;, diversion VARCHAR(256) NOT NULL DEFAULT \u0026#39;\u0026#39;, reason VARCHAR(200) NOT NULL DEFAULT \u0026#39;\u0026#39;, content_type VARCHAR(256) NOT NULL DEFAULT \u0026#39;\u0026#39;, auth VARCHAR(256) NOT NULL DEFAULT \u0026#39;\u0026#39;, user_agent VARCHAR(256) NOT NULL DEFAULT \u0026#39;\u0026#39;, source_ip VARCHAR(60) NOT NULL DEFAULT \u0026#39;\u0026#39;, source_port INT NOT NULL DEFAULT 0, destination_ip VARCHAR(60) NOT NULL DEFAULT \u0026#39;\u0026#39;, destination_port INT NOT NULL DEFAULT 0, contact_ip VARCHAR(60) NOT NULL DEFAULT \u0026#39;\u0026#39;, contact_port INT NOT NULL DEFAULT 0, originator_ip VARCHAR(60) NOT NULL DEFAULT \u0026#39;\u0026#39;, originator_port INT NOT NULL DEFAULT 0, proto INT NOT NULL DEFAULT 0, family INT NOT NULL DEFAULT 0, rtp_stat VARCHAR(256) NOT NULL DEFAULT \u0026#39;\u0026#39;, type INT NOT NULL DEFAULT 0, node VARCHAR(125) NOT NULL DEFAULT \u0026#39;\u0026#39;, msg VARCHAR(1500) NOT NULL DEFAULT \u0026#39;\u0026#39;, PRIMARY KEY (id, date) ) ENGINE=InnoDB; CREATE INDEX sip_capture_ruri_user_idx ON sip_capture (ruri_user); CREATE INDEX sip_capture_from_user_idx ON sip_capture (from_user); CREATE INDEX sip_capture_to_user_idx ON sip_capture (to_user); CREATE INDEX sip_capture_pid_user_idx ON sip_capture (pid_user); CREATE INDEX sip_capture_auth_user_idx ON sip_capture (auth_user); CREATE INDEX sip_capture_callid_aleg_idx ON sip_capture (callid_aleg); CREATE INDEX sip_capture_date_idx ON sip_capture (date); CREATE INDEX sip_capture_callid_idx ON sip_capture (callid); 该模块暂时还未配置成功，后续有时间再补上。\n","date":"2025-04-10T10:28:55+08:00","image":"https://QuincyGao.github.io/p/kamailio-sipcapture%E4%BB%8B%E7%BB%8D/backup_hu526023374974018560.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-sipcapture%E4%BB%8B%E7%BB%8D/","title":"kamailio sipcapture介绍"},{"content":"背景 上章我们介绍了siptrace模块,可以把sip信令存储到数据库或者发送给第三方的Hep server中, 本章sipdump模块,可以记录sip信令到文件。\nkamailio的siptrace+sipdump= opensips的tracer模块, opensips的tracer之前的章节有介绍，可以查看。 但是在存文件的功能上, opensips比较单一,kamailio可以自动回滚文件，删除过期文件,多种文件类型。\nkamailio的官方推荐:\n开发环境使用sipdump 生产环境使用siptrace或者sipcapture 发送给Homer sipdump的官方文档地址:sipdump, 本次测试的kamailio版本是:\nversion: kamailio 5.8.5 (x86_64/linux)\n配置参数分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 是否开启,默认0 modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;enable\u0026#34;, 1) # bit位置: 0,写到text文件;1,产生event route;2,写到pcap文件;3, 添加`P-KSR-SIPDump`头到SIP消息,然后写到pcap文件 modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;mode\u0026#34;, 3) # 当没有sip消息到时等待多少毫秒,默认100 modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;wait\u0026#34;, 2000) # 文件回滚的时间间隔,默认7200秒 modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;rotate\u0026#34;, 3600) # 文件保存路径 modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;folder\u0026#34;, \u0026#34;/run/kamailio\u0026#34;) # 文件名前缀,默认kamailio-sipdump-, yyyy-mm-dd-hh-mm-ss会追加到前缀后面 modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;fprefix\u0026#34;, \u0026#34;ksipdump-\u0026#34;) # 创建多久的文件被删除,单位s, 清除的定时器每10分钟执行一次,默认0,不删除。 modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;fage\u0026#34;, 172800) # 2days mode 是按位算的,二进制1: 写text文件, 10 执行event route, 100: 写pcap文件, 1000: 添加P-KSR-SIPDump头到SIP消息,然后写到pcap文件 modparam(\u0026quot;sipdump\u0026quot;, \u0026quot;mode\u0026quot;, 3) 3就是11,\n函数 sipdump_send(tag) 发送当前的SIP消息到写进程,然后存文件. tag可以是任何字符串。\n实战 配置示例 1 2 3 4 5 6 7 8 9 10 11 loadmodule \u0026#34;sipdump.so\u0026#34; modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;enable\u0026#34;, 1) modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;mode\u0026#34;, 3) modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;wait\u0026#34;, 2000) modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;rotate\u0026#34;, 3600) modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;folder\u0026#34;, \u0026#34;/run/kamailio\u0026#34;) modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;fage\u0026#34;, 172800) event_route[sipdump:msg] { xinfo(\u0026#34;[$sipdump(tag)] [[$sipdump(buf)]]\\n\u0026#34;); } 效果 mode = 3 注册 event_route[sipdump:msg]会打印出注册的SIP消息。 rev: 收到SIP消息, snd: 发送SIP消息\n保存的文件/run/kamailio/ 如果设置modparam(\u0026quot;sipdump\u0026quot;, \u0026quot;rotate\u0026quot;, 60), 60s的效果: 可以看到如果在60s之后,有新的sip信息产生,那么会记录到新的文件。\nkamailio-sipdump-2025-04-03\u0026ndash;10-49-15.data 数据内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 ==================== tag: rcv pid: 5744 process: 2 time: 1743648555.167981 date: Thu Apr 3 10:49:15 2025 proto: udp ipv4 srcip: 172.16.80.3 srcport: 65398 dstip: 172.16.4.113 dstport: 5460 ~~~~~~~~~~~~~~~~~~~~ REGISTER sip:172.16.4.113:5460 SIP/2.0 Via: SIP/2.0/UDP 172.16.80.3:65398;rport;branch=z9hG4bKPj220c0fe63bb746879d404a28e02066c4 Max-Forwards: 70 From: \u0026lt;sip:1002@172.16.4.113\u0026gt;;tag=ffd48e15af3642fb91df63ee47130c6a To: \u0026lt;sip:1002@172.16.4.113\u0026gt; Call-ID: 958acb18b530498191314703f7abbf88 CSeq: 28845 REGISTER User-Agent: MicroSIP/3.21.6 Contact: \u0026lt;sip:1002@172.16.80.3:65398;ob\u0026gt; Expires: 0 Content-Length: 0 |||||||||||||||||||| ==================== tag: snd pid: 5744 process: 2 time: 1743648555.168626 date: Thu Apr 3 10:49:15 2025 proto: udp ipv4 srcip: 172.16.4.113 srcport: 5460 dstip: 172.16.80.3 dstport: 65398 ~~~~~~~~~~~~~~~~~~~~ SIP/2.0 200 OK Via: SIP/2.0/UDP 172.16.80.3:65398;rport=65398;received=172.16.80.3;branch=z9hG4bKPj220c0fe63bb746879d404a28e02066c4 From: \u0026lt;sip:1002@172.16.4.113\u0026gt;;tag=ffd48e15af3642fb91df63ee47130c6a To: \u0026lt;sip:1002@172.16.4.113\u0026gt;;tag=ca36158e07626139fe33104dfec02b96.6776fc32 Call-ID: 958acb18b530498191314703f7abbf88 CSeq: 28845 REGISTER Server: kamailio (5.8.5 (x86_64/linux)) Content-Length: 0 |||||||||||||||||||| ==================== tag: rcv pid: 5745 process: 3 time: 1743648555.947732 date: Thu Apr 3 10:49:15 2025 proto: udp ipv4 srcip: 172.16.80.3 srcport: 65398 dstip: 172.16.4.113 dstport: 5460 ~~~~~~~~~~~~~~~~~~~~ REGISTER sip:172.16.4.113:5460 SIP/2.0 Via: SIP/2.0/UDP 172.16.80.3:65398;rport;branch=z9hG4bKPj8da8a9dd97df4c5581fe1001cf637b49 Max-Forwards: 70 From: \u0026lt;sip:1002@172.16.4.113\u0026gt;;tag=543412e2b3e74c24a73c619373266378 To: \u0026lt;sip:1002@172.16.4.113\u0026gt; Call-ID: a7bf0e550c074020b45c2f304f8d6c9b CSeq: 10448 REGISTER User-Agent: MicroSIP/3.21.6 Contact: \u0026lt;sip:1002@172.16.80.3:65398;ob\u0026gt; Expires: 200 Allow: PRACK, INVITE, ACK, BYE, CANCEL, UPDATE, INFO, SUBSCRIBE, NOTIFY, REFER, MESSAGE, OPTIONS Content-Length: 0 |||||||||||||||||||| ==================== tag: snd pid: 5745 process: 3 time: 1743648555.948576 date: Thu Apr 3 10:49:15 2025 proto: udp ipv4 srcip: 172.16.4.113 srcport: 5460 dstip: 172.16.80.3 dstport: 65398 ~~~~~~~~~~~~~~~~~~~~ SIP/2.0 200 OK Via: SIP/2.0/UDP 172.16.80.3:65398;rport=65398;received=172.16.80.3;branch=z9hG4bKPj8da8a9dd97df4c5581fe1001cf637b49 From: \u0026lt;sip:1002@172.16.4.113\u0026gt;;tag=543412e2b3e74c24a73c619373266378 To: \u0026lt;sip:1002@172.16.4.113\u0026gt;;tag=ca36158e07626139fe33104dfec02b96.f2184574 Call-ID: a7bf0e550c074020b45c2f304f8d6c9b CSeq: 10448 REGISTER Contact: \u0026lt;sip:1002@172.16.80.3:65398;ob\u0026gt;;expires=200 Server: kamailio (5.8.5 (x86_64/linux)) Content-Length: 0 |||||||||||||||||||| ==================== kamailio-sipdump-2025-04-03\u0026ndash;10-49-15.meta 的内容: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 v: 1.0 version: kamailio 5.8.5 start: Thu Apr 3 10:49:04 2025 nrprocs: 46 process: 0 5741 main process - attendant process: 1 5743 udp receiver child=0 sock=172.16.4.113:5460 process: 2 5744 udp receiver child=1 sock=172.16.4.113:5460 process: 3 5745 udp receiver child=2 sock=172.16.4.113:5460 process: 4 5746 udp receiver child=3 sock=172.16.4.113:5460 process: 5 5747 udp receiver child=4 sock=172.16.4.113:5460 process: 6 5748 udp receiver child=5 sock=172.16.4.113:5460 process: 7 5749 udp receiver child=6 sock=172.16.4.113:5460 process: 8 5750 udp receiver child=7 sock=172.16.4.113:5460 process: 9 5751 udp receiver child=0 sock=172.16.4.113:5464 process: 10 5752 udp receiver child=1 sock=172.16.4.113:5464 process: 11 5753 udp receiver child=2 sock=172.16.4.113:5464 process: 12 5754 udp receiver child=3 sock=172.16.4.113:5464 process: 13 5755 udp receiver child=4 sock=172.16.4.113:5464 process: 14 5756 udp receiver child=5 sock=172.16.4.113:5464 process: 15 5757 udp receiver child=6 sock=172.16.4.113:5464 process: 16 5758 udp receiver child=7 sock=172.16.4.113:5464 process: 17 5759 udp receiver child=0 sock=172.16.4.113:5465 process: 18 5760 udp receiver child=1 sock=172.16.4.113:5465 process: 19 5761 udp receiver child=2 sock=172.16.4.113:5465 process: 20 5762 udp receiver child=3 sock=172.16.4.113:5465 process: 21 5763 udp receiver child=4 sock=172.16.4.113:5465 process: 22 5764 udp receiver child=5 sock=172.16.4.113:5465 process: 23 5765 udp receiver child=6 sock=172.16.4.113:5465 process: 24 5766 udp receiver child=7 sock=172.16.4.113:5465 process: 25 5767 slow timer process: 26 5768 timer process: 27 5769 secondary timer process: 28 5770 JSONRPCS FIFO process: 29 5771 JSONRPCS DATAGRAM process: 30 5772 USRLOC Timer process: 31 5773 ctl handler process: 32 5774 TIMER NH process: 33 5775 WEBSOCKET KEEPALIVE process: 34 5776 WEBSOCKET TIMER process: 35 5777 Dialog Clean Timer process: 36 5778 SIPDUMP WRITE TIMER process: 37 5779 tcp receiver (generic) child=0 process: 38 5780 tcp receiver (generic) child=1 process: 39 5781 tcp receiver (generic) child=2 process: 40 5782 tcp receiver (generic) child=3 process: 41 5783 tcp receiver (generic) child=4 process: 42 5784 tcp receiver (generic) child=5 process: 43 5785 tcp receiver (generic) child=6 process: 44 5786 tcp receiver (generic) child=7 process: 45 5787 tcp main process wss注册的情况: event_route 事件产生 .data数据: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 ==================== tag: rcv pid: 6301 process: 37 time: 1743651209.118606 date: Thu Apr 3 11:33:29 2025 proto: tls ipv4 srcip: 172.16.80.3 srcport: 53099 dstip: 172.16.4.113 dstport: 5462 ~~~~~~~~~~~~~~~~~~~~ GET / HTTP/1.1 Host: sbc001.abc:5462 Connection: Upgrade Pragma: no-cache Cache-Control: no-cache User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36 Upgrade: websocket Origin: null Sec-WebSocket-Version: 13 Accept-Encoding: gzip, deflate, br, zstd Accept-Language: zh-CN,zh;q=0.9 Sec-WebSocket-Key: g+6VfakF0iemlALkcrqQzg== Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits Sec-WebSocket-Protocol: sip |||||||||||||||||||| ==================== tag: rcv pid: 6301 process: 37 time: 1743651209.122952 date: Thu Apr 3 11:33:29 2025 proto: wss ipv4 srcip: 172.16.80.3 srcport: 53099 dstip: 172.16.4.113 dstport: 5462 ~~~~~~~~~~~~~~~~~~~~ REGISTER sip:sbc001.abc:5462 SIP/2.0 Via: SIP/2.0/WSS 247b5g7epaou.invalid;branch=z9hG4bK5563369 Max-Forwards: 69 To: \u0026lt;sip:1007@sbc001.abc:5462\u0026gt; From: \u0026#34;1007\u0026#34; \u0026lt;sip:1007@sbc001.abc:5462\u0026gt;;tag=sagp76d6l3 Call-ID: a6g0dtj2pi05mnfrre5jjq CSeq: 4 REGISTER X-SBC: Dinstar Mediant Contact: \u0026lt;sip:1007@247b5g7epaou.invalid;transport=ws\u0026gt;;+sip.ice;reg-id=1;+sip.instance=\u0026#34;\u0026lt;urn:uuid:86509451-8dd3-4056-8273-756c451940fe\u0026gt;\u0026#34;;expires=600 Expires: 600 Allow: INVITE,ACK,CANCEL,BYE,UPDATE,MESSAGE,OPTIONS,REFER,INFO,NOTIFY,SUBSCRIBE Supported: path,gruu,outbound User-Agent: Dinstar WebRTC SDK. Simple phone 1.17.0 Chrome/134 Content-Length: 0 |||||||||||||||||||| ==================== tag: snd pid: 6301 process: 37 time: 1743651209.123431 date: Thu Apr 3 11:33:29 2025 proto: wss ipv4 srcip: 172.16.4.113 srcport: 5462 dstip: 172.16.80.3 dstport: 53099 ~~~~~~~~~~~~~~~~~~~~ SIP/2.0 200 OK Via: SIP/2.0/WSS 247b5g7epaou.invalid;branch=z9hG4bK5563369;rport=53099;received=172.16.80.3 To: \u0026lt;sip:1007@sbc001.abc:5462\u0026gt;;tag=ca36158e07626139fe33104dfec02b96.ccae0000 From: \u0026#34;1007\u0026#34; \u0026lt;sip:1007@sbc001.abc:5462\u0026gt;;tag=sagp76d6l3 Call-ID: a6g0dtj2pi05mnfrre5jjq CSeq: 4 REGISTER Contact: \u0026lt;sip:1007@172.16.80.3:53099;transport=ws\u0026gt;;expires=600;received=\u0026#34;sip:172.16.80.3:53099;transport=ws\u0026#34;;+sip.instance=\u0026#34;\u0026lt;urn:uuid:86509451-8dd3-4056-8273-756c451940fe\u0026gt;\u0026#34;;reg-id=1 Server: kamailio (5.8.5 (x86_64/linux)) Content-Length: 0 |||||||||||||||||||| mode = 4 注册 日志这块确实没有event_route事件产生: 保存的文件/run/kamailio/: 产生了.pcap和.meta文件, .meta和上面的一样，就不看了，使用wireshark打开.pcap文件，看到的效果： wss 的.pcap内容： 可以看到, kamailio把wss解析后转成了udp存储到.pcap文件中.\nmode = 12 不能mode=8,必须是8+4(写pcap文件+P-KSR-SIPDump头)\nwss注册\n产生的.pcap文件,使用wireshark打开之后的结果: 可以看到还是把wss解析后转成了udp存储到.pcap文件中. REGISTER信令带了P-KSR-SIPDump头。\n回复的200OK也是带了P-KSR-SIPDump头: 使用sipdump_send 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 loadmodule \u0026#34;sipdump.so\u0026#34; modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;enable\u0026#34;, 1) modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;mode\u0026#34;, 3) modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;wait\u0026#34;, 2000) modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;rotate\u0026#34;, 60) modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;folder\u0026#34;, \u0026#34;/run/kamailio\u0026#34;) modparam(\u0026#34;sipdump\u0026#34;, \u0026#34;fage\u0026#34;, 120) route[REGISTRAR] { if (!is_method(\u0026#34;REGISTER\u0026#34;)) return; sipdump_send(\u0026#34;reg\u0026#34;);# 跟踪REGISTER信令 if(isflagset(FLT_NATS)) { } } 查看生成的.data数据,可以看到有tag为reg的进来数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 ==================== tag: rcv pid: 6710 process: 37 time: 1743663241.182846 date: Thu Apr 3 14:54:01 2025 proto: tls ipv4 srcip: 172.16.80.3 srcport: 3757 dstip: 172.16.4.113 dstport: 5462 ~~~~~~~~~~~~~~~~~~~~ GET / HTTP/1.1 Host: sbc001.abc:5462 Connection: Upgrade Pragma: no-cache Cache-Control: no-cache User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36 Upgrade: websocket Origin: null Sec-WebSocket-Version: 13 Accept-Encoding: gzip, deflate, br, zstd Accept-Language: zh-CN,zh;q=0.9 Sec-WebSocket-Key: FEb0cVfwgJRa4dJrL5Ping== Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits Sec-WebSocket-Protocol: sip |||||||||||||||||||| ==================== tag: rcv pid: 6710 process: 37 time: 1743663241.198303 date: Thu Apr 3 14:54:01 2025 proto: wss ipv4 srcip: 172.16.80.3 srcport: 3757 dstip: 172.16.4.113 dstport: 5462 ~~~~~~~~~~~~~~~~~~~~ REGISTER sip:sbc001.abc:5462 SIP/2.0 Via: SIP/2.0/WSS v7xc2nukc192.invalid;branch=z9hG4bK5988756 Max-Forwards: 69 To: \u0026lt;sip:1007@sbc001.abc:5462\u0026gt; From: \u0026#34;1007\u0026#34; \u0026lt;sip:1007@sbc001.abc:5462\u0026gt;;tag=uckhn179rv Call-ID: vk44j9hdgsjohp5g5m63tr CSeq: 12 REGISTER X-SBC: Dinstar Mediant Contact: \u0026lt;sip:1007@v7xc2nukc192.invalid;transport=ws\u0026gt;;+sip.ice;reg-id=1;+sip.instance=\u0026#34;\u0026lt;urn:uuid:91dfb460-6e55-465c-a3fa-df50b4a8e284\u0026gt;\u0026#34;;expires=600 Expires: 600 Allow: INVITE,ACK,CANCEL,BYE,UPDATE,MESSAGE,OPTIONS,REFER,INFO,NOTIFY,SUBSCRIBE Supported: path,gruu,outbound User-Agent: Dinstar WebRTC SDK. Simple phone 1.17.0 Chrome/134 Content-Length: 0 |||||||||||||||||||| ==================== tag: reg pid: 6710 process: 37 time: 1743663241.198688 date: Thu Apr 3 14:54:01 2025 proto: wss ipv4 srcip: 172.16.80.3 srcport: 3757 dstip: 172.16.4.113 dstport: 5462 ~~~~~~~~~~~~~~~~~~~~ REGISTER sip:sbc001.abc:5462 SIP/2.0 Via: SIP/2.0/WSS v7xc2nukc192.invalid;branch=z9hG4bK5988756 Max-Forwards: 68 To: \u0026lt;sip:1007@sbc001.abc:5462\u0026gt; From: \u0026#34;1007\u0026#34; \u0026lt;sip:1007@sbc001.abc:5462\u0026gt;;tag=uckhn179rv Call-ID: vk44j9hdgsjohp5g5m63tr CSeq: 12 REGISTER X-SBC: Dinstar Mediant Contact: \u0026lt;sip:1007@v7xc2nukc192.invalid;transport=ws\u0026gt;;+sip.ice;reg-id=1;+sip.instance=\u0026#34;\u0026lt;urn:uuid:91dfb460-6e55-465c-a3fa-df50b4a8e284\u0026gt;\u0026#34;;expires=600 Expires: 600 Allow: INVITE,ACK,CANCEL,BYE,UPDATE,MESSAGE,OPTIONS,REFER,INFO,NOTIFY,SUBSCRIBE Supported: path,gruu,outbound User-Agent: Dinstar WebRTC SDK. Simple phone 1.17.0 Chrome/134 Content-Length: 0 |||||||||||||||||||| ==================== tag: snd pid: 6710 process: 37 time: 1743663241.198832 date: Thu Apr 3 14:54:01 2025 proto: wss ipv4 srcip: 172.16.4.113 srcport: 5462 dstip: 172.16.80.3 dstport: 3757 ~~~~~~~~~~~~~~~~~~~~ SIP/2.0 200 OK Via: SIP/2.0/WSS v7xc2nukc192.invalid;branch=z9hG4bK5988756;rport=3757;received=172.16.80.3 To: \u0026lt;sip:1007@sbc001.abc:5462\u0026gt;;tag=ca36158e07626139fe33104dfec02b96.94ce0000 From: \u0026#34;1007\u0026#34; \u0026lt;sip:1007@sbc001.abc:5462\u0026gt;;tag=uckhn179rv Call-ID: vk44j9hdgsjohp5g5m63tr CSeq: 12 REGISTER Contact: \u0026lt;sip:1007@172.16.80.3:3757;transport=ws\u0026gt;;expires=600;received=\u0026#34;sip:172.16.80.3:3757;transport=ws\u0026#34;;+sip.instance=\u0026#34;\u0026lt;urn:uuid:91dfb460-6e55-465c-a3fa-df50b4a8e284\u0026gt;\u0026#34;;reg-id=1 Server: kamailio (5.8.5 (x86_64/linux)) Content-Length: 0 |||||||||||||||||||| 可以看到带reg只有进来的数据没有出去的数据，所以还要在回复的路由处加sipdump_send(\u0026quot;reg\u0026quot;);。 根据目前的场景看,此函数有点鸡肋。\n总结 只要写的是文件,就会产生两个文件.data或.pcap和.meta kamailio会把wss解析后转成udp存储到.pcap文件中. 当fage的时间到了之后，真的会把过时的文件删除掉。 ","date":"2025-04-03T09:25:15+08:00","image":"https://QuincyGao.github.io/p/kamailio-sipdump%E4%BB%8B%E7%BB%8D/backup_hu15800011913166419551.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-sipdump%E4%BB%8B%E7%BB%8D/","title":"kamailio sipdump介绍"},{"content":"背景 SIPtrace模块提供存储进来和出去的SIP消息到数据库或者发送到第三方的服务器。 两种方式存储信息：\nsip_trace(): 记录会话的SIP消息 trace_mode: 自动记录所有的SIP消息 官方文档地址: siptrace, kamailio的版本:\nversion: kamailio 5.8.5 (x86_64/linux)\n重要参数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) # 用来追踪消息而不是用户的标志,默认0 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_flag\u0026#34;, 22) # 开启追踪功能,默认0 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_on\u0026#34;, 1) # 存储用户的AVP,默认NULL modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;traced_user_avp\u0026#34;, \u0026#34;$avp(user)\u0026#34;) # SIP URL地址,用于发送SIP消息 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;duplicate_uri\u0026#34;, \u0026#34;sip:10.1.1.1:5888\u0026#34;) # 是否存储到数据库,在这种场景下:只发送SIP消息到duplicate_uri,并不想存储到数据库,可以设置为0 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_to_database\u0026#34;, 0) # 本地发送IP地址 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_local_ip\u0026#34;, \u0026#34;10.1.1.1:5064\u0026#34;) # 是否追踪ACK消息,默认1, 当选择追踪某些ACK消息时,可以设置为0,然后结合event_route[sl:filtered-ack],sip_trace来过滤. modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_sl_acks\u0026#34;, 0) # 存储fromip, toip, method,direction到X-Siptrace-*头上, 默认0 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;xheaders_write\u0026#34;, 0) # 读取并删除X-Siptrace-*头, 默认0 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;xheaders_read\u0026#34;, 0) # HEP模式 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;hep_mode_on\u0026#34;, 1) # HEP版本 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;hep_version\u0026#34;, 3) # 区分capture agent id,用在HEPv2和HEPv3中 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;hep_capture_id\u0026#34;, 234) # 存储到数据库的方式,默认0. 1,\u0026#34;INSERT DELAYED\u0026#34;;2,\u0026#34;ASYNC-INSERT\u0026#34;;0,\u0026#34;INSERT\u0026#34; modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_db_mode\u0026#34;, 1) # 本地发送trace的SIP URL地址 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;send_sock_addr\u0026#34;, \u0026#34;sip:10.1.1.2:5000\u0026#34;) #控制追踪的模式,默认0,0,所有模块都初始化;1,只有核心函数模块初始化;2,只有使用flags和functions的模块初始化 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_init_mode\u0026#34;, 1) # 追踪模式,默认0,0,不自动镜像或者存储sip信息;1,镜像sip信息到HEP server;2,存储sip信息到数据库;3,镜像SIP消息到duplicate_uri modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_mode\u0026#34;, 3) # 默认0, 1,使用外网ip发送sip消息 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;data_mode\u0026#34;, 1) # 追踪对话的ACK消息,默认1 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_dialog_ack\u0026#34;, 1) 重要函数 sip_trace([address][, correlation_id][, mode]) 存储或者转发当前的SIP message/transaction/dialog到数据库,mode参数:\n当前的message(\u0026rsquo;m') 当前的transaction(\u0026rsquo;t') 当前的dialog(\u0026rsquo;d') sip_trace_mode(tmode) 设置追踪模式,tmode参数:\n\u0026ldquo;m\u0026rdquo;/\u0026ldquo;M\u0026rdquo; message \u0026ldquo;t\u0026rdquo;/\u0026ldquo;T\u0026rdquo; transaction \u0026ldquo;d\u0026rdquo;/\u0026ldquo;D\u0026rdquo; dialog sip_trace_msg(vmsg, saddr, taddr, daddr, corrid) 发送vmsg到 HEP server(daddr), 设置saddr为源地址, taddr为目的地址, corrid为correlation_id。\nsaddr和taddr为proto:ip:port, daddr为:sip:ip:port\nhlog([correlation_id,] message) 发送log事件到HEP3 server\n实战 存储到数据库 记录所有： 1 2 3 4 loadmodule \u0026#34;siptrace.so\u0026#34; modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_on\u0026#34;, 1) modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_mode\u0026#34;, 2) 不需要调用sip_trace(), 所有的信息都能存储到数据表sip_trace中. 可以看到,REGISTER, INVITE, BYE等SIP消息都能存储到数据库中,还有direction 字段, 表示当前SIP消息是in还是out. wss也能记录到数据库中。\n但是这种记录所有的信息,太频繁了,sip_trace表还得分表, 影响性能。接下来介绍如何只记录指定的SIP消息。\n记录指定的SIP消息\n追踪所有的,过滤掉不想要的SIP消息 1 2 3 4 5 6 7 8 9 10 loadmodule \u0026#34;siptrace.so\u0026#34; modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_on\u0026#34;, 1) modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_mode\u0026#34;, 2) ... event_route[siptrace:msg] { if(is_method(\u0026#34;OPTIONS\u0026#34;)|| is_method(\u0026#34;REGISTER\u0026#34;)) { drop(); } } 数据库可以看到REGISTER没被记录到数据库中.\n追踪指定的SIP消息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 loadmodule \u0026#34;siptrace.so\u0026#34; modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;traced_user_avp\u0026#34;, \u0026#34;$avp(user)\u0026#34;) modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_on\u0026#34;, 1) modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_init_mode\u0026#34;, 0) ... request_route{ ... route(WITHINDLG); ... if (is_method(\u0026#34;INVITE\u0026#34;) \u0026amp;\u0026amp; !has_totag()) { dlg_manage(); sip_trace_mode(\u0026#34;t\u0026#34;); sip_trace(); } } route[WITHINDLG] { if (!has_totag()) return; sip_trace_mode(\u0026#34;t\u0026#34;); ... } 记录会话的SIP消息: 使用sip_trace_mode(\u0026quot;d\u0026quot;)报错failed to serialize siptrace info! Won't trace dialog!, 数据库中只记录INVITE其他的信令没有,已提issue解答。 注意: trace_mode不要设置成2,不然还是存所有的SIP信息,sip_trace_mode(\u0026quot;d\u0026quot;)就没有用.\n发送到HEP server hep server 本次的hep server使用的是:hep-connect\n1 2 3 4 5 6 7 8 9 10 11 docker run -d -p 9060:9060/udp --restart=always \\ -e TZ=Asia/Shanghai \\ -e LogLevel=debug \\ -e DBAddr=\u0026#34;172.16.4.111\u0026#34; \\ -e DBName=\u0026#34;postgres\u0026#34; \\ -e DBUser=\u0026#34;postgres\u0026#34; \\ -e DBPort=\u0026#34;5432\u0026#34; \\ -e DBPasswd=\u0026#34;123456\u0026#34; \\ -e MaxBatchItems=\u0026#34;100\u0026#34; \\ --name hep-connect \\ eddiemurphy5/hep-connect:latest kamailio配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 listen=udp:172.16.4.113:5461 # 加载siptrace loadmodule \u0026#34;siptrace.so\u0026#34; # hep-connect地址 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;duplicate_uri\u0026#34;, \u0026#34;sip:172.16.4.111:9060\u0026#34;) # Kamailio本地监听端口, 对应了listen=udp:172.16.4.113:5461 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;send_sock_addr\u0026#34;, \u0026#34;sip:172.16.4.113:5461\u0026#34;) modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;hep_mode_on\u0026#34;, 1) modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;hep_version\u0026#34;, 3) modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_to_database\u0026#34;, 0) modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;trace_on\u0026#34;, 1) ... request_route { ... route(WITHINDLG); ... if (is_method(\u0026#34;INVITE\u0026#34;) \u0026amp;\u0026amp; !has_totag()) { dlg_manage(); sip_trace_mode(\u0026#34;t\u0026#34;); } } route[WITHINDLG] { if (!has_totag()) return; sip_trace_mode(\u0026#34;t\u0026#34;); ... } 说明几点配置问题:\ntrace_to_database要设置成0,不然需要配置数据库 sip_trace_mode() 要设置成t,如果设置成d,会报错failed to serialize siptrace info! Won't trace dialog!,目前暂未成功使用过d. sip_trace_mode(\u0026quot;t\u0026quot;), 如果想要跟踪完整的会话信令，并不是收到INVITE设置一次就可以了,还要在has_totag()里再设置一次, 否则只能跟踪200OK之前的信令，接通之后的BYE,ACK都不会跟踪到。 sip_trace_mode(\u0026quot;t\u0026quot;)设置之后还可以再设置sip_trace(),效果是一样的。 测试效果 完整的记录： HEP 以tcp的方式发送\n1 2 3 4 5 listen=tcp:172.16.4.113:5461 # hep-connect地址 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;duplicate_uri\u0026#34;, \u0026#34;sip:172.16.4.111:9060;transport=tcp\u0026#34;) # Kamailio本地监听端口, 对应了listen=tcp:172.16.4.113:5461 modparam(\u0026#34;siptrace\u0026#34;, \u0026#34;send_sock_addr\u0026#34;, \u0026#34;sip:172.16.4.113:5461;transport=tcp\u0026#34;) 其他的配置和上面的一样, HEPv3默认使用的是tcp协议, 需要在duplicate_uri和send_sock_addr中添加;transport=tcp 虽然listen监听的是tcp:5461,但是因为kamailio是客户端,所以其发出去的tcp端口是随机的,但是kamailio还是要检查你是否监听了5461端口\n说明:hep-connect目前只支持HEPv3 udp方式，我测试使用自己修改的方式接收数据的。\n","date":"2025-04-02T09:14:06+08:00","image":"https://QuincyGao.github.io/p/kamailio-siptrace%E4%BB%8B%E7%BB%8D/backup_hu4934293144052916046.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-siptrace%E4%BB%8B%E7%BB%8D/","title":"kamailio siptrace介绍"},{"content":"背景介绍 dialplan 主要用于号码转换,规则匹配替换等. 必须依赖数据库，从数据库读取规则。\nkamailio 的版本:\nversion: kamailio 5.8.5 (x86_64/linux)\n参数解析 1 2 3 4 5 6 7 8 # 指定数据库地址 modparam(\u0026#34;dialplan\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) # 获取表字段attrs存储的的变量 modparam(\u0026#34;dialplan\u0026#34;, \u0026#34;attrs_pvar\u0026#34;, \u0026#34;$avp(s:dest)\u0026#34;) # dialplain 是否动态匹配 modparam(\u0026#34;dialplan\u0026#34;, \u0026#34;match_dynamic\u0026#34;, 1) # 重新加载的延迟时间,默认5s modparam(\u0026#34;dialplan\u0026#34;, \u0026#34;reload_delta\u0026#34;, 1) 重要函数 dp_replace(dpid, inval, outvar) 根据dpid规则,把inval替换成dpid表达式下的数据存储在outvar中.\ndp_match(dpid, inval) 根据dpid规则匹配inval\ndp_translate(id, [src[/dest]]) 根据id规则转换src成dest,如果没有dest,只匹配src,并存储attrs到$avp(s:dest)里。此id还是dpid\n实战 构造数据 表结构 name type size default null key extra attributes description id unsigned int 10 no primary auto increment unique ID dpid int 11 no Dialplan ID pr int 11 no Priority of rule match_op int 11 no Matching operator for rule (0-equal, 1-regexp) match_exp string 64 no Matching expression (regexp or string) match_len int 11 no Length of the matching expression (used only for equal operator) subst_exp string 64 no Substitution expression repl_exp string 256 no Replacement expression (sed like) attrs string 64 no General attributes string to be returned in case of rule matching 所有的字段都要填写\n数据 1 INSERT INTO `dialplan` VALUES (1,100,10,0,\u0026#39;1004\u0026#39;,0,\u0026#39;1004\u0026#39;,\u0026#39;200$fU\u0026#39;,\u0026#39;test\u0026#39;);` 配置示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 loadmodule \u0026#34;dialplan.so\u0026#34; modparam(\u0026#34;dialplan\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;dialplan\u0026#34;, \u0026#34;attrs_pvar\u0026#34;, \u0026#34;$avp(s:dest)\u0026#34;) modparam(\u0026#34;dialplan\u0026#34;, \u0026#34;match_dynamic\u0026#34;, 1) modparam(\u0026#34;dialplan\u0026#34;, \u0026#34;reload_delta\u0026#34;, 1) ... request_route { ... dp_replace(\u0026#34;100\u0026#34;, \u0026#34;$fU\u0026#34;, \u0026#34;$var(newru)\u0026#34;); xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;$fU:$var(newru), $avp(s:dest)\\n\u0026#34;); # per request initial checks route(REQINIT); ... } 目前使用的规则是号码添加前缀200, 实际效果打印的日志为:\n1 \u0026lt;script\u0026gt;: 1004:2001004, test ","date":"2025-03-31T10:16:43+08:00","image":"https://QuincyGao.github.io/p/kamailio-dialplan-%E4%BB%8B%E7%BB%8D/backup_hu3537493523197711888.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-dialplan-%E4%BB%8B%E7%BB%8D/","title":"kamailio dialplan 介绍"},{"content":"背景介绍 kamailio 的dispatcher模块提供负载均衡功能,可以采用轮询,负载上的权重,通话负载分发和哈希方式。 该模块比较轻量，适合高并发场景。但是不能分发REGISTER请求。\n它和opensips的dispatcher不一样,opensips的dispatcher可以分发REGISTER请求。 它更像是opensips的load_balancer。\n这个模块既可以使用数据库，也可以使用文件来配置。官方文档地址:dispatcher\nkamailio的版本:\nversion: kamailio 5.8.5 (x86_64/linux)\n重要参数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # 设置dispatcher配置加载的文件 modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;list_file\u0026#34;, \u0026#34;/run/kamailio/dispatcher.list\u0026#34;) # 设置从数据库中加载dispather配置,默认NULL,不从数据库加载 modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;db_url\u0026#34;, \u0026#34;mysql://user:passwd@localhost/kamailio\u0026#34;) # 确定分发的方式，是位掩码,默认0,使用username,hostname,port来计算URI哈希;1,使用username计算URI哈希;2,分发失败后,可以尝试下一个地址。 modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;flags\u0026#34;, 3) # 目的地址集的最后一个地址作为发送地址,默认0 modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;use_default\u0026#34;, 1) #存储分发地址的AVP变量名,默认: _dsdst_ modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;xavp_dst\u0026#34;, \u0026#34;_dsdst_\u0026#34;) # 控制哪些参数存XAVP_DST里, modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;xavp_dst_mode\u0026#34;, 1) # ping方式,默认: OPTIONS modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_ping_method\u0026#34;, \u0026#34;OPTIONS\u0026#34;) # ping的from地址 modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_ping_from\u0026#34;, \u0026#34;sip:proxy@sip.somehost.com\u0026#34;) # ping的时间间隔,默认0, 不能ping modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_ping_interval\u0026#34;, 30) # ping使用的地址,必须提前监听 modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_default_socket\u0026#34;, \u0026#34;udp:192.168.0.125:5060\u0026#34;) # ping失败多少次数后,把gateway标记为不可用,默认1 modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_probing_threshold\u0026#34;, 10) # gateway从不活跃状态恢复到活跃态,需要ping多少次,默认1 modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_inactive_threshold\u0026#34;, 10) # 定义合法的ping响应码,默认:\u0026#34;\u0026#34;,只接受200OK modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_ping_reply_codes\u0026#34;, \u0026#34;class=2;code=403;code=488;class=3\u0026#34;) # 0, 只有PROBING状态的gateway会ping;1, 所有gateway都会ping; # 2,只有INACTIVE状态并且处于PROBING的gateway会ping;3,持续探测任何状态为PROBING的gateway modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_probing_mode\u0026#34;, 1) # 设置定时器进程的运行模式,0, 使用主定时器;1,使用次定时器。 modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_timer_mode\u0026#34;, 1) # 当gateway配置错误时,1,报错;2,跳过错误的gateway,继续下一个 modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_load_mode\u0026#34;, 1) # 当重新加载dispatcher配置时,延迟多少秒,默认5s modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;reload_delta\u0026#34;, 1) 重要函数 ds_select_dst(set, alg[, limit]) 从地址集中选择一个地址，然后把地址设置到$du,\nset 表dispatcher的setid alg 负载均衡算法,可多个叠加: \u0026ldquo;0\u0026rdquo;: 哈希callid \u0026ldquo;1\u0026rdquo;: 哈希from URI \u0026ldquo;2\u0026rdquo;: 哈希to URI \u0026ldquo;3\u0026rdquo;: 哈希request-URI user \u0026ldquo;4\u0026rdquo;: 轮询 \u0026ldquo;5\u0026rdquo;: 哈希authorization-username,如果没有此字段,使用轮询 \u0026ldquo;6\u0026rdquo;: 随机 \u0026ldquo;7\u0026rdquo;: 哈希PVs,必须设置hash_pvar \u0026ldquo;8\u0026rdquo;: 使用dispatcher表里按照priority排序的gateway \u0026ldquo;9\u0026rdquo;: 权重分发，使用dispatcher表里按照weight排序的gateway \u0026ldquo;10\u0026rdquo;: 使用通话负载分发,必须设置ds_hash_size和dispatcher表的attrs添加duid,速度很快 \u0026ldquo;11\u0026rdquo;: 使用相对权重分发, dispatcher表的attrs添加rweight, 相对于权重分发,如果有gateway不活跃了,每次会重新计算权重 \u0026ldquo;12\u0026rdquo;: 分发所有节点 \u0026ldquo;13\u0026rdquo;: 延迟分发ds_ping_latency_stats, 使用的是轮询分发 ds_next_dst() 获取下一个地址,并设置$du。\nds_set_dst() 把当前的地址设置为$du。\nds_select_domain(set, alg[, limit]) 从地址集中选择一个地址,然后重写R-URI里的host和Port,其他参数和ds_select_dst一致。\nds_next_domain() 获取下一个地址,并设置R-URI。\nds_set_domain() 把当前的地址设置为R-URI。\nds_select(set, alg[, limit]) 从地址集中选择一个地址,存在XAVP变量里,不会重写R-URI和$du\nds_select_routes(rules, mode [, limit]) 按照规则从地址集中选择一个地址\nrules 匹配规则,格式为grp1=alg1;grp2=alg2 mode 选择的地址推到哪里 \u0026lsquo;0\u0026rsquo;,\u0026rsquo;d\u0026rsquo;,\u0026lsquo;D\u0026rsquo;: 修改$du \u0026lsquo;1\u0026rsquo;,\u0026lsquo;r\u0026rsquo;,\u0026lsquo;R\u0026rsquo;: 修改R-URI \u0026lsquo;2\u0026rsquo;,\u0026lsquo;x\u0026rsquo;,\u0026lsquo;X\u0026rsquo;: 存储在XAVP变量 ds_mark_dst([state]) 标记上次使用的地址状态\nstate \u0026ldquo;a\u0026rdquo;,\u0026ldquo;A\u0026rdquo;: 活跃状态 \u0026ldquo;i\u0026rdquo;,\u0026ldquo;I\u0026rdquo;: 非活跃状态 \u0026ldquo;t\u0026rdquo;,\u0026ldquo;T\u0026rdquo;: 尝试状态 \u0026ldquo;p\u0026rdquo;,\u0026ldquo;P\u0026rdquo;: 可探测状态 实战 本次测试的场景是:\n软电话1008注册到freeswitch A(172.18.11.187)上, A配置网关转发请求到kamailio (172.16.4.111) 1008拨打1003, kamailio(172.16.4.111)收到请求, dispatcher分发给freeswitch B(172.16.4.113)或 freeswitch C(172.16.4.114) 两个软电话分别向freeswitch B和freeswitch C注册1003 B或者C收到请求,拨打软电话,电话接通 从文件读取 dispatcher.list 1 2 3 # setid(int) destination(sip uri) flags(int,opt) priority(int,opt) attributes(str,opt) 1 sip:172.16.4.114:5060 0 5 class=4;socket=udp:172.16.4.111:5460;pipe=p10 1 sip:172.16.4.113:5060 0 5 class=4;socket=udp:172.16.4.111:5460;pipe=p10 这里要介绍一下attributes参数:\nclass=4 接受错误码为400~499的响应 strip=3 从被叫号码（R-URI）中去除前3位 prefix=86 在被叫号码（R-URI）前加上86 duid=abc 唯一标识目标节点 maxload=30 最大负载值，超过则拒绝 weight=5 1~100,权重，总和为100，权重越大,请求越多 rweight=5 1~100,相对权重，总和为100 socket=udp:127.0.0.1:5060 定义分发请求的socket,覆盖ds_default_socket socketname=xxx 定义分发请求的socket name ping_from 定义ping的From URI,覆盖ds_ping_from obproxy latency 配置示例: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 listen=udp:172.16.4.111:5460 listen=udp:172.16.4.111:5461 listen=udp:172.16.4.111:5464 loadmodule \u0026#34;dispatcher.so\u0026#34; modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;list_file\u0026#34;, \u0026#34;/usr/local/etc/kamailio/dispatcher.list\u0026#34;) modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;xavp_dst\u0026#34;, \u0026#34;_dsdst_\u0026#34;) modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;xavp_ctx\u0026#34;, \u0026#34;_dsctx_\u0026#34;) modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;flags\u0026#34;, 2) modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_ping_method\u0026#34;, \u0026#34;OPTIONS\u0026#34;) modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_ping_from\u0026#34;, \u0026#34;sip:proxy@172.16.4.111\u0026#34;) modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_ping_interval\u0026#34;, 30) modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_default_socket\u0026#34;, \u0026#34;udp:172.16.4.111:5461\u0026#34;) modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_timer_mode\u0026#34;, 1) modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_probing_threshold\u0026#34;, 2) modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_inactive_threshold\u0026#34;, 3) modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_probing_mode\u0026#34;, 1) modparam(\u0026#34;dispatcher\u0026#34;, \u0026#34;ds_hash_size\u0026#34;, 9) ... request_route { ... route(REGISTRAR); if ($rU==$null) { # request with no Username in RURI sl_send_reply(\u0026#34;484\u0026#34;, \u0026#34;Address Incomplete\u0026#34;); exit; } route(DISPATCH); # dispatch destinations to PSTN #route(PSTN); # user location service #route(LOCATION); return; } route[DISPATCH] { # round robin dispatching on gateways group \u0026#39;1\u0026#39; if(!ds_select_dst(\u0026#34;1\u0026#34;, \u0026#34;4\u0026#34;)) { send_reply(\u0026#34;404\u0026#34;, \u0026#34;No destination\u0026#34;); exit; } xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;----- going to $ru via $du (attrs: $xavp(_dsdst_=\u0026gt;attrs))\\n\u0026#34;); t_on_failure(\u0026#34;RTF_DISPATCH\u0026#34;); route(RELAY); exit; } failure_route[RTF_DISPATCH] { if (t_is_canceled()) { exit; } # next DST - only for 500 or local timeout if (t_check_status(\u0026#34;500\u0026#34;) or (t_branch_timeout() and !t_branch_replied())) { if(ds_next_dst()) { xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;--- SCRIPT: retrying to \u0026lt;$ru\u0026gt; via \u0026lt;$du\u0026gt; (attrs: $xavp(_dsdst_=\u0026gt;attrs))\\n\u0026#34;); t_on_failure(\u0026#34;RTF_DISPATCH\u0026#34;); route(RELAY); exit; } } } event_route[dispatcher:dst-down] { xlog(\u0026#34;L_ERR\u0026#34;, \u0026#34;-----------------Destination down: $rm $ru ($du)\\n\u0026#34;); } event_route[dispatcher:dst-up] { xlog(\u0026#34;L_ERR\u0026#34;, \u0026#34;-----------------Destination up: $rm $ru\\n\u0026#34;); } 测试效果 ping kamailio 分别往两个节点发送OPTIONS请求\n172.16.4.113机器: 172.16.4.114机器: 正常拨打电话 可以看到ds_select_dst配置的是轮询,所以不管第一通172.16.4.113是否接通,第二通都会转到172.16.4.114节点\n注意: 一定不要配置modparam(\u0026quot;dispatcher\u0026quot;, \u0026quot;use_default\u0026quot;, 1), 否则不管配置的策略是什么,都只会往一个节点发送请求。\n当其中一个节点停掉 停掉172.16.4.113节点的freeswitch,在dispatcher未标记此节点为非活跃状态之前，请求还是会发往此节点的。 dispatcher标记172.16.4.113状态为非活跃状态之后，所有的请求只会转到172.16.4.114节点。 存在的问题 dispatcher模块目前没有找到配置可以让服务一启动就开始ping节点。 这就会导致服务启动后，在ping的定时器开始之前，如果有请求过来，不会分发请求。\n当然可以缩短ds_ping_interval间隔，但是这样的话，ping的频率会变高。\n","date":"2025-03-27T08:55:38+08:00","image":"https://QuincyGao.github.io/p/kamailio-dispatcher%E4%BB%8B%E7%BB%8D/backup_hu7820894276915030663.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-dispatcher%E4%BB%8B%E7%BB%8D/","title":"kamailio dispatcher介绍"},{"content":"背景介绍 当kamailio需要做集群或者主备时, 需要对集群节点做数据同步。\nDMQ_USRLOC用来对注册用户信息做同步 DMQ用来实现数据同步的方式 Dialog会话信息 本次以常见的两个节点方式为例介绍,kamailio的节点并没有主备的概念,这点和opensips有点不一样。\n节点1 节点2 172.16.4.111 172.16.4.113 kamailo版本:\nversion: kamailio 5.8.5 (x86_64/linux)\nDMQ 模块介绍 DMQ 用于节点之间使用SIP消息(KDMQ)进行同步, 新节点可以通过发送可用的消息通知来加入集群, 如果节点不响应其他活跃节点的消息,那么就会被踢出集群。 集群节点的kamailio版本必须一致。\nDMQ 参数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 本地发送和接收DMQ 消息的地址 modparam(\u0026#34;dmq\u0026#34;, \u0026#34;server_address\u0026#34;, \u0026#34;sip:172.16.4.111:5464\u0026#34;) # 本地监听DMQ消息的地址,默认 NULL modparam(\u0026#34;dmq\u0026#34;, \u0026#34;server_socket\u0026#34;, \u0026#34;udp:172.16.4.111:5464\u0026#34;) # 通知备节点地址,默认 NULL modparam(\u0026#34;dmq\u0026#34;, \u0026#34;notification_address\u0026#34;, \u0026#34;sip:172.16.4.113:5464\u0026#34;) # 通知消息通道,默认\u0026#34;notification_peer\u0026#34; modparam(\u0026#34;dmq\u0026#34;, \u0026#34;notification_channel\u0026#34;, \u0026#34;peers\u0026#34;) # 是否可以解析多个IPv4/IPv6地址,0,只解析第一个地址;非0,通过host解析所有的ip. 默认 0 modparam(\u0026#34;dmq\u0026#34;, \u0026#34;multi_notify\u0026#34;, 1) # DMQ工作线程数量,默认 2 modparam(\u0026#34;dmq\u0026#34;, \u0026#34;num_workers\u0026#34;, 4) # DMQ工作线程休眠时间,默认0 modparam(\u0026#34;dmq\u0026#34;, \u0026#34;worker_usleep\u0026#34;, 0) # DMQ心跳时间,默认 60 秒 modparam(\u0026#34;dmq\u0026#34;, \u0026#34;ping_interval\u0026#34;, 90) 要提前监听listen=udp:172.16.4.111:5462\nDMQ 重要函数 dmq_handle_message() 处理DMQ 消息, 可以用在REQUEST_ROUTE\ndmq_process_message() 和dmq_handle_message()类似，但是处理是立即的,不再是copy这个请求到共享内存中给DMQ workers去处理。\ndmq_send_message(channel, node, body, content_type) 发送DMQ消息到单节点,示例:\ndmq_send_message(\u0026quot;channel1\u0026quot;, \u0026quot;sip:10.0.0.21:5060\u0026quot;, \u0026quot;Message body...\u0026quot;, \u0026quot;text/plain\u0026quot;);\ndmq_bcast_message(channel, body, content_type) 发送DMQ消息到所有节点,示例: dmq_bcast_message(\u0026quot;channel1\u0026quot;, \u0026quot;Message body...\u0026quot;, \u0026quot;text/plain\u0026quot;);\ndmq_t_replicate() 复制当前的SIP消息到所有节点。只能用在REQUEST_ROUTE\ndmq_is_from_node() 判断当前请求是不是被其他的节点发送过。示例:\n1 2 3 4 5 6 7 8 9 if(is_method(\u0026#34;REGISTER\u0026#34;)) { if (dmq_is_from_node()) { # coming from a DMQ node - already authenticated there # now just save contact, etc... } else { # coming from end point - authenticate, save contact, etc... dmq_t_replicate(\u0026#34;1\u0026#34;); # source address checked, skip the loop test } } DMQ 实战 为方便观察server_socket和server_address的区别，特意把这两个的端口设置不同， 以及两个节点的ping_interval时间不一样。\n1节点 172.16.4.111配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 listen=udp:172.16.4.111:5465 loadmodule \u0026#34;dmq.so\u0026#34; modparam(\u0026#34;dmq\u0026#34;, \u0026#34;server_address\u0026#34;, \u0026#34;sip:172.16.4.111:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;server_socket\u0026#34;, \u0026#34;udp:172.16.4.111:5465\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;notification_address\u0026#34;, \u0026#34;sip:172.16.4.113:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;notification_channel\u0026#34;, \u0026#34;peers\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;num_workers\u0026#34;, 4) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;ping_interval\u0026#34;, 30) ... request_route { ... if(is_method(\u0026#34;KDMQ\u0026#34;)) { dmq_process_message(); } ... } 2节点 172.16.4.113配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 listen=udp:172.16.4.113:5464 loadmodule \u0026#34;dmq.so\u0026#34; modparam(\u0026#34;dmq\u0026#34;, \u0026#34;server_address\u0026#34;, \u0026#34;sip:172.16.4.113:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;server_socket\u0026#34;, \u0026#34;udp:172.16.4.113:5465\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;notification_address\u0026#34;, \u0026#34;sip:172.16.4.111:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;notification_channel\u0026#34;, \u0026#34;peers\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;num_workers\u0026#34;, 4) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;ping_interval\u0026#34;, 40) ... request_route { ... if(is_method(\u0026#34;KDMQ\u0026#34;)) { dmq_process_message(); } ... } 172.16.4.111 发送请求的sip信令图如下: 可以看到KDMQ消息发送是通过server_socket发出的,其中的sip信令填充了server_address。\n172.16.4.113 发送请求的sip信令图如下: 同理,和111的情况一致。\n所以为避免占用较多的端口, 可以把server_socket和server_address设置为同一个端口。\n当节点2服务停掉之后,得到的信令图: 可以看到sip消息少了节点2的活跃信息\nDMQ_USRLOC 模块介绍 DMQ_USRLOC 参数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 是否开启DMQ_USRLOC模块,默认 0,不开启 modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;enable\u0026#34;, 1) # 是否在服务一启动时就同步数据,默认 0,不启动同步 modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;sync\u0026#34;, 0) # 批量同步数据条数,同步之后进入batch_usleep时间, 默认0,不开启批量同步 modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;batch_size\u0026#34;, 4000) # 批量同步休眠时间,默认 0,不开启批量同步 modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;batch_usleep\u0026#34;, 1000) # 设置同步消息的大小,最大65536,默认60000 modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;batch_msg_size\u0026#34;, 500000) # 批量同步联系人条数,默认1,最大150 modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;batch_msg_contacts\u0026#34;, 50) # usrloc domain同步参数 modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;usrloc_domain\u0026#34;, \u0026#34;location\u0026#34;) # 是否同步socker信息,默认 0,不同步;1,同步proto:host:port;2,同步socket name; modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;replicate_socket_info\u0026#34;, 1) # 是否同步删除信息,默认 1,同步;0,不同步删除动作,当usrloc的过期时间很短时,此时设置为0,让其自己删除更高效。 modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;usrloc_delete\u0026#34;, 0) DMQ_USRLOC 实战 1节点72.16.4.111配置: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 listen=udp:172.16.4.111:5460 listen=udp:172.16.4.111:5464 loadmodule \u0026#34;dmq.so\u0026#34; modparam(\u0026#34;dmq\u0026#34;, \u0026#34;server_address\u0026#34;, \u0026#34;sip:172.16.4.111:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;server_socket\u0026#34;, \u0026#34;udp:172.16.4.111:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;notification_address\u0026#34;, \u0026#34;sip:172.16.4.113:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;notification_channel\u0026#34;, \u0026#34;peers\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;num_workers\u0026#34;, 4) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;ping_interval\u0026#34;, 30) loadmodule \u0026#34;dmq_usrloc.so\u0026#34; modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;enable\u0026#34;, 1) modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;sync\u0026#34;, 1) modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;batch_msg_contacts\u0026#34;, 50) # 50 contacts / message modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;batch_size\u0026#34;, 10000) # 10000 contacts / batch modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;batch_usleep\u0026#34;, 500000) ... request_route { ... if(is_method(\u0026#34;KDMQ\u0026#34;)) { dmq_handle_message(); } ... } 2节点 172.16.4.113配置: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 listen=udp:172.16.4.113:5460 listen=udp:172.16.4.113:5464 loadmodule \u0026#34;dmq.so\u0026#34; loadmodule \u0026#34;dmq_usrloc.so\u0026#34; modparam(\u0026#34;dmq\u0026#34;, \u0026#34;server_address\u0026#34;, \u0026#34;sip:172.16.4.113:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;server_socket\u0026#34;, \u0026#34;udp:172.16.4.113:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;notification_address\u0026#34;, \u0026#34;sip:172.16.4.111:5464\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;notification_channel\u0026#34;, \u0026#34;peers\u0026#34;) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;num_workers\u0026#34;, 4) modparam(\u0026#34;dmq\u0026#34;, \u0026#34;ping_interval\u0026#34;, 30) modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;enable\u0026#34;, 1) modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;sync\u0026#34;, 1) modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;batch_msg_contacts\u0026#34;, 50) # 50 contacts / message modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;batch_size\u0026#34;, 10000) # 10000 contacts / batch modparam(\u0026#34;dmq_usrloc\u0026#34;, \u0026#34;batch_usleep\u0026#34;, 500000) ... request_route { ... if(is_method(\u0026#34;KDMQ\u0026#34;)) { dmq_handle_message(); } ... } 使用软电话注册到172.16.4.111:5460,sip信令图如下: 172.16.4.111同步注册数据到172.16.4.113的信令图如下: 通过kamctl ul show分别查看111和113机器上存储的usrloc数据:\n172.16.4.111机器: 172.16.4.113机器: 可以知道同步到113机器上的过期时间和111机器上的过期时间不一致。\nDialog 模块介绍 dialog的其他参数暂时不介绍,新增以下配置:\n1 2 3 4 5 modparam(\u0026#34;dialog\u0026#34;, \u0026#34;enable_dmq\u0026#34;, 1) ... if (is_method(\u0026#34;INVITE\u0026#34;)) { dlg_manage(); } dialog 集群效果 使用两个软电话1003,1008注册到172.16.4.111:5460机器上,1003拨打1008, 然后使用kamctl dialog show分别查看两台机器上的dialog信息。\nDMQ发送的sip同步信令: 查看两台机器上的dialog信息:\n172.16.4.111机器: 172.16.4.113机器: 存在的问题 目前当113这个机器上使用 如下的配置：\n1 2 3 if(is_method(\u0026#34;KDMQ\u0026#34;)) { dmq_handle_message(); } DMQ在发送dialog消息时可以返回200Ok。\n但是如果用的是dmq_process_message(),此时会报错 400 Bad Request. 113机器上提示没有解析到content length,目前在github上已提bug了.\n","date":"2025-03-26T09:16:36+08:00","image":"https://QuincyGao.github.io/p/kamailio-%E9%9B%86%E7%BE%A4dmq%E4%BB%8B%E7%BB%8D/backup_hu7940699364098095192.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-%E9%9B%86%E7%BE%A4dmq%E4%BB%8B%E7%BB%8D/","title":"kamailio 集群(DMQ)介绍"},{"content":"websocket模块依赖 websocket是http协议的升级,所以kamailio需要xhttp模块, websockets需要tls模块。 在编译kamailio时,需要把xhttp和tls模块库编译进去。\n官方文档地址: websocket模块\n本次测试的kamailio版本是:\nversion: kamailio 5.8.5 (x86_64/linux)\nwebsocket 配置参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 保活机制: 0,不保活;1,ping;2,pong, 默认: 1 modparam(\u0026#34;websocket\u0026#34;, \u0026#34;keepalive_mechanism\u0026#34;, 0) # 多长时间发送一个保活信息到空闲的websockt连接: 默认: 180,单位:秒 modparam(\u0026#34;websocket\u0026#34;, \u0026#34;keepalive_timeout\u0026#34;, 180) # 处理websocket 保活信息的进程数: 默认: 1 modparam(\u0026#34;websocket\u0026#34;, \u0026#34;keepalive_processes\u0026#34;, 2) # 多个处理保活进程运行的时间间隔: 默认: 1,单位:秒 modparam(\u0026#34;websocket\u0026#34;, \u0026#34;keepalive_interval\u0026#34;, 2) # ping/pong 应用程序数据: 默认: \u0026#34;header content\u0026#34; modparam(\u0026#34;websocket\u0026#34;, \u0026#34;ping_application_data\u0026#34;, \u0026#34;WebSockets rock\u0026#34;) # 支持的通过websocket发送的数据协议, 1,sip;2,msrp,默认1 modparam(\u0026#34;websocket\u0026#34;, \u0026#34;sub_protocols\u0026#34;, 1) # 配置跨域,0,不添加;1,添加\u0026#34;Access-Control-Allow-Origin: *\u0026#34;;2,添加\u0026#34;Access-Control-Allow-Origin:\u0026#34;值为请求的\u0026#34;Origin\u0026#34;; modparam(\u0026#34;websocket\u0026#34;, \u0026#34;cors_mode\u0026#34;, 2) #是否打印websocket连接列表,默认0(不打印) modparam(\u0026#34;websocket\u0026#34;, \u0026#34;verbose_list\u0026#34;, 1) # 每个时间处理进程运行间隔,默认1,单位秒 modparam(\u0026#34;websocket\u0026#34;, \u0026#34;timer_interval\u0026#34;, 5) # 待删除的连接多久之后开始删除,默认5,单位秒 modparam(\u0026#34;websocket\u0026#34;, \u0026#34;rm_delay_interval\u0026#34;, 2) websocket 实战 场景一(websocket注册到kamailio) 配置参考 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 #!define WITH_MYSQL #!define WITH_USRLOCDB #!define WITH_NAT #!define WITH_RTPENGINE #!define WITH_JSONRPC log_prefix=\u0026#34;|$timef(%y-%m-%d %H:%M:%S)|$ci| \u0026#34; listen=udp:172.16.4.111:5460 listen=udp:172.16.4.111:5461 listen=tcp:172.16.4.111:5461 #!ifdef WITH_MYSQL loadmodule \u0026#34;db_mysql.so\u0026#34; #!endif #!ifdef WITH_JSONRPC loadmodule \u0026#34;xhttp.so\u0026#34; #!endif #!ifdef WITH_NAT loadmodule \u0026#34;nathelper.so\u0026#34; #!ifdef WITH_RTPENGINE loadmodule \u0026#34;rtpengine.so\u0026#34; #!else loadmodule \u0026#34;rtpproxy.so\u0026#34; #!endif #!endif loadmodule \u0026#34;dialog.so\u0026#34; modparam(\u0026#34;dialog\u0026#34;, \u0026#34;enable_stats\u0026#34;, 1) loadmodule \u0026#34;websocket.so\u0026#34; modparam(\u0026#34;websocket\u0026#34;, \u0026#34;keepalive_mechanism\u0026#34;, 1) modparam(\u0026#34;websocket\u0026#34;, \u0026#34;keepalive_timeout\u0026#34;, 30) modparam(\u0026#34;websocket\u0026#34;, \u0026#34;keepalive_processes\u0026#34;, 2) modparam(\u0026#34;websocket\u0026#34;, \u0026#34;keepalive_interval\u0026#34;, 2) modparam(\u0026#34;websocket\u0026#34;, \u0026#34;ping_application_data\u0026#34;, \u0026#34;WebSockets rock\u0026#34;) # ----- jsonrpcs params ----- modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;pretty_format\u0026#34;, 1) /* set the path to RPC fifo control file */ #modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;fifo_name\u0026#34;, \u0026#34;/run/kamailio/kamailio_rpc.fifo\u0026#34;) #modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;fifo_mode\u0026#34;, 0660) #modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;fifo_group\u0026#34;, \u0026#34;root\u0026#34;) #modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;fifo_user\u0026#34;, \u0026#34;root\u0026#34;) /* set the path to RPC unix socket control file */ # modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;dgram_socket\u0026#34;, \u0026#34;/run/kamailio/kamailio_rpc.sock\u0026#34;) #!ifdef WITH_JSONRPC modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;transport\u0026#34;, 7) #!endif # ----- ctl params ----- /* set the path to RPC unix socket control file */ # modparam(\u0026#34;ctl\u0026#34;, \u0026#34;binrpc\u0026#34;, \u0026#34;unix:/run/kamailio/kamailio_ctl\u0026#34;) # ----- sanity params ----- modparam(\u0026#34;sanity\u0026#34;, \u0026#34;autodrop\u0026#34;, 0) # ----- tm params ----- # auto-discard branches from previous serial forking leg modparam(\u0026#34;tm\u0026#34;, \u0026#34;failure_reply_mode\u0026#34;, 3) # default retransmission timeout: 30sec modparam(\u0026#34;tm\u0026#34;, \u0026#34;fr_timer\u0026#34;, 30000) # default invite retransmission timeout after 1xx: 120sec modparam(\u0026#34;tm\u0026#34;, \u0026#34;fr_inv_timer\u0026#34;, 120000) # ----- rr params ----- # set next param to 1 to add value to ;lr param (helps with some UAs) modparam(\u0026#34;rr\u0026#34;, \u0026#34;enable_full_lr\u0026#34;, 0) # do not append from tag to the RR (no need for this script) modparam(\u0026#34;rr\u0026#34;, \u0026#34;append_fromtag\u0026#34;, 0) # ----- registrar params ----- modparam(\u0026#34;registrar\u0026#34;, \u0026#34;method_filtering\u0026#34;, 1) /* uncomment the next line to disable parallel forking via location */ # modparam(\u0026#34;registrar\u0026#34;, \u0026#34;append_branches\u0026#34;, 0) /* uncomment the next line not to allow more than 10 contacts per AOR */ # modparam(\u0026#34;registrar\u0026#34;, \u0026#34;max_contacts\u0026#34;, 10) /* max value for expires of registrations */ modparam(\u0026#34;registrar\u0026#34;, \u0026#34;max_expires\u0026#34;, 3600) /* set it to 1 to enable GRUU */ modparam(\u0026#34;registrar\u0026#34;, \u0026#34;gruu_enabled\u0026#34;, 0) /* set it to 0 to disable Path handling */ modparam(\u0026#34;registrar\u0026#34;, \u0026#34;use_path\u0026#34;, 1) /* save Path even if not listed in Supported header */ modparam(\u0026#34;registrar\u0026#34;, \u0026#34;path_mode\u0026#34;, 0) # ----- usrloc params ----- modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;timer_interval\u0026#34;, 60) modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;timer_procs\u0026#34;, 1) modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;use_domain\u0026#34;, MULTIDOMAIN) /* enable DB persistency for location entries */ #!ifdef WITH_USRLOCDB modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;db_url\u0026#34;, DBURL) modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;db_mode\u0026#34;, 0) modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;hash_size\u0026#34;, 12) #!endif #!ifdef WITH_NAT #!ifdef WITH_RTPENGINE # ----- rtpengine params ----- modparam(\u0026#34;rtpengine\u0026#34;, \u0026#34;rtpengine_sock\u0026#34;, \u0026#34;udp:172.16.4.111:2222\u0026#34;) #!else # ----- rtpproxy params ----- modparam(\u0026#34;rtpproxy\u0026#34;, \u0026#34;rtpproxy_sock\u0026#34;, \u0026#34;udp:127.0.0.1:7722\u0026#34;) #!endif # ----- nathelper params ----- modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;natping_interval\u0026#34;, 30) modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;ping_nated_only\u0026#34;, 1) modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;sipping_bflag\u0026#34;, FLB_NATSIPPING) modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;sipping_from\u0026#34;, \u0026#34;sip:pinger@kamailio.org\u0026#34;) # params needed for NAT traversal in other modules modparam(\u0026#34;nathelper|registrar\u0026#34;, \u0026#34;received_avp\u0026#34;, \u0026#34;$avp(RECEIVED)\u0026#34;) modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;nat_bflag\u0026#34;, FLB_NATB) #!endif ... # JSONRPC over HTTP(S) routing #!ifdef WITH_JSONRPC event_route[xhttp:request] { set_reply_close(); set_reply_no_connect(); #if(src_ip!=127.0.0.1) { # xhttp_reply(\u0026#34;403\u0026#34;, \u0026#34;Forbidden\u0026#34;, \u0026#34;text/html\u0026#34;, # \u0026#34;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Not allowed from $si\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;); # exit; #} #if ($hu =~ \u0026#34;^/RPC\u0026#34;) { # jsonrpc_dispatch(); # exit; #} if ($hdr(Upgrade)=~\u0026#34;websocket\u0026#34; \u0026amp;\u0026amp; $hdr(Connection)=~\u0026#34;Upgrade\u0026#34; \u0026amp;\u0026amp; $rm=~\u0026#34;GET\u0026#34;) { # Validate Host - make sure the client is using the correct # alias for WebSockets if ($hdr(Host) == $null || !is_myself(\u0026#34;sip:\u0026#34; + $hdr(Host))) { xlog(\u0026#34;L_WARN\u0026#34;, \u0026#34;Bad host $hdr(Host)\\n\u0026#34;); xhttp_reply(\u0026#34;403\u0026#34;, \u0026#34;Forbidden\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;); exit; } # Optional... validate Origin - make sure the client is from an # authorised website. For example, # # if ($hdr(Origin) != \u0026#34;http://communicator.MY_DOMAIN\u0026#34; # \u0026amp;\u0026amp; $hdr(Origin) != \u0026#34;https://communicator.MY_DOMAIN\u0026#34;) { # xlog(\u0026#34;L_WARN\u0026#34;, \u0026#34;Unauthorised client $hdr(Origin)\\n\u0026#34;); # xhttp_reply(\u0026#34;403\u0026#34;, \u0026#34;Forbidden\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;); # exit; # } # Optional... perform HTTP authentication # ws_handle_handshake() exits (no further configuration file # processing of the request) when complete in case of failure. if (ws_handle_handshake()) { # Optional... cache some information about the # successful connection xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;------------------ successful websocket connection \\n\u0026#34;); exit; } } xlog(\u0026#34;receive http request:\\n\u0026#34;); xhttp_reply(\u0026#34;200\u0026#34;, \u0026#34;OK\u0026#34;, \u0026#34;text/html\u0026#34;, \u0026#34;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Wrong URL $hu\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;); exit; } #!endif 只需要监听一个tcp端口,加载websockets.so, 然后在event_route[xhttp:request]route中添加如上代码即可.\n只是注册的话, 就可以不需要配置rtpengine了。\n注册 客户端使用JsSip,用户名密码随便填，注册到ws://172.16.4.111:5461上，就能收到相关的注册成功信息了. 场景二(websocket注册到kamailio 然后转到sip服务器) 如何想转到第三方的sip服务器比如freeswitch,可以参考我之前的文章kamailio关于registrar的介绍。 用户名和密码使用1000~1020之间的,密码1234.\ntcp配置方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 route[REGISTRAR] { if (!is_method(\u0026#34;REGISTER\u0026#34;)) return; if(isflagset(FLT_NATS)) { setbflag(FLB_NATB); #!ifdef WITH_NATSIPPING # do SIP NAT pinging setbflag(FLB_NATSIPPING); #!endif } if (!save(\u0026#34;location\u0026#34;,\u0026#34;0x02\u0026#34;)) { sl_reply_error(); } $fs=\u0026#34;tcp:172.16.4.111:5460\u0026#34;; $du=\u0026#34;sip:172.16.4.114:5060;transport=tcp\u0026#34;; route(RELAY); exit; } $fs是kamailio转发请求使用的端口,$du是fs的地址, 配置转发使用的tcp,5460端口就没用了,使用的是随机端口. udp配置方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 route[REGISTRAR] { if (!is_method(\u0026#34;REGISTER\u0026#34;)) return; if(isflagset(FLT_NATS)) { setbflag(FLB_NATB); #!ifdef WITH_NATSIPPING # do SIP NAT pinging setbflag(FLB_NATSIPPING); #!endif } if (!save(\u0026#34;location\u0026#34;,\u0026#34;0x02\u0026#34;)) { sl_reply_error(); } $fs=\u0026#34;udp:172.16.4.111:5460\u0026#34;; $du=\u0026#34;sip:172.16.4.114:5060\u0026#34;; route(RELAY); exit; } 具体的sip交互图为: 转发使用udp和tcp的区别是，转发相当于kamailio是客户端，所以udp必须提前listen, tcp则不需要提前listen,其发送端口是按照系统随机端口区间使用的。\nwebsockets 配置参数 在websocket的配置基础上,定义WITH_TLS,然后监听tls的端口,配置证书\n1 2 3 4 5 6 7 8 9 #!define WITH_TLS alias=\u0026#34;服务域名\u0026#34; listen=tls:172.16.4.113:5462 log_prefix=\u0026#34;|$timef(%y-%m-%d %H:%M:%S)|$ci| \u0026#34; #!ifdef WITH_TLS # ----- tls params ----- modparam(\u0026#34;tls\u0026#34;, \u0026#34;config\u0026#34;, \u0026#34;/usr/local/etc/kamailio/tls.cfg\u0026#34;) #!endif 打开tls.cfg文件,可以看到一下内容:\n1 2 3 4 5 6 7 8 9 10 11 12 13 [server:default] method = TLSv1.2+ verify_certificate = no require_certificate = no private_key = /usr/local/etc/kamailio/域名.key certificate = /usr/local/etc/kamailio/域名.pem #ca_list = /usr/local/etc/kamailio/tls/cacert.pem #crl = /usr/local/etc/kamailio/tls/crl.pem [client:default] #method = TLSv1.2+ verify_certificate = yes require_certificate = yes private_key配置nginx证书的私钥.key文件\ncertificat配置nginx证书的公钥.pem文件\nverify_certificate和require_certificate是验证证书和要求证书功能\nserver:\n配置成yes, 浏览器在访问服务端的wss://172.16.4.113:5462时,需要配置证书,虽然安全，但是比较麻烦，所以一般配置成no\nclient:\n配置成yes, 要求服务端要配置证书,然后客户端验证. 所以一般配制成yes.\nwebsockets 实战 注册转发 使用上面的websocket的注册转发udp的方式，再加上wss的配置，得到的信令图为： 由于wss是加密的，所以sngrep无法查看，只有转发的部分，可以在request_route里添加日志：\n1 xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;$si:$sp|$Ri:$Rp|$pr|$rm\\n\u0026#34;); 打印了协议类型,这样可以在日志中看到wss请求过来了。\n","date":"2025-03-21T09:53:05+08:00","image":"https://QuincyGao.github.io/p/kamailio-websockets%E4%BB%8B%E7%BB%8D/backup_hu1452218715310749411.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-websockets%E4%BB%8B%E7%BB%8D/","title":"kamailio websocket(s)介绍"},{"content":"背景 上一章我们介绍了opensips对接prometheus的方法，这章作为对比， 我们介绍下kamailio对接prometheus的方法。\nkamailio的prometheus监控使用的是xHTTP_PROM模块, 依赖XHTTP模块, 编译时要把这两个模块加上。\nkamailio本次测试使用的版本是:\nversion: kamailio 5.8.5 (x86_64/linux)\nkamailio 配置参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!define WITH_JSONRPC listen=udp:172.16.4.111:5060 listen=tcp:172.16.4.111:5461 loadmodule \u0026#34;dialog.so\u0026#34; modparam(\u0026#34;dialog\u0026#34;, \u0026#34;enable_stats\u0026#34;, 1) loadmodule \u0026#34;xhttp_prom.so\u0026#34; # 设置构建http Reponse 的缓冲区最大的大小,默认为0,自动设置成pkg mem的1/3 modparam(\u0026#34;xhttp_prom\u0026#34;, \u0026#34;xhttp_prom_buf_size\u0026#34;, 1024) # 设置metrics数据过期时间,如果数据未使用，会自动删除,默认是60 min,单位分钟。 modparam(\u0026#34;xhttp_prom\u0026#34;, \u0026#34;xhttp_prom_timeout\u0026#34;, 600) #10 hours # 设置metrics数据统计,默认是\u0026#34;\u0026#34;,有：\u0026#34;all\u0026#34;, \u0026#34;group_name\u0026#34;, \u0026#34;statistic_name\u0026#34; modparam(\u0026#34;xhttp_prom\u0026#34;, \u0026#34;xhttp_prom_stats\u0026#34;, \u0026#34;all\u0026#34;) # 设置metrics数据前缀,默认\u0026#34;kamailio_\u0026#34; #modparam(\u0026#34;xhttp_prom\u0026#34;, \u0026#34;xhttp_prom_beginning\u0026#34;, \u0026#34;\u0026#34;); ... event_route[xhttp:request] { if (prom_check_uri()) prom_dispatch(); else xhttp_reply(\u0026#34;200\u0026#34;, \u0026#34;OK\u0026#34;, \u0026#34;text/html\u0026#34;, \u0026#34;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Wrong URL $hu\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;); } 需要注意的是: 这个模块会把metrics数据缓存在共享内存中,所以在数据量过大时,要适当增加pkg mem。\nprometheus 收集数据 prometheus 配置 按照上一章的prometheus配置,修改prometheus.yaml文件为:\n1 2 3 4 5 6 7 8 9 10 global: scrape_interval: 15s evaluation_interval: 15s external_labels: monitor: \u0026#39;edc-lab-monitor\u0026#39; scrape_configs: - job_name: \u0026#39;kamailio\u0026#39; # 修改名字 static_configs: - targets: [\u0026#39;172.16.4.111:5461\u0026#39;] ##填写kamailio的ip和tcp端口 运行容器：\n1 docker run -d -v ${PWD}/prometheus.yaml:/etc/prometheus/prometheus.yml --restart=always --net=host --name=prometheus prom/prometheus prometheus 查看数据 通过访问:http://172.16.4.111:9090/,查看到的metrics数据如下(如果不知道哪里看收集的数据，可以看上一章的截图)： 有点奇怪的是，这些数据类型都是unknown的, 本来以为这些是有问题的，但是在grafana中可以正常显示,好像没什么影响。 grafana 展示数据 grafana docker 运行 docker 运行命令:\n1 docker run -d -i -p 3000:3000 -e \u0026#34;GF_SERVER_ROOT_URL=http://grafana.server.name\u0026#34; -e \u0026#34;GF_SECURITY_ADMIN_PASSWORD=admin123\u0026#34; --restart=always --name=grafana grafana/grafana grafana 添加数据源 通过访问:http://172.16.4.111:3000/, 新建dashboard, 添加metrics,查看到的数据如下： 总结 opensips和kamailio监控数据都有注册数,通话数，内存，负载等信息。 kamailio 功能较丰富一些，可以使用prom_counter,prom_gauge,prom_histogram来自定义监控数据。 ","date":"2025-03-19T13:48:23+08:00","image":"https://QuincyGao.github.io/p/kamailio-%E6%B7%BB%E5%8A%A0prometheus%E7%9B%91%E6%8E%A7/backup_hu11339965587864543336.jpg","permalink":"https://QuincyGao.github.io/p/kamailio-%E6%B7%BB%E5%8A%A0prometheus%E7%9B%91%E6%8E%A7/","title":"kamailio 添加prometheus监控"},{"content":"背景介绍 本章主要介绍如何添加prometheus监控, 需要使用prometheus模块, prometheus依赖httpd模块, 所以在编译opensips的时候, 需要添加httpd和prometheus模块.\n多说一句，httpd依赖libmcrohttpd, libmcrohttpd的版本一定要大于0.9.50, 不然http请求会有bug: 多次请求httpd服务，会有概率不返回结果， 这个是libmcrohttpd的bug, 官方已经修复了,我用的是1.0.1版本。\nopensips版本是:\nversion: opensips 3.3.10 (x86_64/linux)\nopensips配置参考 1 2 3 4 5 6 7 8 9 10 11 socket=udp:172.16.4.111:5261 ... loadmodule \u0026#34;httpd.so\u0026#34; modparam(\u0026#34;httpd\u0026#34;, \u0026#34;port\u0026#34;, 9998) ... loadmodule \u0026#34;prometheus.so\u0026#34; modparam(\u0026#34;prometheus\u0026#34;, \u0026#34;group_mode\u0026#34;, 1) modparam(\u0026#34;prometheus\u0026#34;, \u0026#34;statistics\u0026#34;, \u0026#34;dialog: usrloc:\u0026#34;) modparam(\u0026#34;prometheus\u0026#34;, \u0026#34;statistics\u0026#34;, \u0026#34;shmem: load: pkmem:\u0026#34;) ... statistics参数可以配置多个, 以空格分隔，使用组的话要带:,如果就想获取组里某个变量，不用带:,比如： modparam(\u0026quot;prometheus\u0026quot;, \u0026quot;statistics\u0026quot;, \u0026quot;processed_dialogs\u0026quot;) 就是 dialog:processed_dialogs的值， 直接使用。\n这些变量在哪里获取呢， 你要使用opensips-cli -x mi get_statistics all 来查看,以下是我的参考：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 (opensips-cli): mi get_statistics all { \u0026#34;shmem:total_size\u0026#34;: 2147483648, \u0026#34;shmem:max_used_size\u0026#34;: 4975904, \u0026#34;shmem:free_size\u0026#34;: 2142650392, \u0026#34;shmem:used_size\u0026#34;: 4599408, \u0026#34;shmem:real_used_size\u0026#34;: 4833256, \u0026#34;shmem:fragments\u0026#34;: 3571, \u0026#34;rpmem:rpm_total_size\u0026#34;: 0, \u0026#34;rpmem:rpm_used_size\u0026#34;: 0, \u0026#34;rpmem:rpm_real_used_size\u0026#34;: 0, \u0026#34;rpmem:rpm_fragments\u0026#34;: 0, \u0026#34;rpmem:rpm_max_used_size\u0026#34;: 0, \u0026#34;rpmem:rpm_free_size\u0026#34;: 0, \u0026#34;core:rcv_requests\u0026#34;: 243, \u0026#34;core:rcv_replies\u0026#34;: 242, \u0026#34;core:fwd_requests\u0026#34;: 0, \u0026#34;core:fwd_replies\u0026#34;: 0, \u0026#34;core:drop_requests\u0026#34;: 0, \u0026#34;core:drop_replies\u0026#34;: 0, \u0026#34;core:err_requests\u0026#34;: 0, \u0026#34;core:err_replies\u0026#34;: 0, \u0026#34;core:bad_URIs_rcvd\u0026#34;: 0, \u0026#34;core:bad_msg_hdr\u0026#34;: 0, \u0026#34;core:slow_messages\u0026#34;: 0, \u0026#34;core:timestamp\u0026#34;: 70159, \u0026#34;net:waiting_udp\u0026#34;: 0, \u0026#34;net:waiting_tcp\u0026#34;: 0, \u0026#34;net:waiting_tls\u0026#34;: 0, \u0026#34;dns:dns_total_queries\u0026#34;: 0, \u0026#34;dns:dns_slow_queries\u0026#34;: 0, \u0026#34;sql:sql_total_queries\u0026#34;: 0, \u0026#34;sql:sql_slow_queries\u0026#34;: 0, \u0026#34;cdb:cdb_total_queries\u0026#34;: 2189, \u0026#34;cdb:cdb_slow_queries\u0026#34;: 0, \u0026#34;tm:received_replies\u0026#34;: 242, \u0026#34;tm:relayed_replies\u0026#34;: 242, \u0026#34;tm:local_replies\u0026#34;: 0, \u0026#34;tm:UAS_transactions\u0026#34;: 242, \u0026#34;tm:UAC_transactions\u0026#34;: 0, \u0026#34;tm:2xx_transactions\u0026#34;: 158, \u0026#34;tm:3xx_transactions\u0026#34;: 0, \u0026#34;tm:4xx_transactions\u0026#34;: 84, \u0026#34;tm:5xx_transactions\u0026#34;: 0, \u0026#34;tm:6xx_transactions\u0026#34;: 0, \u0026#34;tm:inuse_transactions\u0026#34;: 0, \u0026#34;sl:1xx_replies\u0026#34;: 0, \u0026#34;sl:2xx_replies\u0026#34;: 0, \u0026#34;sl:3xx_replies\u0026#34;: 0, \u0026#34;sl:4xx_replies\u0026#34;: 0, \u0026#34;sl:5xx_replies\u0026#34;: 0, \u0026#34;sl:6xx_replies\u0026#34;: 0, \u0026#34;sl:sent_replies\u0026#34;: 0, \u0026#34;sl:sent_err_replies\u0026#34;: 0, \u0026#34;sl:received_ACKs\u0026#34;: 0, \u0026#34;usrloc:registered_users\u0026#34;: 1, \u0026#34;usrloc:location-users\u0026#34;: 1, \u0026#34;usrloc:location-contacts\u0026#34;: 1, \u0026#34;usrloc:location-expires\u0026#34;: 1, \u0026#34;registrar:max_expires\u0026#34;: 0, \u0026#34;registrar:max_contacts\u0026#34;: 0, \u0026#34;registrar:default_expire\u0026#34;: 3600, \u0026#34;registrar:accepted_regs\u0026#34;: 169, \u0026#34;registrar:rejected_regs\u0026#34;: 0, \u0026#34;dialog:active_dialogs\u0026#34;: 0, \u0026#34;dialog:early_dialogs\u0026#34;: 0, \u0026#34;dialog:processed_dialogs\u0026#34;: 0, \u0026#34;dialog:expired_dialogs\u0026#34;: 0, \u0026#34;dialog:failed_dialogs\u0026#34;: 0, \u0026#34;dialog:create_sent\u0026#34;: 0, \u0026#34;dialog:update_sent\u0026#34;: 0, \u0026#34;dialog:delete_sent\u0026#34;: 0, \u0026#34;dialog:create_recv\u0026#34;: 0, \u0026#34;dialog:update_recv\u0026#34;: 0, \u0026#34;dialog:delete_recv\u0026#34;: 0, \u0026#34;tracer:traced_requests\u0026#34;: 339, \u0026#34;tracer:traced_replies\u0026#34;: 336, \u0026#34;load:load-proc-1\u0026#34;: 0, \u0026#34;load:load1m-proc-1\u0026#34;: 0, \u0026#34;load:load10m-proc-1\u0026#34;: 0, \u0026#34;load:load-proc-2\u0026#34;: 0, \u0026#34;load:load1m-proc-2\u0026#34;: 0, \u0026#34;load:load10m-proc-2\u0026#34;: 0, \u0026#34;load:load-proc-5\u0026#34;: 0, \u0026#34;load:load1m-proc-5\u0026#34;: 0, \u0026#34;load:load10m-proc-5\u0026#34;: 0, \u0026#34;load:load-proc-6\u0026#34;: 0, \u0026#34;load:load1m-proc-6\u0026#34;: 0, \u0026#34;load:load10m-proc-6\u0026#34;: 0, \u0026#34;load:load-proc-7\u0026#34;: 0, \u0026#34;load:load1m-proc-7\u0026#34;: 0, \u0026#34;load:load10m-proc-7\u0026#34;: 0, \u0026#34;load:load-proc-8\u0026#34;: 0, \u0026#34;load:load1m-proc-8\u0026#34;: 0, \u0026#34;load:load10m-proc-8\u0026#34;: 0, \u0026#34;load:load-proc-9\u0026#34;: 0, \u0026#34;load:load1m-proc-9\u0026#34;: 0, \u0026#34;load:load10m-proc-9\u0026#34;: 0, \u0026#34;load:load-proc-10\u0026#34;: 0, \u0026#34;load:load1m-proc-10\u0026#34;: 0, \u0026#34;load:load10m-proc-10\u0026#34;: 0, \u0026#34;load:load-proc-11\u0026#34;: 0, \u0026#34;load:load1m-proc-11\u0026#34;: 0, \u0026#34;load:load10m-proc-11\u0026#34;: 0, \u0026#34;load:load-proc-12\u0026#34;: 0, \u0026#34;load:load1m-proc-12\u0026#34;: 0, \u0026#34;load:load10m-proc-12\u0026#34;: 0, \u0026#34;load:load-proc-13\u0026#34;: 0, \u0026#34;load:load1m-proc-13\u0026#34;: 0, \u0026#34;load:load10m-proc-13\u0026#34;: 0, \u0026#34;load:load-proc-14\u0026#34;: 0, \u0026#34;load:load1m-proc-14\u0026#34;: 0, \u0026#34;load:load10m-proc-14\u0026#34;: 0, \u0026#34;load:load-proc-15\u0026#34;: 0, \u0026#34;load:load1m-proc-15\u0026#34;: 0, \u0026#34;load:load10m-proc-15\u0026#34;: 0, \u0026#34;load:load-proc-16\u0026#34;: 0, \u0026#34;load:load1m-proc-16\u0026#34;: 0, \u0026#34;load:load10m-proc-16\u0026#34;: 0, \u0026#34;load:load-proc-17\u0026#34;: 0, \u0026#34;load:load1m-proc-17\u0026#34;: 0, \u0026#34;load:load10m-proc-17\u0026#34;: 0, \u0026#34;load:load-proc-18\u0026#34;: 0, \u0026#34;load:load1m-proc-18\u0026#34;: 0, \u0026#34;load:load10m-proc-18\u0026#34;: 0, \u0026#34;load:load-proc-19\u0026#34;: 0, \u0026#34;load:load1m-proc-19\u0026#34;: 0, \u0026#34;load:load10m-proc-19\u0026#34;: 0, \u0026#34;load:load-proc-20\u0026#34;: 0, \u0026#34;load:load1m-proc-20\u0026#34;: 0, \u0026#34;load:load10m-proc-20\u0026#34;: 0, \u0026#34;load:load-proc-21\u0026#34;: 0, \u0026#34;load:load1m-proc-21\u0026#34;: 0, \u0026#34;load:load10m-proc-21\u0026#34;: 0, \u0026#34;load:load-proc-22\u0026#34;: 0, \u0026#34;load:load1m-proc-22\u0026#34;: 0, \u0026#34;load:load10m-proc-22\u0026#34;: 0, \u0026#34;load:load-proc-23\u0026#34;: 0, \u0026#34;load:load1m-proc-23\u0026#34;: 0, \u0026#34;load:load10m-proc-23\u0026#34;: 0, \u0026#34;load:load-proc-24\u0026#34;: 0, \u0026#34;load:load1m-proc-24\u0026#34;: 0, \u0026#34;load:load10m-proc-24\u0026#34;: 0, \u0026#34;load:load-proc-25\u0026#34;: 0, \u0026#34;load:load1m-proc-25\u0026#34;: 0, \u0026#34;load:load10m-proc-25\u0026#34;: 0, \u0026#34;load:load-proc-26\u0026#34;: 0, \u0026#34;load:load1m-proc-26\u0026#34;: 0, \u0026#34;load:load10m-proc-26\u0026#34;: 0, \u0026#34;load:load-proc-27\u0026#34;: 0, \u0026#34;load:load1m-proc-27\u0026#34;: 0, \u0026#34;load:load10m-proc-27\u0026#34;: 0, \u0026#34;load:load-proc-28\u0026#34;: 0, \u0026#34;load:load1m-proc-28\u0026#34;: 0, \u0026#34;load:load10m-proc-28\u0026#34;: 0, \u0026#34;load:load-proc-29\u0026#34;: 0, \u0026#34;load:load1m-proc-29\u0026#34;: 0, \u0026#34;load:load10m-proc-29\u0026#34;: 0, \u0026#34;load:load-proc-30\u0026#34;: 0, \u0026#34;load:load1m-proc-30\u0026#34;: 0, \u0026#34;load:load10m-proc-30\u0026#34;: 0, \u0026#34;load:load-proc-31\u0026#34;: 0, \u0026#34;load:load1m-proc-31\u0026#34;: 0, \u0026#34;load:load10m-proc-31\u0026#34;: 0, \u0026#34;load:load-proc-32\u0026#34;: 0, \u0026#34;load:load1m-proc-32\u0026#34;: 0, \u0026#34;load:load10m-proc-32\u0026#34;: 0, \u0026#34;load:load-proc-33\u0026#34;: 0, \u0026#34;load:load1m-proc-33\u0026#34;: 0, \u0026#34;load:load10m-proc-33\u0026#34;: 0, \u0026#34;load:load-proc-34\u0026#34;: 0, \u0026#34;load:load1m-proc-34\u0026#34;: 0, \u0026#34;load:load10m-proc-34\u0026#34;: 0, \u0026#34;load:load-proc-35\u0026#34;: 0, \u0026#34;load:load1m-proc-35\u0026#34;: 0, \u0026#34;load:load10m-proc-35\u0026#34;: 0, \u0026#34;load:load-proc-36\u0026#34;: 0, \u0026#34;load:load1m-proc-36\u0026#34;: 0, \u0026#34;load:load10m-proc-36\u0026#34;: 0, \u0026#34;load:load-proc-37\u0026#34;: 0, \u0026#34;load:load1m-proc-37\u0026#34;: 0, \u0026#34;load:load10m-proc-37\u0026#34;: 0, \u0026#34;load:load-proc-38\u0026#34;: 0, \u0026#34;load:load1m-proc-38\u0026#34;: 0, \u0026#34;load:load10m-proc-38\u0026#34;: 0, \u0026#34;load:load-proc-39\u0026#34;: 0, \u0026#34;load:load1m-proc-39\u0026#34;: 0, \u0026#34;load:load10m-proc-39\u0026#34;: 0, \u0026#34;load:load-proc-40\u0026#34;: 0, \u0026#34;load:load1m-proc-40\u0026#34;: 0, \u0026#34;load:load10m-proc-40\u0026#34;: 0, \u0026#34;load:load-proc-41\u0026#34;: 0, \u0026#34;load:load1m-proc-41\u0026#34;: 0, \u0026#34;load:load10m-proc-41\u0026#34;: 0, \u0026#34;load:load-proc-42\u0026#34;: 0, \u0026#34;load:load1m-proc-42\u0026#34;: 0, \u0026#34;load:load10m-proc-42\u0026#34;: 0, \u0026#34;load:load-proc-43\u0026#34;: 0, \u0026#34;load:load1m-proc-43\u0026#34;: 0, \u0026#34;load:load10m-proc-43\u0026#34;: 0, \u0026#34;load:load-proc-44\u0026#34;: 0, \u0026#34;load:load1m-proc-44\u0026#34;: 0, \u0026#34;load:load10m-proc-44\u0026#34;: 0, \u0026#34;load:load-proc-45\u0026#34;: 0, \u0026#34;load:load1m-proc-45\u0026#34;: 0, \u0026#34;load:load10m-proc-45\u0026#34;: 0, \u0026#34;load:load-proc-46\u0026#34;: 0, \u0026#34;load:load1m-proc-46\u0026#34;: 0, \u0026#34;load:load10m-proc-46\u0026#34;: 0, \u0026#34;load:load-proc-47\u0026#34;: 0, \u0026#34;load:load1m-proc-47\u0026#34;: 0, \u0026#34;load:load10m-proc-47\u0026#34;: 0, \u0026#34;load:load-proc-48\u0026#34;: 0, \u0026#34;load:load1m-proc-48\u0026#34;: 0, \u0026#34;load:load10m-proc-48\u0026#34;: 0, \u0026#34;load:load-proc-49\u0026#34;: 0, \u0026#34;load:load1m-proc-49\u0026#34;: 0, \u0026#34;load:load10m-proc-49\u0026#34;: 0, \u0026#34;load:load-proc-50\u0026#34;: 0, \u0026#34;load:load1m-proc-50\u0026#34;: 0, \u0026#34;load:load10m-proc-50\u0026#34;: 0, \u0026#34;load:load-proc-51\u0026#34;: 0, \u0026#34;load:load1m-proc-51\u0026#34;: 0, \u0026#34;load:load10m-proc-51\u0026#34;: 0, \u0026#34;load:load-proc-52\u0026#34;: 0, \u0026#34;load:load1m-proc-52\u0026#34;: 0, \u0026#34;load:load10m-proc-52\u0026#34;: 0, \u0026#34;load:load-proc-53\u0026#34;: 0, \u0026#34;load:load1m-proc-53\u0026#34;: 0, \u0026#34;load:load10m-proc-53\u0026#34;: 0, \u0026#34;load:load-proc-54\u0026#34;: 0, \u0026#34;load:load1m-proc-54\u0026#34;: 0, \u0026#34;load:load10m-proc-54\u0026#34;: 0, \u0026#34;load:load-proc-55\u0026#34;: 0, \u0026#34;load:load1m-proc-55\u0026#34;: 0, \u0026#34;load:load10m-proc-55\u0026#34;: 0, \u0026#34;load:load-proc-56\u0026#34;: 0, \u0026#34;load:load1m-proc-56\u0026#34;: 0, \u0026#34;load:load10m-proc-56\u0026#34;: 0, \u0026#34;load:load\u0026#34;: 0, \u0026#34;load:load1m\u0026#34;: 0, \u0026#34;load:load10m\u0026#34;: 0, \u0026#34;load:load-all\u0026#34;: 0, \u0026#34;load:load1m-all\u0026#34;: 0, \u0026#34;load:load10m-all\u0026#34;: 0, \u0026#34;load:processes_number\u0026#34;: 57, \u0026#34;pkmem:1-total_size\u0026#34;: 0, \u0026#34;pkmem:1-used_size\u0026#34;: 0, \u0026#34;pkmem:1-real_used_size\u0026#34;: 0, \u0026#34;pkmem:1-max_used_size\u0026#34;: 0, \u0026#34;pkmem:1-free_size\u0026#34;: 0, \u0026#34;pkmem:1-fragments\u0026#34;: 0, \u0026#34;pkmem:2-total_size\u0026#34;: 104857600, \u0026#34;pkmem:2-used_size\u0026#34;: 14733384, \u0026#34;pkmem:2-real_used_size\u0026#34;: 15215088, \u0026#34;pkmem:2-max_used_size\u0026#34;: 15215088, \u0026#34;pkmem:2-free_size\u0026#34;: 89642512, \u0026#34;pkmem:2-fragments\u0026#34;: 7999, \u0026#34;pkmem:5-total_size\u0026#34;: 104857600, \u0026#34;pkmem:5-used_size\u0026#34;: 14739264, \u0026#34;pkmem:5-real_used_size\u0026#34;: 15221808, \u0026#34;pkmem:5-max_used_size\u0026#34;: 15222608, \u0026#34;pkmem:5-free_size\u0026#34;: 89635792, \u0026#34;pkmem:5-fragments\u0026#34;: 8012, \u0026#34;pkmem:6-total_size\u0026#34;: 0, \u0026#34;pkmem:6-used_size\u0026#34;: 0, \u0026#34;pkmem:6-real_used_size\u0026#34;: 0, \u0026#34;pkmem:6-max_used_size\u0026#34;: 0, \u0026#34;pkmem:6-free_size\u0026#34;: 0, \u0026#34;pkmem:6-fragments\u0026#34;: 0, \u0026#34;pkmem:7-total_size\u0026#34;: 104857600, \u0026#34;pkmem:7-used_size\u0026#34;: 14732944, \u0026#34;pkmem:7-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:7-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:7-free_size\u0026#34;: 89643400, \u0026#34;pkmem:7-fragments\u0026#34;: 7991, \u0026#34;pkmem:8-total_size\u0026#34;: 0, \u0026#34;pkmem:8-used_size\u0026#34;: 0, \u0026#34;pkmem:8-real_used_size\u0026#34;: 0, \u0026#34;pkmem:8-max_used_size\u0026#34;: 0, \u0026#34;pkmem:8-free_size\u0026#34;: 0, \u0026#34;pkmem:8-fragments\u0026#34;: 0, \u0026#34;pkmem:9-total_size\u0026#34;: 104857600, \u0026#34;pkmem:9-used_size\u0026#34;: 14732944, \u0026#34;pkmem:9-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:9-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:9-free_size\u0026#34;: 89643400, \u0026#34;pkmem:9-fragments\u0026#34;: 7991, \u0026#34;pkmem:10-total_size\u0026#34;: 0, \u0026#34;pkmem:10-used_size\u0026#34;: 0, \u0026#34;pkmem:10-real_used_size\u0026#34;: 0, \u0026#34;pkmem:10-max_used_size\u0026#34;: 0, \u0026#34;pkmem:10-free_size\u0026#34;: 0, \u0026#34;pkmem:10-fragments\u0026#34;: 0, \u0026#34;pkmem:11-total_size\u0026#34;: 0, \u0026#34;pkmem:11-used_size\u0026#34;: 0, \u0026#34;pkmem:11-real_used_size\u0026#34;: 0, \u0026#34;pkmem:11-max_used_size\u0026#34;: 0, \u0026#34;pkmem:11-free_size\u0026#34;: 0, \u0026#34;pkmem:11-fragments\u0026#34;: 0, \u0026#34;pkmem:12-total_size\u0026#34;: 104857600, \u0026#34;pkmem:12-used_size\u0026#34;: 14732944, \u0026#34;pkmem:12-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:12-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:12-free_size\u0026#34;: 89643400, \u0026#34;pkmem:12-fragments\u0026#34;: 7991, \u0026#34;pkmem:13-total_size\u0026#34;: 104857600, \u0026#34;pkmem:13-used_size\u0026#34;: 14732944, \u0026#34;pkmem:13-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:13-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:13-free_size\u0026#34;: 89643400, \u0026#34;pkmem:13-fragments\u0026#34;: 7991, \u0026#34;pkmem:14-total_size\u0026#34;: 104857600, \u0026#34;pkmem:14-used_size\u0026#34;: 14737040, \u0026#34;pkmem:14-real_used_size\u0026#34;: 15218856, \u0026#34;pkmem:14-max_used_size\u0026#34;: 15219048, \u0026#34;pkmem:14-free_size\u0026#34;: 89638744, \u0026#34;pkmem:14-fragments\u0026#34;: 8001, \u0026#34;pkmem:15-total_size\u0026#34;: 104857600, \u0026#34;pkmem:15-used_size\u0026#34;: 14732944, \u0026#34;pkmem:15-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:15-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:15-free_size\u0026#34;: 89643400, \u0026#34;pkmem:15-fragments\u0026#34;: 7991, \u0026#34;pkmem:16-total_size\u0026#34;: 104857600, \u0026#34;pkmem:16-used_size\u0026#34;: 14732944, \u0026#34;pkmem:16-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:16-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:16-free_size\u0026#34;: 89643400, \u0026#34;pkmem:16-fragments\u0026#34;: 7991, \u0026#34;pkmem:17-total_size\u0026#34;: 104857600, \u0026#34;pkmem:17-used_size\u0026#34;: 14732944, \u0026#34;pkmem:17-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:17-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:17-free_size\u0026#34;: 89643400, \u0026#34;pkmem:17-fragments\u0026#34;: 7991, \u0026#34;pkmem:18-total_size\u0026#34;: 104857600, \u0026#34;pkmem:18-used_size\u0026#34;: 14732944, \u0026#34;pkmem:18-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:18-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:18-free_size\u0026#34;: 89643400, \u0026#34;pkmem:18-fragments\u0026#34;: 7991, \u0026#34;pkmem:19-total_size\u0026#34;: 104857600, \u0026#34;pkmem:19-used_size\u0026#34;: 14732944, \u0026#34;pkmem:19-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:19-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:19-free_size\u0026#34;: 89643400, \u0026#34;pkmem:19-fragments\u0026#34;: 7991, \u0026#34;pkmem:20-total_size\u0026#34;: 104857600, \u0026#34;pkmem:20-used_size\u0026#34;: 14732944, \u0026#34;pkmem:20-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:20-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:20-free_size\u0026#34;: 89643400, \u0026#34;pkmem:20-fragments\u0026#34;: 7991, \u0026#34;pkmem:21-total_size\u0026#34;: 104857600, \u0026#34;pkmem:21-used_size\u0026#34;: 14732944, \u0026#34;pkmem:21-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:21-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:21-free_size\u0026#34;: 89643400, \u0026#34;pkmem:21-fragments\u0026#34;: 7991, \u0026#34;pkmem:22-total_size\u0026#34;: 104857600, \u0026#34;pkmem:22-used_size\u0026#34;: 14732944, \u0026#34;pkmem:22-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:22-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:22-free_size\u0026#34;: 89643400, \u0026#34;pkmem:22-fragments\u0026#34;: 7991, \u0026#34;pkmem:23-total_size\u0026#34;: 104857600, \u0026#34;pkmem:23-used_size\u0026#34;: 14732944, \u0026#34;pkmem:23-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:23-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:23-free_size\u0026#34;: 89643400, \u0026#34;pkmem:23-fragments\u0026#34;: 7991, \u0026#34;pkmem:24-total_size\u0026#34;: 104857600, \u0026#34;pkmem:24-used_size\u0026#34;: 14732944, \u0026#34;pkmem:24-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:24-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:24-free_size\u0026#34;: 89643400, \u0026#34;pkmem:24-fragments\u0026#34;: 7991, \u0026#34;pkmem:25-total_size\u0026#34;: 104857600, \u0026#34;pkmem:25-used_size\u0026#34;: 14732944, \u0026#34;pkmem:25-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:25-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:25-free_size\u0026#34;: 89643400, \u0026#34;pkmem:25-fragments\u0026#34;: 7991, \u0026#34;pkmem:26-total_size\u0026#34;: 104857600, \u0026#34;pkmem:26-used_size\u0026#34;: 14739208, \u0026#34;pkmem:26-real_used_size\u0026#34;: 15223096, \u0026#34;pkmem:26-max_used_size\u0026#34;: 15233904, \u0026#34;pkmem:26-free_size\u0026#34;: 89634504, \u0026#34;pkmem:26-fragments\u0026#34;: 8028, \u0026#34;pkmem:27-total_size\u0026#34;: 104857600, \u0026#34;pkmem:27-used_size\u0026#34;: 14734520, \u0026#34;pkmem:27-real_used_size\u0026#34;: 15217288, \u0026#34;pkmem:27-max_used_size\u0026#34;: 15225120, \u0026#34;pkmem:27-free_size\u0026#34;: 89640312, \u0026#34;pkmem:27-fragments\u0026#34;: 8012, \u0026#34;pkmem:28-total_size\u0026#34;: 104857600, \u0026#34;pkmem:28-used_size\u0026#34;: 14739168, \u0026#34;pkmem:28-real_used_size\u0026#34;: 15223168, \u0026#34;pkmem:28-max_used_size\u0026#34;: 15233864, \u0026#34;pkmem:28-free_size\u0026#34;: 89634432, \u0026#34;pkmem:28-fragments\u0026#34;: 8028, \u0026#34;pkmem:29-total_size\u0026#34;: 104857600, \u0026#34;pkmem:29-used_size\u0026#34;: 14739312, \u0026#34;pkmem:29-real_used_size\u0026#34;: 15223424, \u0026#34;pkmem:29-max_used_size\u0026#34;: 15234008, \u0026#34;pkmem:29-free_size\u0026#34;: 89634176, \u0026#34;pkmem:29-fragments\u0026#34;: 8028, \u0026#34;pkmem:30-total_size\u0026#34;: 104857600, \u0026#34;pkmem:30-used_size\u0026#34;: 14739512, \u0026#34;pkmem:30-real_used_size\u0026#34;: 15223848, \u0026#34;pkmem:30-max_used_size\u0026#34;: 15234848, \u0026#34;pkmem:30-free_size\u0026#34;: 89633752, \u0026#34;pkmem:30-fragments\u0026#34;: 8034, \u0026#34;pkmem:31-total_size\u0026#34;: 104857600, \u0026#34;pkmem:31-used_size\u0026#34;: 14739136, \u0026#34;pkmem:31-real_used_size\u0026#34;: 15222688, \u0026#34;pkmem:31-max_used_size\u0026#34;: 15233264, \u0026#34;pkmem:31-free_size\u0026#34;: 89634912, \u0026#34;pkmem:31-fragments\u0026#34;: 8026, \u0026#34;pkmem:32-total_size\u0026#34;: 0, \u0026#34;pkmem:32-used_size\u0026#34;: 0, \u0026#34;pkmem:32-real_used_size\u0026#34;: 0, \u0026#34;pkmem:32-max_used_size\u0026#34;: 0, \u0026#34;pkmem:32-free_size\u0026#34;: 0, \u0026#34;pkmem:32-fragments\u0026#34;: 0, \u0026#34;pkmem:33-total_size\u0026#34;: 104857600, \u0026#34;pkmem:33-used_size\u0026#34;: 14739584, \u0026#34;pkmem:33-real_used_size\u0026#34;: 15223976, \u0026#34;pkmem:33-max_used_size\u0026#34;: 15234808, \u0026#34;pkmem:33-free_size\u0026#34;: 89633624, \u0026#34;pkmem:33-fragments\u0026#34;: 8035, \u0026#34;pkmem:34-total_size\u0026#34;: 104857600, \u0026#34;pkmem:34-used_size\u0026#34;: 14739560, \u0026#34;pkmem:34-real_used_size\u0026#34;: 15223896, \u0026#34;pkmem:34-max_used_size\u0026#34;: 15234784, \u0026#34;pkmem:34-free_size\u0026#34;: 89633704, \u0026#34;pkmem:34-fragments\u0026#34;: 8034, \u0026#34;pkmem:35-total_size\u0026#34;: 104857600, \u0026#34;pkmem:35-used_size\u0026#34;: 14732944, \u0026#34;pkmem:35-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:35-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:35-free_size\u0026#34;: 89643400, \u0026#34;pkmem:35-fragments\u0026#34;: 7991, \u0026#34;pkmem:36-total_size\u0026#34;: 104857600, \u0026#34;pkmem:36-used_size\u0026#34;: 14732944, \u0026#34;pkmem:36-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:36-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:36-free_size\u0026#34;: 89643400, \u0026#34;pkmem:36-fragments\u0026#34;: 7991, \u0026#34;pkmem:37-total_size\u0026#34;: 104857600, \u0026#34;pkmem:37-used_size\u0026#34;: 14732944, \u0026#34;pkmem:37-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:37-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:37-free_size\u0026#34;: 89643400, \u0026#34;pkmem:37-fragments\u0026#34;: 7991, \u0026#34;pkmem:38-total_size\u0026#34;: 104857600, \u0026#34;pkmem:38-used_size\u0026#34;: 14732944, \u0026#34;pkmem:38-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:38-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:38-free_size\u0026#34;: 89643400, \u0026#34;pkmem:38-fragments\u0026#34;: 7991, \u0026#34;pkmem:39-total_size\u0026#34;: 104857600, \u0026#34;pkmem:39-used_size\u0026#34;: 14732944, \u0026#34;pkmem:39-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:39-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:39-free_size\u0026#34;: 89643400, \u0026#34;pkmem:39-fragments\u0026#34;: 7991, \u0026#34;pkmem:40-total_size\u0026#34;: 104857600, \u0026#34;pkmem:40-used_size\u0026#34;: 14732944, \u0026#34;pkmem:40-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:40-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:40-free_size\u0026#34;: 89643400, \u0026#34;pkmem:40-fragments\u0026#34;: 7991, \u0026#34;pkmem:41-total_size\u0026#34;: 104857600, \u0026#34;pkmem:41-used_size\u0026#34;: 14732944, \u0026#34;pkmem:41-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:41-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:41-free_size\u0026#34;: 89643400, \u0026#34;pkmem:41-fragments\u0026#34;: 7991, \u0026#34;pkmem:42-total_size\u0026#34;: 104857600, \u0026#34;pkmem:42-used_size\u0026#34;: 14732944, \u0026#34;pkmem:42-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:42-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:42-free_size\u0026#34;: 89643400, \u0026#34;pkmem:42-fragments\u0026#34;: 7991, \u0026#34;pkmem:43-total_size\u0026#34;: 104857600, \u0026#34;pkmem:43-used_size\u0026#34;: 14732944, \u0026#34;pkmem:43-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:43-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:43-free_size\u0026#34;: 89643400, \u0026#34;pkmem:43-fragments\u0026#34;: 7991, \u0026#34;pkmem:44-total_size\u0026#34;: 104857600, \u0026#34;pkmem:44-used_size\u0026#34;: 14732944, \u0026#34;pkmem:44-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:44-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:44-free_size\u0026#34;: 89643400, \u0026#34;pkmem:44-fragments\u0026#34;: 7991, \u0026#34;pkmem:45-total_size\u0026#34;: 104857600, \u0026#34;pkmem:45-used_size\u0026#34;: 14732944, \u0026#34;pkmem:45-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:45-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:45-free_size\u0026#34;: 89643400, \u0026#34;pkmem:45-fragments\u0026#34;: 7991, \u0026#34;pkmem:46-total_size\u0026#34;: 104857600, \u0026#34;pkmem:46-used_size\u0026#34;: 14732944, \u0026#34;pkmem:46-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:46-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:46-free_size\u0026#34;: 89643400, \u0026#34;pkmem:46-fragments\u0026#34;: 7991, \u0026#34;pkmem:47-total_size\u0026#34;: 104857600, \u0026#34;pkmem:47-used_size\u0026#34;: 14732944, \u0026#34;pkmem:47-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:47-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:47-free_size\u0026#34;: 89643400, \u0026#34;pkmem:47-fragments\u0026#34;: 7991, \u0026#34;pkmem:48-total_size\u0026#34;: 104857600, \u0026#34;pkmem:48-used_size\u0026#34;: 14732944, \u0026#34;pkmem:48-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:48-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:48-free_size\u0026#34;: 89643400, \u0026#34;pkmem:48-fragments\u0026#34;: 7991, \u0026#34;pkmem:49-total_size\u0026#34;: 104857600, \u0026#34;pkmem:49-used_size\u0026#34;: 14732944, \u0026#34;pkmem:49-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:49-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:49-free_size\u0026#34;: 89643400, \u0026#34;pkmem:49-fragments\u0026#34;: 7991, \u0026#34;pkmem:50-total_size\u0026#34;: 104857600, \u0026#34;pkmem:50-used_size\u0026#34;: 14732944, \u0026#34;pkmem:50-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:50-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:50-free_size\u0026#34;: 89643400, \u0026#34;pkmem:50-fragments\u0026#34;: 7991, \u0026#34;pkmem:51-total_size\u0026#34;: 104857600, \u0026#34;pkmem:51-used_size\u0026#34;: 14732944, \u0026#34;pkmem:51-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:51-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:51-free_size\u0026#34;: 89643400, \u0026#34;pkmem:51-fragments\u0026#34;: 7991, \u0026#34;pkmem:52-total_size\u0026#34;: 104857600, \u0026#34;pkmem:52-used_size\u0026#34;: 14732944, \u0026#34;pkmem:52-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:52-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:52-free_size\u0026#34;: 89643400, \u0026#34;pkmem:52-fragments\u0026#34;: 7991, \u0026#34;pkmem:53-total_size\u0026#34;: 104857600, \u0026#34;pkmem:53-used_size\u0026#34;: 14732944, \u0026#34;pkmem:53-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:53-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:53-free_size\u0026#34;: 89643400, \u0026#34;pkmem:53-fragments\u0026#34;: 7991, \u0026#34;pkmem:54-total_size\u0026#34;: 104857600, \u0026#34;pkmem:54-used_size\u0026#34;: 14732944, \u0026#34;pkmem:54-real_used_size\u0026#34;: 15214200, \u0026#34;pkmem:54-max_used_size\u0026#34;: 15215976, \u0026#34;pkmem:54-free_size\u0026#34;: 89643400, \u0026#34;pkmem:54-fragments\u0026#34;: 7991, \u0026#34;pkmem:55-total_size\u0026#34;: 0, \u0026#34;pkmem:55-used_size\u0026#34;: 0, \u0026#34;pkmem:55-real_used_size\u0026#34;: 0, \u0026#34;pkmem:55-max_used_size\u0026#34;: 0, \u0026#34;pkmem:55-free_size\u0026#34;: 0, \u0026#34;pkmem:55-fragments\u0026#34;: 0, \u0026#34;pkmem:56-total_size\u0026#34;: 0, \u0026#34;pkmem:56-used_size\u0026#34;: 0, \u0026#34;pkmem:56-real_used_size\u0026#34;: 0, \u0026#34;pkmem:56-max_used_size\u0026#34;: 0, \u0026#34;pkmem:56-free_size\u0026#34;: 0, \u0026#34;pkmem:56-fragments\u0026#34;: 0 } prometheus 收集数据 opensips已经通过9998端口,提供了数据收集的接口,那么就需要使用prometheus来收集数据。 本次由于只用来展示opensips的数据,所以node-exporter就不安装了，只安装prometheus和grafana\nprometheus部署的机器系统时间一定要和你电脑时间一致,否则无法收集到数据。\nprometheus docker运行 prometheus.yaml 配置：\n1 2 3 4 5 6 7 8 9 10 global: scrape_interval: 15s evaluation_interval: 15s external_labels: monitor: \u0026#39;edc-lab-monitor\u0026#39; scrape_configs: - job_name: \u0026#39;opensips\u0026#39; static_configs: - targets: [\u0026#39;172.16.4.111:9998\u0026#39;] ##填写opensips的ip和9998端口 运行容器：\n1 docker run -d -v ${PWD}/prometheus.yaml:/etc/prometheus/prometheus.yml --restart=always --net=host --name=prometheus prom/prometheus prometheus 查看数据 服务如果没有报错的话,浏览器访问：http://172.16.4.111:9090,就能看到prometheus的界面了 如果想要看上报的数据统计,通过下图查看: prometheus的metrics数据类型总共有四种类型:counter、gauge、histogram、summary 当type类型是unknown时,表示该指标没有被采集到,后续在grafana中不能显示该指标。\ngrafana 展示数据 grafana docker 安装 docker 运行命令:\n1 docker run -d -i -p 3000:3000 -e \u0026#34;GF_SERVER_ROOT_URL=http://grafana.server.name\u0026#34; -e \u0026#34;GF_SECURITY_ADMIN_PASSWORD=admin123\u0026#34; --restart=always --name=grafana grafana/grafana grafana 页面配置 浏览器访问： http://172.16.4.111:3000, 登录用户名密码admin:admin123,创建新的dashboard \u0026ldquo;Add visualizaion\u0026rdquo;\u0026mdash;\u0026gt;\u0026ldquo;Select data source\u0026rdquo; 选择prometheus 如果通过opensips两个坐席拨打电话,就能看到监控数据了. 在统计使用内存的指标上,纵坐标的单位是bytes.不直观，需要修改展示的单位,Axis-\u0026gt;Unit: 目前暂时未找到合适的grafana的web页面来展示opensips的数据,有一些插件比较老,好多年没更新了. 如果大家看到了比较好用的grafana插件,欢迎评论。\n","date":"2025-03-18T11:30:44+08:00","image":"https://QuincyGao.github.io/p/opensips-%E6%B7%BB%E5%8A%A0prometheus%E7%9B%91%E6%8E%A7/backup_hu6216985177044040611.jpg","permalink":"https://QuincyGao.github.io/p/opensips-%E6%B7%BB%E5%8A%A0prometheus%E7%9B%91%E6%8E%A7/","title":"opensips 添加prometheus监控"},{"content":"生成脚本 这个是golang 生成动态库示例的脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;C\u0026#34; //export hello func hello() { println(\u0026#34;Hello from DLL\u0026#34;) } //export add func add(a, b int) int { println(\u0026#34;add a+b\u0026#34;) return a + b } func main() {} // 必须存在，但不会被调用 linux 系统版本是:linux/amd64\n64位创建一个build.sh文件, 内容如下： CGO_ENABLED=1 go build -buildmode=c-shared -o test.so main.go\n32位创建一个build-32.sh文件, 内容如下 GOARCH=386 CGO_ENABLED=1 go build -buildmode=c-shared -o test-32.so main.go\nC语言调用.so库的示例代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; typedef void (*HELLO_FUNC)(); typedef int (*ADD_FUNC)(int, int); int main() { void *handle = dlopen(\u0026#34;test.so\u0026#34;, RTLD_LAZY); if (!handle) { fprintf(stderr, \u0026#34;%s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } char* error; dlerror(); HELLO_FUNC hello_func = dlsym(handle, \u0026#34;hello\u0026#34;); if ((error = dlerror()) != NULL) { fprintf(stderr, \u0026#34;%s\\n\u0026#34;, error); exit(EXIT_FAILURE); } hello_func(); ADD_FUNC add_func = dlsym(handle, \u0026#34;add\u0026#34;); if ((error = dlerror()) != NULL) { fprintf(stderr, \u0026#34;%s\\n\u0026#34;, error); exit(EXIT_FAILURE); } printf(\u0026#34;add(1,2) = %d\\n\u0026#34;, add_func(1,2)); dlclose(handle); } 编译：gcc -o test test.c -ldl 运行：./test,结果:\n1 2 Hello World! add(1,2) = 3 windows 系统版本是:windows/amd64\n64位 创建一个build.bat文件, 内容如下: 1 2 set CGO_ENABLED=1 go build -buildmode=c-shared -o test.dll main.go 32位 创建一个build-32.bat文件, 内容如下: 1 2 3 set GOARCH=386 set CGO_ENABLED=1 go build -buildmode=c-shared -o test.dll main.go C语言调用.dll库的示例代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; typedef void (*HELLO_FUNC)(); typedef int (*ADD_FUNC)(int, int); int main() { HMODULE hModule = LoadLibrary(\u0026#34;test.dll\u0026#34;); if (hModule == NULL) { // 错误处理 return 1; } printf(\u0026#34;LoadLibrary success.\\n\u0026#34;); HELLO_FUNC hello_func = (HELLO_FUNC)GetProcAddress(hModule, \u0026#34;hello\u0026#34;); if (hello_func == NULL) { // 错误处理 return 1; } hello_func(); // printf(\u0026#34;Result: %d\\n\u0026#34;, result); ADD_FUNC add_func = (ADD_FUNC)GetProcAddress(hModule, \u0026#34;add\u0026#34;); if (add_func == NULL) { // 错误处理 return 1; } int result = add_func(1,2); printf(\u0026#34;result: %d\\n\u0026#34;,result); FreeLibrary(hModule); return 0; } 测试脚本编译方式: gcc -o test test.c 运行：./test,结果:\n1 2 Hello World! add(1,2) = 3 windows加载库卡死 在实际的项目中,发现使用golang调用cgo生成的动态库,有这样的用法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main //#include \u0026lt;string.h\u0026gt; //#include \u0026lt;stdlib.h\u0026gt; /* void __attribute__ ((constructor)) ConfigLoad(); void __attribute__ ((destructor)) ConfUnLoad(); */ import \u0026#34;C\u0026#34; //export hello func hello() { println(\u0026#34;Hello from DLL\u0026#34;) } //export add func add(a, b int) int { println(\u0026#34;add a+b\u0026#34;) return a + b } //export ConfigLoad func ConfigLoad() {} //export ConfUnLoad func ConfUnLoad() {} func main() {} // 必须存在，但不会被调用 void __attribute__ ((constructor)) ConfigLoad() 和 void __attribute__ ((destructor)) ConfUnLoad() 这两个函数在动态库被加载和卸载时调用，可以用来初始化和清理动态库。\n但是在windows调用生成的test.dll的库时，会出现服务卡死的情况，卡死的位置在:LoadLibrary, 但是Linux环境是没有问题的。\n问题分析: windows系统在加载动态库时，会调用DllMain的构造函数， golang运行时的初始化(调度器,GC等)会同步执行在一个系统线程，构造函数调用Go代码时,可能触发未完全初始化状态的Go代码,导致死锁。 dll在加载线程处于受限状态，不允许创建新线程。\nLinux处理机制不一样，会先完成动态库的初始化,然后再调用构造函数，加载线程处于正常状态，不会出现死锁。\n解决办法: 在必须加载ConfigLoad的条件下， 去掉void __attribute__ ((constructor)) ConfigLoad();, 改成使用golang 的init: 1 2 3 func init() { ConfigLoad() } 最好避免使用void __attribute__ ((constructor)) ConfigLoad();这样的结构,改成主动调用。 ","date":"2025-03-13T16:19:59+08:00","image":"https://QuincyGao.github.io/p/golang-%E4%BD%BF%E7%94%A8cgo-%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93/backup_hu15969127416341068613.jpg","permalink":"https://QuincyGao.github.io/p/golang-%E4%BD%BF%E7%94%A8cgo-%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93/","title":"golang 使用cgo 生成动态库"},{"content":"http server 模块 上一章，已经介绍了http client的模块的用法，这章主要介绍http server模块。\nserver 描述 JSONRPCS 支持http,fifo, datagram MICROHTTPD 依赖libmcrohttpd XHTTP 提供http/1.0基础服务 XHTTP_PI 通过kamailio的API提供数据库操作,依赖xhttp,libxml2 XHTTP_PROM 为prometheus提供metrics数据 XHTTP_RPC 通过http方式 提供rpc服务 JSONRPCS 模块 JSONRPCS支持三种传输方式: fifo, udp, http/https, 依赖xhttp.\n配置参数 1 2 # 0,支持所有协议; 1,http;2,fifo;4,udp;8,tcp 可多个协议叠加 modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;transport\u0026#34;, 1) http 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 listen=tcp:172.16.4.111:5361 tcp_accept_no_cl=yes loadmodule \u0026#34;xhttp.so\u0026#34; loadmodule \u0026#34;jsonrpcs.so\u0026#34; modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;transport\u0026#34;, 1) event_route[xhttp:request] { set_reply_close(); set_reply_no_connect(); if(src_ip!=127.0.0.1) { xhttp_reply(\u0026#34;403\u0026#34;, \u0026#34;Forbidden\u0026#34;, \u0026#34;text/html\u0026#34;, \u0026#34;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Not allowed from $si\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;); exit; } if ($hu =~ \u0026#34;^/RPC\u0026#34;) { jsonrpc_dispatch(); exit; } xhttp_reply(\u0026#34;200\u0026#34;, \u0026#34;OK\u0026#34;, \u0026#34;text/html\u0026#34;, \u0026#34;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Wrong URL $hu\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;); exit; } 监听一个tcp端口,tcp_accept_no_cl=yes, 之后就可以往该tcp端口发送http请求了。 想要调用kamailio的内部函数,请求/RPC路径。例如,查询注册用户数:\nPOST:http://172.16.4.111:5461/RPC, body: { \u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;, \u0026quot;method\u0026quot;:\u0026quot;stats.get_statistics\u0026quot;, \u0026quot;params\u0026quot;:[\u0026quot;registered_users\u0026quot;], \u0026quot;id\u0026quot;:\u0026quot;123234\u0026quot;, \u0026quot;value\u0026quot;:{ \u0026quot;test1\u0026quot;:1111, \u0026quot;test2\u0026quot;:\u0026quot;2222\u0026quot; } }\n返回值: { \u0026quot;jsonrpc\u0026quot;: \u0026quot;2.0\u0026quot;, \u0026quot;result\u0026quot;: [ \u0026quot;usrloc:registered_users = 1\u0026quot; ], \u0026quot;id\u0026quot;: \u0026quot;123234\u0026quot; }\nfifo 1 2 3 modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;transport\u0026#34;, 7) modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;fifo_name\u0026#34;, \u0026#34;/run/kamailio/kamailio_rpc.fifo\u0026#34;) modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;fifo_mode\u0026#34;, 0660) 测试方式配置kamctlrc文件，RPCFIFOPATH和CTLENGINE, 运行kamctl ul show 命令。\nudp 1 2 3 4 5 6 7 modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;transport\u0026#34;, 4) modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;dgram_socket\u0026#34;, \u0026#34;/tmp/kamailio_rpc.sock\u0026#34;) modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;dgram_workers\u0026#34;, 4) modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;dgram_mode\u0026#34;, 0600) modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;dgram_group\u0026#34;, 0) modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;dgram_user\u0026#34;, 0) modparam(\u0026#34;jsonrpcs\u0026#34;, \u0026#34;dgram_timeout\u0026#34;, 2000) 重要函数 jsonrpc_dispatch() 用于处理jsonrpc请求, 并返回结果。\njsonrpc_exec(cmd) 例如jsonrpc_exec(\u0026quot;stats.get_statistics('registered_users')\u0026quot;) 结果存储在$jsonrpl(key),例如$jsonrpl(code) - the body is: $jsonrpl(body)\nMICROHTTPD 模块 此MICROHTTPD依赖libmicrohttpd库, 该库提供了http服务.\n使用较为简单, 配置如下:\n1 2 3 4 5 6 7 8 9 10 11 loadmodule \u0026#34;microhttpd.so\u0026#34; modparam(\u0026#34;microhttpd\u0026#34;, \u0026#34;listen_addr\u0026#34;, \u0026#34;127.0.0.1\u0026#34;) #默认8280 modparam(\u0026#34;microhttpd\u0026#34;, \u0026#34;listen_port\u0026#34;, 8284) event_route[microhttpd:request] { xinfo(\u0026#34;request: $mhttpd(method) - url: $mhttpd(url) - data: [$mhttpd(data)]\\n\u0026#34;); mhttpd_reply(\u0026#34;200\u0026#34;, \u0026#34;OK\u0026#34;, \u0026#34;text/html\u0026#34;, \u0026#34;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;OK\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;); } 这块测试post请求带body出现没有响应的问题, kamailio的版本是kamailio 5.8.5 (x86_64/linux)已提bug到github。\nXHTTP 模块 此模块通常和jsonrpcs一起使用，具体的使用示例，参考jsonrpcs模块。新增配置参数：\n1 2 3 4 # 如果url匹配,跳过请求不处理 modparam(\u0026#34;xhttp\u0026#34;, \u0026#34;url_skip\u0026#34;, \u0026#34;^/RPC2\u0026#34;) # 如果url匹配,处理请求 modparam(\u0026#34;xhttp\u0026#34;, \u0026#34;url_match\u0026#34;, \u0026#34;^/sip/\u0026#34;) XHTTP_PI 模块 提供接口访问数据库,配置方式比较简单,请求/pi/dispatcher：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 tcp_accept_no_cl=yes ... loadmodule \u0026#34;sl.so\u0026#34; loadmodule \u0026#34;xhttp.so\u0026#34; loadmodule \u0026#34;xhttp_pi.so\u0026#34; ... modparam(\u0026#34;xhttp_pi\u0026#34;, \u0026#34;framework\u0026#34;, \u0026#34;/usr/local/etc/kamailio/pi_framework.xml\u0026#34;) ... event_route[xhttp:request] { $var(xhttp_root) = $(hu{s.substr,0,3}); if ($var(xhttp_root) == \u0026#34;/pi\u0026#34;) dispatch_xhttp_pi(); else xhttp_reply(\u0026#34;200\u0026#34;, \u0026#34;OK\u0026#34;, \u0026#34;text/html\u0026#34;, \u0026#34;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Wrong URL $hu\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;); } 目前暂时未找到成功的测试示例。\nXHTTP_PROM 模块 此模块依赖xhttp模块,提供prometheus metrics数据. 此模块暂时不深入研究,后续研究监控时，再介绍。\nXHTTP_RPC 模块 此模块依赖xhttp模块，会调用rpc函数,相当于kamactl rpc xxx配置方式如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 tcp_accept_no_cl=yes ... loadmodule \u0026#34;sl.so\u0026#34; loadmodule \u0026#34;xhttp.so\u0026#34; loadmodule \u0026#34;xhttp_rpc.so\u0026#34; ... modparam(\u0026#34;xhttp_rpc\u0026#34;, \u0026#34;xhttp_rpc_root\u0026#34;, \u0026#34;http_rpc\u0026#34;) ... event_route[xhttp:request] { $var(xhttp_rpc_root) = $(hu{s.substr,0,9}); if ($var(xhttp_rpc_root) == \u0026#34;/http_rpc\u0026#34;) dispatch_xhttp_rpc(); else xhttp_reply(\u0026#34;200\u0026#34;, \u0026#34;OK\u0026#34;, \u0026#34;text/html\u0026#34;, \u0026#34;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Wrong URL $hu\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;); } ","date":"2025-03-10T14:05:22+08:00","image":"https://QuincyGao.github.io/p/kamailio%E7%9A%84http%E5%8A%9F%E8%83%BD%E4%BA%8C/backup_hu5189888814327220012.jpg","permalink":"https://QuincyGao.github.io/p/kamailio%E7%9A%84http%E5%8A%9F%E8%83%BD%E4%BA%8C/","title":"kamailio的HTTP功能(二)"},{"content":"http 模块 kamailio的http功能十分丰富,提供了客户端和服务端。对应的模块有：\nclient 描述 HTTP_CLIENT 依赖libcurl HTTP_ASYNC_CLIENT 异步client,依赖libcurl 和libevent JSONRPCC 依赖libjson,libevent,glibc JANSSONRPCC 依赖jansson,libevent server 描述 JSONRPCS 支持http,fifo, datagram MICROHTTPD 依赖libmcrohttpd XHTTP 提供http/1.0基础服务 XHTTP_PI 通过kamailio的API提供数据库操作 XHTTP_PROM 为prometheus提供metrics数据 XHTTP_RPC 通过http方式 提供rpc服务 本章主要是介绍client模块,版本为：\nversion: kamailio 5.8.5 (x86_64/linux)\nClient HTTP_CLIENT 模块 支持http和https协议,同步请求\nhttp配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 302是否重定向, 默认为:1 modparam(\u0026#34;http_client\u0026#34;, \u0026#34;httpredirect\u0026#34;, 0) # useragent 设置 modparam(\u0026#34;http_client\u0026#34;, \u0026#34;useragent\u0026#34;, \u0026#34;Secret HTTP REST grabber 0.42\u0026#34;) # maxdatasize reponse body的最大大小,默认0,不设置 modparam(\u0026#34;http_client\u0026#34;, \u0026#34;maxdatasize\u0026#34;, 2000) # connection_timeout 等待服务端返回的超时时间,默认4s,单位是秒还是毫秒,由timeout_mode决定 modparam(\u0026#34;http_client\u0026#34;, \u0026#34;connection_timeout\u0026#34;, 5) # timeout_mode 0,超时功能不能用 1,表示单位是秒,2,表示单位是毫秒,默认1 modparam(\u0026#34;http_client\u0026#34;, \u0026#34;timeout_mode\u0026#34;, 1) # keep_connections 0,请求之后关闭连接;1,请求之后保持连接 modparam(\u0026#34;http_client\u0026#34;, \u0026#34;keep_connections\u0026#34;, 1) # query_result 控制http_client_query的返回结果, 0,返回整个body;1,返回body的第一行,默认1 modparam(\u0026#34;http_client\u0026#34;, \u0026#34;query_result\u0026#34;, 0) https 1 2 3 4 5 6 7 8 9 10 modparam(\u0026#34;http_client\u0026#34;, \u0026#34;client_cert\u0026#34;, \u0026#34;/var/certs/sollentuna.example.com.cert\u0026#34;) modparam(\u0026#34;http_client\u0026#34;, \u0026#34;client_key\u0026#34;, \u0026#34;/var/certs/sollentuna.example.com.key\u0026#34;) # 验证服务端证书,默认1 modparam(\u0026#34;http_client\u0026#34;, \u0026#34;verify_peer\u0026#34;, 1) # 验证domain,默认2 modparam(\u0026#34;http_client\u0026#34;, \u0026#34;verify_host\u0026#34;, 2) #tls版本 0,libcurl默认; 1,TLSv1; 2,SSLv2; 3,SSLv3; 4,TLSv1.0; 5,TLSv1.1; 6,TLSv1.2 modparam(\u0026#34;http_client\u0026#34;, \u0026#34;tlsversion\u0026#34;, 6) # http认证方式,默认3(1+2) 1,BASIC authention; 2,HTTP Digest authentication; 4,GSS-Negotiate authentication; 8, NTLM authentication; 16,HTTP Digest with IE flavour modparam(\u0026#34;http_client\u0026#34;, \u0026#34;authmethod\u0026#34;, 3) https的配置也可以从文件读取\n1 modparam(\u0026#34;http_client\u0026#34;, \u0026#34;config_file\u0026#34;, \u0026#34;httpconnections.cfg) httpconnections.cfg\n1 2 3 4 5 6 7 8 9 [authapiserver] url = https://api.runbo.example.com/v4.2/auth timeout = 1 maxdatasize = 4 tlsversion = TLSv1.2 verify_peer = yes client_key = default_key.pem client_cert = default_cert.pem http_follow_redirect = no 设置http server的url 1 2 3 4 modparam(\u0026#34;http_client\u0026#34;, \u0026#34;httpcon\u0026#34;, \u0026#34;apione=\u0026gt;http://atlanta.example.com\u0026#34;) modparam(\u0026#34;http_client\u0026#34;, \u0026#34;httpcon\u0026#34;, \u0026#34;apitwo=\u0026gt;http://atlanta.example.com/api/12\u0026#34;) modparam(\u0026#34;http_client\u0026#34;, \u0026#34;httpcon\u0026#34;, \u0026#34;apithree=\u0026gt;http://annabella:mysecret@atlanta.example.com/api/12\u0026#34;) modparam(\u0026#34;http_client\u0026#34;, \u0026#34;httpcon\u0026#34;, \u0026#34;apifour=\u0026gt;http://stockholm.example.com/api/getstuff;timeout=12;failover=apione\u0026#34;) 几个请求函数 http_connect(connection, url, [content_type, data,] result) 1 2 3 4 5 modparam(\u0026#34;http_client\u0026#34;, \u0026#34;httpcon\u0026#34;, \u0026#34;apiserver=\u0026gt;https://kamailio.org/api/\u0026#34;); #POST $var(res) = http_connect(\u0026#34;apiserver\u0026#34;, \u0026#34;/mailbox\u0026#34;, \u0026#34;application/json\u0026#34;, \u0026#34;{ ok, {200, ok}}\u0026#34;, \u0026#34;$avp(gurka)\u0026#34;); #GET $var(res) = http_connect(\u0026#34;apiserver\u0026#34;, \u0026#34;/mailbox?page=1\u0026amp;\u0026amp;limit=10\u0026#34;,\u0026#34;$avp(gurka)\u0026#34;); 默认是GET方式, POST方式,需要设置content_type和data,只能被用到REQUEST_ROUTE, ONREPLY_ROUTE, FAILURE_ROUTE,BRANCH_ROUTE\nhttp_connect_raw(connection, url, content_type, data, result) 1 $var(res) = http_connect_raw(\u0026#34;apiserver\u0026#34;, \u0026#34;/mailbox\u0026#34;, \u0026#34;application/json\u0026#34;, \u0026#34;{ ok, {200, ok}}\u0026#34;, \u0026#34;$avp(gurka)\u0026#34;); 只能发送POST,可以使用的路由有：REQUEST_ROUTE, ONREPLY_ROUTE, FAILURE_ROUTE, BRANCH_ROUTE\nhttp_client_query(url, [post-data], [hdrs], result) 1 2 3 4 5 6 #GET http_client_query(\u0026#34;http://api.com/index.php?r_uri=$(ru{s.escape.param})\u0026amp;f_uri=$(fu{s.escape.param})\u0026#34;, \u0026#34;$var(result)\u0026#34;); # POST-Request http_client_query(\u0026#34;http://api.com/index.php\u0026#34;, \u0026#34;src=$si\u0026#34;, \u0026#34;Content-Type: text/plain\u0026#34;, \u0026#34;$var(result)\u0026#34;); 可以发送GET和POST, POST就设置post-data,可以用在ANY ROUTE.\nhttp_client_get(url, body, hdrs, respv) 1 2 http_client_get(\u0026#34;http://api.com/index.php?r_uri=$(ru{s.escape.param})\u0026amp;f_uri=$(fu{s.escape.param})\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;X-Token: abc\u0026#34;, \u0026#34;$var(result)\u0026#34;); 只能GET, body为空,可以用在ANY ROUTE.\nHTTP_ASYNC_CLIENT 模块 异步请求,支持http和https两种方式\nhttp配置 1 2 3 4 5 6 7 8 9 10 11 12 #多少个worker来发送请求和处理返回,默认1个 modparam(\u0026#34;http_async_client\u0026#34;, \u0026#34;workers\u0026#34;, 2) # 等待服务端返回的超时时间，单位毫秒，默认500ms modparam(\u0026#34;http_async_client\u0026#34;, \u0026#34;connection_timeout\u0026#34;, 1000) # hash_size, 默认2048 modparam(\u0026#34;http_async_client\u0026#34;, \u0026#34;hash_size\u0026#34;, 1024) modparam(\u0026#34;http_async_client\u0026#34;, \u0026#34;tcp_keepalive\u0026#34;, 1) # 保持keepalive的时间,单位秒,空闲等待时间,默认60s modparam(\u0026#34;http_async_client\u0026#34;, \u0026#34;tcp_ka_idle\u0026#34;, 30) # 保持keepalive的间隔时间,单位秒,默认60s modparam(\u0026#34;http_async_client\u0026#34;, \u0026#34;tcp_ka_interval\u0026#34;, 120) https 配置 1 2 3 4 5 6 7 8 # tls的版本 modparam(\u0026#34;http_async_client\u0026#34;, \u0026#34;tls_version\u0026#34;, 6) # 是否验证domain,默认2 modparam(\u0026#34;http_async_client\u0026#34;, \u0026#34;tls_verify_host\u0026#34;, 0) # 是否验证服务端证书,默认1 modparam(\u0026#34;http_async_client\u0026#34;, \u0026#34;tls_verify_peer\u0026#34;, 0) modparam(\u0026#34;http_async_client\u0026#34;, \u0026#34;tls_client_cert\u0026#34;, \u0026#34;/etc/kamailio/ssl/clientcert.pem\u0026#34;) modparam(\u0026#34;http_async_client\u0026#34;, \u0026#34;tls_client_key\u0026#34;, \u0026#34;/etc/kamailio/ssl/clientcert.key\u0026#34;) 重要函数介绍 http_async_query(url, route_name) 支持GET和POST, 可以用在ANY ROUTE.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # GET http_async_query(\u0026#34;http://example.com/test.php?r_uri=$rU\u0026amp;f_uri=$fU\u0026#34;, \u0026#34;HTTP_REPLY\u0026#34;); ... # POST $http_req(body) = \u0026#34;{\u0026#39;r_uri\u0026#39;:\u0026#39;\u0026#34; + $rU + \u0026#34;\u0026#39;, \u0026#39;f_uri\u0026#39;:\u0026#39;\u0026#34; + $fU + \u0026#34;\u0026#39;}\u0026#34;; http_async_query(\u0026#34;http://example.com/test.php\u0026#34;, \u0026#34;HTTP_REPLY\u0026#34;); ··· route[HTTP_REPLY] { if ($http_ok) { xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;route[HTTP_REPLY]: status $http_rs\\n\u0026#34;); xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;route[HTTP_REPLY]: body $http_rb\\n\u0026#34;); } else { xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;route[HTTP_REPLY]: error $http_err)\\n\u0026#34;); } } 重要变量介绍 http_req(key),只能写，key有以下几种:\nall: 设置成$null, 重置所有的变量 hdr: 设置/修改/删除 http header,设置多次，可以添加多个头 body: 设置/修改/删除 http body method: 设置请求方式:GET,POST,PUT,DELETE, 不设置的话,就是GET,有body就是POST timeout: 设置超时时间 tls_client_cert: 设置客户端证书 tls_client_key: 设置客户端证书的key tls_ca_path: ca证书路径 authmethod: 设置认证方式 username: 设置认证用户名 password: 设置认证密码 suspend: 设置为0,不会停止当前的事务 tcp_keepalive: 设置为1,开启keepalive tcp_ka_idle: 设置keepalive的等待时间,单位秒,默认60s tcp_ka_interval: 设置keepalive的间隔时间,单位秒,默认60s follow_redirect: 设置为1,开启重定向 http_X: 只读，\n$http_ok: 1 请求成功;0失败 $http_rs: http状态码 $http_err: 请求出错，$null 表示没有出错 $http_rr: http reason 解析 $http_hdr(name): 获取http header $http_mb 和 $http_ml: response的buffer和长度 $http_rb 和 $http_bs: response的body和长度 $http_time: http请求的响应时间,单位毫秒 JSONRPCC 模块 JSONRPC是JSON格式HTTP协议下RESTful风格的RPC协议。 使用较简单。\n配置解析： 1 2 3 4 #配置server地址,可配多个,格式\u0026#34;host1:port1,priority1 host2:port2,priority2\u0026#34; modparam(\u0026#34;jsonrpcc\u0026#34;, \u0026#34;servers\u0026#34;, \u0026#34;localhost:9999,2 10.10.0.1:9999,2 backup.server:9999,1\u0026#34;) # 最大重试次数，-1 一直重连， 0 不重试 modparam(\u0026#34;jsonrpcc\u0026#34;, \u0026#34;max_conn_attempts\u0026#34;, 10) 关键函数 jsonrpc_notification(method, parameters) 事件通知，不需要返回值。\n1 jsonrpc_notification(\u0026#34;update_user\u0026#34;, \u0026#34;{\u0026#39;id\u0026#39;: 1234, \u0026#39;name\u0026#39;: \u0026#39;Petros\u0026#39;}\u0026#34;) jsonrpc_request(method, parameters, return_route, error_route, result_var) 获取返回值，可以通过这个函数来实现kamctl的功能。\n1 2 3 4 5 6 7 8 9 10 11 jsonrpc_request(\u0026#34;get_user\u0026#34;, \u0026#34;{\u0026#39;id\u0026#39;: 1234}\u0026#34;, \u0026#34;RESPONSE\u0026#34;, \u0026#34;ERROR\u0026#34;, \u0026#34;$var(result)\u0026#34;); ... route[RESPONSE] { xlog(\u0026#34;Result received: $var(result)\u0026#34;); ... } ... route[ERROR] { xlog(\u0026#34;Error received: $var(result)\u0026#34;); ... } JANSSONRPCC 模块 配置解析： 1 2 3 4 5 6 # 返回值存储位置，默认:$var(jsrpc_result) modparam(\u0026#34;janssonrpcc\u0026#34;, \u0026#34;result_pv\u0026#34;, \u0026#34;$var(result)\u0026#34;) # 重试的错误码，默认: -32603, -32000..-32099 modparam(\u0026#34;janssonrpcc\u0026#34;, \u0026#34;retry_codes\u0026#34;, \u0026#34;-32603, -32000..-32099\u0026#34;); # keepalive时间，默认: 10 modparam(\u0026#34;janssonrpcc\u0026#34;, \u0026#34;keep_alive\u0026#34;, 10) server端配置方式:\n1 2 3 4 modparam(\u0026#34;janssonrpcc\u0026#34;, \u0026#34;server\u0026#34;, \u0026#34;conn=tests;srv=_test1._tcp.example.net\u0026#34;); modparam(\u0026#34;janssonrpcc\u0026#34;, \u0026#34;server\u0026#34;, \u0026#34;conn=tests;srv=_test2._tcp.example.net\u0026#34;); modparam(\u0026#34;janssonrpcc\u0026#34;, \u0026#34;server\u0026#34;, \u0026#34;conn=local;addr=localhost;port=8080;priority=10;weight=10\u0026#34;); modparam(\u0026#34;janssonrpcc\u0026#34;, \u0026#34;server\u0026#34;, \u0026#34;conn=user_db;addr=rpc.prod.example.net;port=5060;priority=10;weight=10\u0026#34;); 关键函数 janssonrpc_notification(conn, method, parameters) 通知函数，不需要返回值。\njanssonrpc_request(conn, method, params[, options]]) json请求函数,可以用在ANY ROUTE,示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 route { janssonrpc_request(\u0026#34;user_db\u0026#34;, \u0026#34;get_user\u0026#34;, \u0026#39;{\u0026#34;id\u0026#34;: 1234}\u0026#39;, \u0026#34;route=RESPONSE;retry=1\u0026#34;); } route[RESPONSE] { if(jansson_get(\u0026#34;internal_error\u0026#34;, $var(jsrpc_result), \u0026#34;$var(internal)\u0026#34;)) { route(INTERNAL); } else if(jansson_get(\u0026#34;error\u0026#34;, $var(jsrpc_result), \u0026#34;$var(error)\u0026#34;)) { route(ERROR); } else if(jansson_get(\u0026#34;result\u0026#34;, $var(jsrpc_result), \u0026#34;$var(result)\u0026#34;)) { route(RESULT); } t_reply(\u0026#34;200\u0026#34;, \u0026#34;OK\u0026#34;); } route[RESULT] { xlog(\u0026#34;result is $var(result)\\n\u0026#34;); xlog(\u0026#34;success\\n\u0026#34;); } route[ERROR] { xlog(\u0026#34;There was an error\\n\u0026#34;); if(jansson_get(\u0026#34;code\u0026#34;, $var(error), \u0026#34;$var(c)\u0026#34;)) { xlog(\u0026#34;code is $var(c)\\n\u0026#34;); } if(jansson_get(\u0026#34;message\u0026#34;, $var(error), \u0026#34;$var(r)\u0026#34;)) { xlog(\u0026#34;error is $var(r)\\n\u0026#34;); } if(jansson_get(\u0026#34;data\u0026#34;, $var(error), \u0026#34;$var(d)\u0026#34;)) { xlog(\u0026#34;data is $var(d)\\n\u0026#34;); } } route[INTERNAL] { xlog(\u0026#34;There was an internal error\\n\u0026#34;); jansson_get(\u0026#34;code\u0026#34;, $var(internal), \u0026#34;$var(c)\u0026#34;); xlog(\u0026#34;code is $var(c)\\n\u0026#34;); jansson_get(\u0026#34;message\u0026#34;, $var(internal), \u0026#34;$var(r)\u0026#34;); xlog(\u0026#34;error is $var(r)\\n\u0026#34;); if(jansson_get(\u0026#34;data\u0026#34;, $var(internal), \u0026#34;$var(d)\u0026#34;)) { xlog(\u0026#34;request is $var(d)\\n\u0026#34;); } } ","date":"2025-03-05T17:23:39+08:00","image":"https://QuincyGao.github.io/p/kamailio%E7%9A%84http%E5%8A%9F%E8%83%BD%E4%B8%80/backup_hu16797498490379775505.jpg","permalink":"https://QuincyGao.github.io/p/kamailio%E7%9A%84http%E5%8A%9F%E8%83%BD%E4%B8%80/","title":"kamailio的HTTP功能(一)"},{"content":"registrar模块简介 version: kamailio 5.8.5 (x86_64/linux)\n本文主要是通过实战来展示参数的用法，让您有个比较清晰的认识。官方文档地址：kamailio.org\n重要参数介绍 default_expires 默认过期时间3600s,此参数只有在REGISTER信令中没有Expires或者contact中没有expires时生效,如果有这些参数，此变量不生效。 软电话都带有Expires,目前无法模拟.\ndefault_exipires_range 默认过期时间变化范围(0-100),[default_expires - default_expires_range%, default_expires]\nexpires_range 作用在expires上，范围(0-100), 例如:30,那么expires的范围为 [0.7*expires, expires]\n1 modparam(\u0026#34;registrar\u0026#34;, \u0026#34;expires_range\u0026#34;, 30) REGISTER的Expires为300 ,usrloc中存储的过期时间为210~300之间,此时返回的200OK的Contact里的expires也是此随机值 min_expires min_expires_mode 最小的过期时间，如果REGISTER里的Expires大于此值，此值不起作用,过期时间按照Expires。 REGISTER里Expires(70)时间小于min_expires(100):\nmin_expires_mode为0时, 设置usrloc里坐席过期时间为min_expires,200OK返里的Contact的expires为min_expires min_expires_mode为1时, kamailio会返回423 Interval Too Brief,并带有Min-Expires时间， 软电话收到此错误，会自动重试，重试的Expires为min_expires,此时注册成功。 max_expires 最大过期时间，REGISTER的Expires过期时间高过此值，坐席过期时间以此值为准； 比此值低，则按照REGISTER的Expires过期。\nappend_branches 默认是1, 当一个用户有多个Contacts时(比如:同一个账号使用不同的软电话注册),在lookup查找坐席时：\nappend_branches为1时,会给所有的Contact发送请求 append_branches为0时,只给第一个Contact发送请求 received_avp 1 modparam(\u0026#34;registrar\u0026#34;, \u0026#34;received_avp\u0026#34;, \u0026#34;$avp(s:rcv)\u0026#34;) 存储REGISTER的Received地址到s:rcv变量中。\nreceived_param 默认received, 返回200OK的Contact里带received变量: max_contacts 能接受的最大Contact个数,超过会报错503,设置max_contacts为1, 使用两个软电话注册同一个账号,第二个报错： retry_after REGISTER返回5xx错误之后，重新尝试注册的间隔。5xx的返回头带此参数Retry-After\nmethod_filtering lookup 查找用户时，contact是否支持method过滤,0不支持,其他为支持。\noutbound_mode 默认是0,接受不带Supported的REGISTER,返回的200OK不带Require 如果REGISTER带Require, 报错返回420 Bad Extension 1,接受带Supported的REGISTER,返回的200OK带Require或者Supported 2,拒绝不带Supported的REGISTER contact_max_size 设置contact的最大长度,默认为512\nuse_expired_contacts 是否使用过期的contacts,默认0不用,1使用\n重要函数介绍 save(domain, [,flag [,uri]]) domain为:location flag: 0x01: 不存DB,只缓存 0x02: 不生成SIP reply,不能用在ONREPLY_ROUTE上, 可以用在转发注册上 0x04: 只保存一个contact,同一个账号有多个软电话注册时,只会保存最新的一个contact 0x08: 使expires_rangeordefault_expires_range失效 0x10: 准备reply的Headers,要和0x02一起使用 url: flag必须先设置,自定义contact的uri 返回值: -2: 错误, 太多contact -1: 错误 1: contact保存成功 2: contact更新成功 3: contact删除成功 4: contact 返回 代理转发示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 route[REGISTRAR] { if (!is_method(\u0026#34;REGISTER\u0026#34;)) return; if(isflagset(FLT_NATS)) { setbflag(FLB_NATB); #!ifdef WITH_NATSIPPING # do SIP NAT pinging setbflag(FLB_NATSIPPING); #!endif } if (!save(\u0026#34;location\u0026#34;,\u0026#34;0x12\u0026#34;)) { sl_reply_error(); } $fs=\u0026#34;tcp:172.16.4.111:5461\u0026#34;; $du=\u0026#34;sip:172.16.4.114:5060;transport=tcp\u0026#34;; route(RELAY); exit; } $fs 为本地出去的地址, $du 为代理方的地址: 从信令可以看出,如果转发的sip协议是tcp,那么出去的端口不是5461,是随机生成的。 flag可以多个叠加，十六进制直接相加即可。 lookup(domain [, uri]) 查找contact, 把Contact放在Request-URI上,转发请求。\nregistered(domain [, uri [, match_option [, match_action]]]) 判断坐席是否已经注册\nunregister(domain, uri[, ruid]) 注销AOR\n总结 registrar模块还有一些其他的参数和函数未提到,目前场景中还未用到，重要的主要是注册，查找，注销功能。\nregistrar需要和usrloc一起使用。usrloc决定是否使用DB存储用户信息。\n","date":"2025-03-05T09:06:55+08:00","image":"https://QuincyGao.github.io/p/registrar%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/backup_hu727594043910014209.jpg","permalink":"https://QuincyGao.github.io/p/registrar%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","title":"registrar模块介绍"},{"content":"对比的版本 opensips kamailio 版本信息 3.3.10 5.8.5 官方文档地址 https://www.opensips.org/Documentation/Manuals https://www.kamailio.org/w/documentation/ 文档 opensips kamailio 核心变量 https://www.opensips.org/Documentation/Script-CoreVar-3-3 https://www.kamailio.org/wikidocs/cookbooks/5.8.x/pseudovariables/ 全局变量 1. https://www.opensips.org/Documentation/Script-CoreFunctions-3-3\n2. https://www.opensips.org/Documentation/Script-CoreParameters-3-3 https://www.kamailio.org/wikidocs/cookbooks/5.8.x/core/ 函数索引 https://www.opensips.org/Documentation/Function-Index-3-3 https://www.kamailio.org/wikidocs/alphaindexes/5.8.x/modfunctions/ 数据表 https://www.opensips.org/Documentation/Install-DBSchema-3-3 https://kamailio.org/docs/db-tables/kamailio-db-5.8.x.html 支持的route类型 序号 opensips kamailio 说明 1 route request_route 请求入口 2 branch_route[a] branch_route[a] 分支路由,a为自定义变量 3 failure_route[a] failure_route[a] 失败路由,a为自定义变量 4 onreply_route reply_route onreply_route{}\nonreply_route[0]{} 主返回路由 5 onreply_route[a] onreply_route[a] 子返回路由,a为自定义变量 6 event_route[a] event_route[a] 事件路由,a为自定义变量 7 error_route event_route[tm:branch-failure] 出错路由 8 local_route event_route[tm:local-request] 本地路由 9 startup_route event_route[core:worker-one-init]或者event_route[evrexec:timer] 服务启动时执行的路由 10 timer_route[a] RTimer模块 定时执行的路由, a为自定义变量 11 - onsend_route 请求发出去前执行的路由 监控管理端 差异 opensips kamailio 运行命令 opensips-cli kamctl 独立编译 是,仓库地址:\nhttps://github.com/OpenSIPS/opensips-cli.git 否\n没有单独仓库，和kamailio一起编译生成 编写语言 Python c 配置文件 ~/.opensips-cli.cfg kamctlrc 创建数据库 opensips-cli -f ~/.opensips-cli.cfg -x database create kamdbctl create kamailio 和服务端连接方式 fifo/http/udp fifo 说明:\nopensips-cli因为是Python编写，在做opensips容器时，如果把opensips-cli打包进去，整个包会较大。 可以把opensips-cli单独制作镜像，opensips-cli使用http方式和opensips服务端进行通信。 web管理服务 opensips kamailio 仓库地址 https://github.com/OpenSIPS/opensips-cp.git https://github.com/asipto/siremis-php.git 两个服务都是php的，不太好用，页面样式不好看，中文支持度不好,正在考虑使用Vue3重写。\n功能差异 模块 opensips kamailio 日志 日志默认带时间 日志默认不带时间,需要使用log_prefix自己设置 websocket - 支持跨域设置 dispatcher 必须使用数据库 可不使用数据库，从文件读取 缓存 cache_store/cache_remove/cache_fetch htable acc syslog/db存储/AAA/Events syslog/db存储 使用体验 维度 opensips kamailio 上手难度 简单 较高 star(截止20250227) 1.3k 2.4k 模块功能 能满足日常需求 较丰富，还有KEMI脚本语言实现(上手难度大) 官方文档 文档层次分明,模块清楚 文档完整 网络教程 大部分是2.x版本的，3.x文档不全 国内教程少 迭代变化 2.x和3.x版本配置参数区别较大 版本迭代配置参数变化不大 bug修复进度 较慢,起步一个月 较快，一周左右反馈 社区 没有 有,社区地址:\nhttps://lists.kamailio.org/mailman3/hyperkitty/list/sr-users@lists.kamailio.org/ 补充：\nopensips 适合快速上手,负载均衡，sip代理转发等基本能满足日常需求。 kamailio 可以作为进阶版本，后期完全可以不写.cfg配置，用KEMI脚本来写。 两个产品bug的issue都设置了定时删除，没有修复的话，需要自己回复一下才能不被删。 关于并发上，目前线上使用的opensips并未有崩溃的记录，8c8G的机器性能很高，具体可以查看我的opensips 压测介绍文章， kamailio目前还未压测，应该稳定性不差。 opensips没有社区，遇到问题只能提issue，kamailio可以先在社区提问，如果问题没有解决，再提issue。 ","date":"2025-02-28T14:12:33+08:00","permalink":"https://QuincyGao.github.io/p/opensips%E5%92%8Ckamailio%E6%AF%94%E8%BE%83%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/","title":"opensips和kamailio比较(持续更新中···)"},{"content":"背景介绍 本文主要是针对kamailio新手的入门使用介绍, 已默认kamailio服务编译安装成功。 关于kamailio的容器制作方式，后续会有其他章节介绍。\nkamailio 5.8.5 (x86_64/linux)\n准备环境 mysql 5.7.x rtpengine (可选) 创建数据库 我的kamailio安装在/usr/local下，几个目录介绍下：\n/usr/local/bin/ kamailio的二进制文件 1 2 3 4 5 6 ll /usr/local/bin/ total 8024 -rwxr-xr-x. 1 root root 8053416 Feb 27 13:52 kamailio # kamailio主程序 -rwxr-xr-x. 1 root root 74544 Feb 27 13:53 kamcmd # kamailio命令行 -rwxr-xr-x. 1 root root 66247 Feb 27 13:54 kamctl # kamailio控制台 -rwxr-xr-x. 1 root root 10935 Feb 27 13:54 kamdbctl # kamailio数据库管理 /usr/local/etc/kamailio kamailio的配置文件 1 2 3 4 5 ll /usr/local/etc/kamailio total 40 -rw-r--r--. 1 root root 27104 Feb 28 13:48 kamailio.cfg # kamailio主配置文件 -rw-r--r--. 1 root root 4391 Feb 28 13:48 kamctlrc # kamailio控制台配置文件 -rw-r--r--. 1 root root 3543 Feb 27 13:54 tls.cfg # tls配置文件 /usr/local/share/kamailio/ kamailio的sql脚本文件 1 2 3 4 5 ll /usr/local/share/kamailio/ total 4 drwxr-xr-x. 3 root root 22 Feb 27 13:53 db_redis drwxr-xr-x. 3 root root 22 Feb 27 13:53 dbtext drwxr-xr-x. 2 root root 4096 Feb 27 13:52 mysql 如果找不到这些文件，可以在源码utils/kamctl/下找到这些sql文件。\n修改配置文件：/usr/local/etc/kamailio/kamactlrc 如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 DBENGINE=MYSQL ## database host DBHOST=172.16.4.111 ## database port DBPORT=3306 ## database name (for ORACLE this is TNS name) DBNAME=kamailio ## database path used by dbtext, db_berkeley or sqlite DB_PATH=\u0026#34;/usr/local/share/kamailio/mysql\u0026#34; #DB_PATH=\u0026#34;/usr/local/etc/kamailio/dbtext\u0026#34; ## database read/write user DBRWUSER=\u0026#34;kamauser\u0026#34; ## password for database read/write user DBRWPW=\u0026#34;kamailiorw\u0026#34; ## database read only user DBROUSER=\u0026#34;kamailioro\u0026#34; ## password for database read only user DBROPW=\u0026#34;kamailiotest\u0026#34; ## database access host (from where is kamctl used) # DBACCESSHOST=192.168.0.1 ## database super user (for ORACLE this is \u0026#39;scheme-creator\u0026#39; user) DBROOTUSER=\u0026#34;root\u0026#34; ## password for database super user ## - important: this is insecure, targeting the use only for automatic testing ## - known to work for: mysql DBROOTPW=\u0026#34;123456\u0026#34; ## option to ask confirmation for all database creation steps # DBINITASK=yes ## database character set (used by MySQL when creating database) CHARSET=\u0026#34;utf8\u0026#34; 创建数据库：/usr/local/bin/kamdbctl create kamailio 创建过程中有可能会报创建用户失败(CREATE USER xxx failed)，有可能此用户已经存在，\n进入数据库，删除此用户drop user 'xxx'@'%'; 手动删除kamailio 重新使用kamdbctl创建库，就可以了。 几个常用的数据库(mysql5.7.x)操作命令：\n查看用户： 1 SELECT DISTINCT CONCAT(\u0026#39;User: \u0026#39;\u0026#39;\u0026#39;,user,\u0026#39;\u0026#39;\u0026#39;@\u0026#39;\u0026#39;\u0026#39;,host,\u0026#39;\u0026#39;\u0026#39;;\u0026#39;) AS query FROM mysql.user; 删除用户: 1 drop user \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39;; 配置文件：/usr/local/etc/kamailio/kamailio.cfg，修改以下几点： WITH_MYSQL 使用数据库 1 #!define WITH_MYSQL WITH_USRLOCDB 1 #!define WITH_USRLOCDB DBURL 修改dburl为实际的地址 1 #!trydef DBURL \u0026#34;mysql://kamauser:kamailiorw@172.16.4.111:3306/kamailio\u0026#34; listen 监听服务 1 listen=udp:172.16.4.111:5460 运行服务 /usr/local/bin/kamailio -f /usr/local/etc/kamailio/kamailio.cfg -DD -E\n使用软电话MicroSip注册, 密码:1234(随便,默认是没开启用户认证功能),配置如下： 可以再使用另外一个MicroSip注册其他用户到此服务上，两个软电话就能互相拨打了。 ","date":"2025-02-27T15:53:07+08:00","image":"https://QuincyGao.github.io/p/kamailio%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/backup_hu94911474509027823.jpg","permalink":"https://QuincyGao.github.io/p/kamailio%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/","title":"kamailio入门使用"},{"content":"功能介绍 topology_hiding 功能主要是隐藏Hearder头里的(Via,Record-Route,Route)，防止被其他服务器探测到。\n在opensips以udp方式转发sip请求时，有可能Header很大，超过了MTU,此时udp会有概率发送失败。 有人可能会想用此方式来减少包量，通过这篇介绍，你就能知道实际上Header头并未减少多少,效果不大。 遇到这种情况，还不如删除一部分头或者改成tcp方式。\n模块配置 opensips版本：\nopensips 3.3.10 (x86_64/linux)\n正常代理的配置： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 loadmodule \u0026#34;dialog.so\u0026#34; route{ if (!mf_process_maxfwd_header(10)) { sl_send_reply(483,\u0026#34;Too Many Hops\u0026#34;); exit; } if (has_totag()) { # sequential requests within a dialog should # take the path determined by record-routing xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---has_totag-:$rm|$rs|$tu|$socket_in(port)\\n\u0026#34;); if (loose_route()) { if (is_method(\u0026#34;INVITE\u0026#34;)) { # even if in most of the cases is useless, do RR for # re-INVITEs alos, as some buggy clients do change route set # during the dialog. record_route(); } # route it out to whatever destination was set by loose_route() # in $du (destination URI). xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---is-loose_route-:$rm|$rs|$tu|$socket_in(port)\\n\u0026#34;); route(relay); } else { xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---not-loose_route-:$rm|$rs|$tu|$socket_in(port)\\n\u0026#34;); if ( is_method(\u0026#34;ACK\u0026#34;) ) { if ( t_check_trans() ) { # non loose-route, but stateful ACK; must be an ACK after # a 487 or e.g. 404 from upstream server t_relay(); exit; } else { # ACK without matching transaction -\u0026gt; # ignore and discard exit; } } sl_send_reply(404,\u0026#34;Not here\u0026#34;); } exit; } # CANCEL processing if (is_method(\u0026#34;CANCEL\u0026#34;)) { if (t_check_trans()) t_relay(); exit; } t_check_trans(); #if (!is_method(\u0026#34;REGISTER\u0026#34;)) { # if (is_myself(\u0026#34;$fd\u0026#34;)) { # # if caller is not local, then called number must be local # if (!is_myself(\u0026#34;$rd\u0026#34;)) { # send_reply(403,\u0026#34;Rely forbidden\u0026#34;); # exit; # } # } #} # preloaded route checking if (loose_route()) { xlog(\u0026#34;L_ERR\u0026#34;, \u0026#34;Attempt to route with preloaded Route\u0026#39;s [$fu/$tu/$ru/$ci]\u0026#34;); if (!is_method(\u0026#34;ACK\u0026#34;)) sl_send_reply(403,\u0026#34;Preload Route denied\u0026#34;); exit; } # record routing if (!is_method(\u0026#34;REGISTER|MESSAGE\u0026#34;)) record_route(); if (!is_myself(\u0026#34;$rd\u0026#34;)) { append_hf(\u0026#34;P-hint: outbound\\r\\n\u0026#34;); route(relay); } # requests for my domain if (is_method(\u0026#34;PUBLISH|SUBSCRIBE\u0026#34;)) { sl_send_reply(503, \u0026#34;Service Unavailable\u0026#34;); exit; } # check if the clients are using WebSockets or WebSocketSecure if ( $socket_in(proto) == \u0026#34;WS\u0026#34;|| $socket_in(proto) == \u0026#34;WSS\u0026#34;) setflag(\u0026#34;SRC_WS\u0026#34;); # consider the client is behind NAT - always fix the contact #fix_nated_contact(); xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---main-1-:$rm|$rs|$tu|$socket_in(port)|$hdr(contact)\\n\u0026#34;); if (is_method(\u0026#34;REGISTER\u0026#34;)) { # indicate that the client supports DTLS # so we know when he is called if (isflagset(\u0026#34;SRC_WS\u0026#34;)) setbflag(\u0026#34;DST_WS\u0026#34;); fix_nated_register(); if (!save(\u0026#34;location\u0026#34;)) sl_reply_error(); exit; } xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---main--:$rm|$rs|$tu|$socket_in(port)|$hdr(contact)\\n\u0026#34;); if ($rU==NULL) { # request with no Username in RURI sl_send_reply(484,\u0026#34;Address Incomplete\u0026#34;); exit; } # do lookup with method filtering if (!lookup(\u0026#34;location\u0026#34;,\u0026#34;m\u0026#34;)) { $ru = \u0026#34;sip:172.16.4.114:5080\u0026#34;; $socket_out = \u0026#34;udp:172.16.4.111:5361\u0026#34;; } #if (!lookup(\u0026#34;location\u0026#34;,\u0026#34;m\u0026#34;)) { # t_newtran(); # t_reply(404, \u0026#34;Not Found\u0026#34;); # exit; #} route(relay); } route[relay] { # for INVITEs enable some additional helper routes if (is_method(\u0026#34;INVITE\u0026#34;)) { t_on_branch(\u0026#34;handle_nat\u0026#34;); t_on_reply(\u0026#34;handle_nat\u0026#34;); } else if (is_method(\u0026#34;BYE|CANCEL\u0026#34;)) { rtpengine_delete(); } if (!t_relay()) { send_reply(500,\u0026#34;Internal Error\u0026#34;); }; exit; } branch_route[handle_nat] { if (!is_method(\u0026#34;INVITE\u0026#34;) || !has_body(\u0026#34;application/sdp\u0026#34;)) return; $var(rtp_flag) = \u0026#34;replace-origin \u0026#34;; if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) { #web-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; ICE=force-relay DTLS=passive\u0026#34;; } else if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)){ #web-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; codec-strip-G722 codec-strip-CN codec-strip-red strip-extmap rtcp-mux-demux DTLS=off SDES-off ICE=remove RTP/AVP\u0026#34;; } else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) {#sip-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; rtcp-mux-offer generate-mid DTLS=passive SDES-off ICE=force RTP/SAVPF\u0026#34;; } else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)) #sip-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; DTLS=off SDES-off ICE=remove RTP/AVP\u0026#34;; rtpengine_offer(\u0026#34;$var(rtp_flag)\u0026#34;); } onreply_route[handle_nat] { fix_nated_contact(); if (!has_body(\u0026#34;application/sdp\u0026#34;)) return; $var(rtp_flag) = \u0026#34;replace-origin \u0026#34;; if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) #web-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; ICE=force-relay DTLS=passive\u0026#34;; else if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)) #web-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; codec-strip-G722 codec-strip-CN codec-strip-red codec-strip-opus rtcp-mux-offer generate-mid DTLS=passive SDES-off ICE=force\u0026#34;; else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) #sip-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; rtcp-mux-offer generate-mid DTLS=passive SDES-off ICE=remove RTP/AVP\u0026#34;; else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)) #sip-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; DTLS=off SDES-off ICE=remove RTP/AVP\u0026#34;; rtpengine_answer(\u0026#34;$var(rtp_flag)\u0026#34;); } 使用topology_hiding的配置： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 loadmodule \u0026#34;dialog.so\u0026#34; loadmodule \u0026#34;topology_hiding.so\u0026#34; modparam(\u0026#34;topology_hiding\u0026#34;, \u0026#34;th_callid_passwd\u0026#34;, \u0026#34;my_topo_hiding_secret\u0026#34;) modparam(\u0026#34;topology_hiding\u0026#34;, \u0026#34;th_callid_prefix\u0026#34;, \u0026#34;MYCALLIDPREFIX_\u0026#34;) modparam(\u0026#34;topology_hiding\u0026#34;, \u0026#34;th_passed_contact_uri_params\u0026#34;, \u0026#34;paramname1;myparam;custom_param\u0026#34;) modparam(\u0026#34;topology_hiding\u0026#34;, \u0026#34;th_passed_contact_params\u0026#34;, \u0026#34;paramname1;myparam;custom_param\u0026#34;) modparam(\u0026#34;topology_hiding\u0026#34;, \u0026#34;th_contact_encode_passwd\u0026#34;, \u0026#34;my_topoh_passwd\u0026#34;) modparam(\u0026#34;topology_hiding\u0026#34;, \u0026#34;th_contact_encode_param\u0026#34;, \u0026#34;customparam\u0026#34;) route{ if (!mf_process_maxfwd_header(10)) { sl_send_reply(483,\u0026#34;Too Many Hops\u0026#34;); exit; } if (has_totag()) { # sequential requests within a dialog should # take the path determined by record-routing xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---has_totag-:$rm|$rs|$tu|$socket_in(port)\\n\u0026#34;); if (topology_hiding_match()) { if (is_method(\u0026#34;INVITE\u0026#34;)) { # even if in most of the cases is useless, do RR for # re-INVITEs alos, as some buggy clients do change route set # during the dialog. record_route(); } # route it out to whatever destination was set by loose_route() # in $du (destination URI). xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---is-loose_route-:$rm|$rs|$tu|$socket_in(port)\\n\u0026#34;); route(relay); } else { xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---not-loose_route-:$rm|$rs|$tu|$socket_in(port)\\n\u0026#34;); if ( is_method(\u0026#34;ACK\u0026#34;) ) { if ( t_check_trans() ) { # non loose-route, but stateful ACK; must be an ACK after # a 487 or e.g. 404 from upstream server t_relay(); exit; } else { # ACK without matching transaction -\u0026gt; # ignore and discard exit; } } sl_send_reply(404,\u0026#34;Not here\u0026#34;); } exit; } # CANCEL processing if (is_method(\u0026#34;CANCEL\u0026#34;)) { if (t_check_trans()) t_relay(); exit; } t_check_trans(); #if (!is_method(\u0026#34;REGISTER\u0026#34;)) { # if (is_myself(\u0026#34;$fd\u0026#34;)) { # # if caller is not local, then called number must be local # if (!is_myself(\u0026#34;$rd\u0026#34;)) { # send_reply(403,\u0026#34;Rely forbidden\u0026#34;); # exit; # } # } #} # preloaded route checking if (loose_route()) { xlog(\u0026#34;L_ERR\u0026#34;, \u0026#34;Attempt to route with preloaded Route\u0026#39;s [$fu/$tu/$ru/$ci]\u0026#34;); if (!is_method(\u0026#34;ACK\u0026#34;)) sl_send_reply(403,\u0026#34;Preload Route denied\u0026#34;); exit; } # record routing if (!is_method(\u0026#34;REGISTER|MESSAGE\u0026#34;)) record_route(); if (!is_myself(\u0026#34;$rd\u0026#34;)) { append_hf(\u0026#34;P-hint: outbound\\r\\n\u0026#34;); route(relay); } # requests for my domain if (is_method(\u0026#34;PUBLISH|SUBSCRIBE\u0026#34;)) { sl_send_reply(503, \u0026#34;Service Unavailable\u0026#34;); exit; } # check if the clients are using WebSockets or WebSocketSecure if ( $socket_in(proto) == \u0026#34;WS\u0026#34;|| $socket_in(proto) == \u0026#34;WSS\u0026#34;) setflag(\u0026#34;SRC_WS\u0026#34;); # consider the client is behind NAT - always fix the contact #fix_nated_contact(); xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---main-1-:$rm|$rs|$tu|$socket_in(port)|$hdr(contact)\\n\u0026#34;); if (is_method(\u0026#34;REGISTER\u0026#34;)) { # indicate that the client supports DTLS # so we know when he is called if (isflagset(\u0026#34;SRC_WS\u0026#34;)) setbflag(\u0026#34;DST_WS\u0026#34;); fix_nated_register(); if (!save(\u0026#34;location\u0026#34;)) sl_reply_error(); exit; } xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---main--:$rm|$rs|$tu|$socket_in(port)|$hdr(contact)\\n\u0026#34;); if ($rU==NULL) { # request with no Username in RURI sl_send_reply(484,\u0026#34;Address Incomplete\u0026#34;); exit; } if (is_method(\u0026#34;INVITE\u0026#34;) \u0026amp;\u0026amp; !has_totag()) { topology_hiding(); } # do lookup with method filtering if (!lookup(\u0026#34;location\u0026#34;,\u0026#34;m\u0026#34;)) { $ru = \u0026#34;sip:172.16.4.114:5080\u0026#34;; $socket_out = \u0026#34;udp:172.16.4.111:5361\u0026#34;; } #if (!lookup(\u0026#34;location\u0026#34;,\u0026#34;m\u0026#34;)) { # t_newtran(); # t_reply(404, \u0026#34;Not Found\u0026#34;); # exit; #} route(relay); } route[relay] { # for INVITEs enable some additional helper routes if (is_method(\u0026#34;INVITE\u0026#34;)) { t_on_branch(\u0026#34;handle_nat\u0026#34;); t_on_reply(\u0026#34;handle_nat\u0026#34;); } else if (is_method(\u0026#34;BYE|CANCEL\u0026#34;)) { rtpengine_delete(); } if (!t_relay()) { send_reply(500,\u0026#34;Internal Error\u0026#34;); }; exit; } branch_route[handle_nat] { if (!is_method(\u0026#34;INVITE\u0026#34;) || !has_body(\u0026#34;application/sdp\u0026#34;)) return; $var(rtp_flag) = \u0026#34;replace-origin \u0026#34;; if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) { #web-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; ICE=force-relay DTLS=passive\u0026#34;; } else if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)){ #web-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; codec-strip-G722 codec-strip-CN codec-strip-red strip-extmap rtcp-mux-demux DTLS=off SDES-off ICE=remove RTP/AVP\u0026#34;; } else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) {#sip-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; rtcp-mux-offer generate-mid DTLS=passive SDES-off ICE=force RTP/SAVPF\u0026#34;; } else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)) #sip-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; DTLS=off SDES-off ICE=remove RTP/AVP\u0026#34;; rtpengine_offer(\u0026#34;$var(rtp_flag)\u0026#34;); } onreply_route[handle_nat] { fix_nated_contact(); if (!has_body(\u0026#34;application/sdp\u0026#34;)) return; $var(rtp_flag) = \u0026#34;replace-origin \u0026#34;; if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) #web-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; ICE=force-relay DTLS=passive\u0026#34;; else if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)) #web-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; codec-strip-G722 codec-strip-CN codec-strip-red codec-strip-opus rtcp-mux-offer generate-mid DTLS=passive SDES-off ICE=force\u0026#34;; else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) #sip-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; rtcp-mux-offer generate-mid DTLS=passive SDES-off ICE=remove RTP/AVP\u0026#34;; else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)) #sip-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; DTLS=off SDES-off ICE=remove RTP/AVP\u0026#34;; rtpengine_answer(\u0026#34;$var(rtp_flag)\u0026#34;); } 对比两份配置,可以看出在has_totag内的处理有些差异，也就是软电话收到200OK,返回ACK之后的处理， 使用了topology_hiding,软电话返回的ACK里没有Route,所以就不需要使用loose_route, 直接使用topology_hiding_match来解析链路转发。\n实际使用示例 完整通话信令图: INVITE到被代理方(114机器) 正常sip 隐藏sip 可以看到Record-Route被隐藏了, Via隐藏了软电话的地址。\nContact替换成了发送到被代理方请求出口的ip和port。 Contact内隐藏的一些其他信息按照base64方式存到了customparam, 可以看到数据还是很长。\n被代理方返回200OK 因为183和200ok的头差别不大，所以以200OK为例：\n正常sip 隐藏sip 在使用topology_hiding时，被代理方因为收到的INVITE信令中没有Record-Route,所以返回200OK也不会有。\nopensips返回200OK 正常sip 隐藏sip 在使用topology_hiding时，opensips把软电话的地址补充到了Via, Contact修改成了opensip出口的ip和port.\n软电话返回ACK 正常sip 隐藏sip 在使用topology_hiding时, 因为返回的200OK,没有Record-Route,所以软电话返回的ACK也就没有Route。\n被代理方返回BYE 正常sip 隐藏sip 在使用topology_hiding时, 因为收到的INVITE,没有Record-Route,所以被代理方发送BYE也就没有Record-Route。 Via使用的是INVITE带的Via。\nopensips返回BYE 正常sip 隐藏sip 在使用topology_hiding时, 修改了Via为出口ip和port.\n软电话返回200OK 正常sip 隐藏sip opensips返回200OK 正常sip 隐藏sip 在使用topology_hiding时, 修改了Via为被代理方的ip和port.\ntopology_hiding 参数示例 U:用户名补充到contact中 1 topology_hiding(\u0026#34;U\u0026#34;); 往被代理方发送INVITE,效果： topology_hiding(\u0026quot;U\u0026quot;)会补充用户名1002到contact中\nD:把DID补充到Contact用户名中 1 2 modparam(\u0026#34;topology_hiding\u0026#34;, \u0026#34;force_dialog\u0026#34;, 1) topology_hiding(\u0026#34;D\u0026#34;); 往被代理方发送INVITE,效果： C:对Call-id编码 1 2 modparam(\u0026#34;topology_hiding\u0026#34;, \u0026#34;force_dialog\u0026#34;, 1) topology_hiding(\u0026#34;C\u0026#34;); 往被代理方发送INVITE,效果： call-id会被编码，导致和软电话请求过来的call-id不一致。\na/A: 目前并未看到效果.\n","date":"2025-02-26T10:15:32+08:00","image":"https://QuincyGao.github.io/p/topology_hiding%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/11_hu8978428634062723750.jpg","permalink":"https://QuincyGao.github.io/p/topology_hiding%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","title":"topology_hiding模块介绍"},{"content":"使用场景 registrar和mid_registrar都是用来存储用户注册信息的模块，mid_registrar主要是充当注册中间件，需要代理转发, 另外也可以降低被代理方的注册请求的次数。registrar模块也支持代理转发，但是不能拦截注册请求到被代理方。\n两个模块的数据都缓存在usrloc里。\n使用示例 opensips版本:\nopensips 3.3.10 (x86_64/linux)\nregistrar 重要参数介绍 default_expires: 默认注册过期时间,单位秒 min_expires: 最小注册过期时间,Contact中的过期时间小于此值，会被设置为此值,单位秒 max_expires: 最大注册过期时间,Contact中的过期时间大于此值，会被设置为此值,单位秒 tcp_presentent_flag: 此参数会设置tcp连接的生命周期为contact的过期时间，如果设置为-1，则不设置。 received_avp: 存储received字段的avp，常常和nathelper模块一起使用. recevied_param: 设置200OK信令的Contact中的received字段,默认为received max_contacts: 限制每个用户最大注册数的contact,超过会报错5xx。 代理配置示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 socket=udp:172.16.4.111:5360 socket=tcp:172.16.4.111:5360 socket=udp:172.16.4.111:5361 loadmodule \u0026#34;usrloc.so\u0026#34; loadmodule \u0026#34;registrar.so\u0026#34; loadmodule \u0026#34;nathelper.so\u0026#34; modparam(\u0026#34;registrar|nathelper\u0026#34;, \u0026#34;received_avp\u0026#34;, \u0026#34;$avp(rcv)\u0026#34;) modparam(\u0026#34;registrar\u0026#34;, \u0026#34;default_expires\u0026#34;, 1800) modparam(\u0026#34;registrar\u0026#34;, \u0026#34;tcp_persistent_flag\u0026#34;, \u0026#34;TCP_PERSIST_DURATION\u0026#34;) route { ... if (is_method(\u0026#34;REGISTER\u0026#34;)) { # indicate that the client supports DTLS # so we know when he is called if (isflagset(\u0026#34;SRC_WS\u0026#34;)) setbflag(\u0026#34;DST_WS\u0026#34;); fix_nated_register(); if (!save(\u0026#34;location\u0026#34;,\u0026#34;rfc1\u0026#34;)) sl_reply_error(); if ($socket_in(proto) == \u0026#34;tcp\u0026#34;) { setflag(\u0026#34;TCP_PERSIST_DURATION\u0026#34;); xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---main-1-:$rm|$tu|$socket_in(port)|$socket_in(proto)\\n\u0026#34;); } $socket_out = \u0026#34;udp:172.16.4.111:5361\u0026#34;; sethostport(\u0026#34;172.16.4.114:5060\u0026#34;); if (!t_relay()) { send_reply(500, \u0026#34;Internal Error\u0026#34;); } exit; } if (!lookup(\u0026#34;location\u0026#34;,\u0026#34;m\u0026#34;)) { t_newtran(); t_reply(404, \u0026#34;Not Found\u0026#34;); exit; } route(relay); } 坐席的信令图： save(\u0026quot;location\u0026quot;,\u0026quot;rfc1\u0026quot;): rfc1 表示usrloc一个用户只保存一个Contact信息,这样在webrtc连接中，及时更新往新的连接发送请求地址。\n如果opensips中坐席过期时间小于被代理方，opensips过期之后不会重新往被代理方发送注册请求。\nmid_registrar 代理配置示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 socket=udp:172.16.4.111:5326 socket=udp:172.16.4.111:5360 socket=tcp:172.16.4.111:5360 socket=udp:172.16.4.111:5361 loadmodule \u0026#34;mid_registrar.so\u0026#34; modparam(\u0026#34;mid_registrar\u0026#34;, \u0026#34;mode\u0026#34;, 0) modparam(\u0026#34;mid_registrar|nathelper\u0026#34;, \u0026#34;received_avp\u0026#34;, \u0026#34;$avp(rcv)\u0026#34;) modparam(\u0026#34;mid_registrar\u0026#34;, \u0026#34;outgoing_expires\u0026#34;, 80) modparam(\u0026#34;mid_registrar\u0026#34;, \u0026#34;tcp_persistent_flag\u0026#34;, \u0026#34;TCP_PERSIST_REGISTRATIONS\u0026#34;) modparam(\u0026#34;mid_registrar\u0026#34;, \u0026#34;max_expires\u0026#34;, 130) modparam(\u0026#34;mid_registrar\u0026#34;, \u0026#34;attr_avp\u0026#34;, \u0026#34;$avp(attr)\u0026#34;) route { ... if (is_method(\u0026#34;REGISTER\u0026#34;)) { # indicate that the client supports DTLS # so we know when he is called if (isflagset(\u0026#34;SRC_WS\u0026#34;)) setbflag(\u0026#34;DST_WS\u0026#34;); #fix_nated_register(); mid_registrar_save(\u0026#34;location\u0026#34;); switch ($retcode) { case 1: if ($socket_in(proto) == \u0026#34;tcp\u0026#34;) { setflag(\u0026#34;TCP_PERSIST_REGISTRATIONS\u0026#34;); xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---main-1-:$rm|$tu|$socket_in(port)|$socket_in(proto)\\n\u0026#34;); } $socket_out = \u0026#34;udp:172.16.4.111:5361\u0026#34;; $ru = \u0026#34;sip:172.16.4.114:5060\u0026#34;; if (!t_relay()) { send_reply(500, \u0026#34;Internal Error\u0026#34;); } break; case 2: xlog(\u0026#34;L_INFO\u0026#34;, \u0026#34;REGISTER has been absorbed!\\n\u0026#34;); break; default: xlog(\u0026#34;L_ERR\u0026#34;, \u0026#34;mid-registrar error!\\n\u0026#34;); send_reply(500, \u0026#34;Server Internal Error 2\u0026#34;); } exit; } } mode = 0 当outgoing_expires大于max_expires时： 能够得出的结论为：\n软电话的Expires:200, opensips的过期时间为:130,此时发送给114的Expires为200. 114保存的过期时间为200, 而opensips保存的过期时间为130，返回给软电话的过期时间为130. 软电话130s过期之后，会重新发送Register，此时opensips会转发请求给114机器。 当outgoing_expires小于max_expires时： mode = 1 当outgoing_expires 比opensips的max_expires很大时： sip信息： 能够得出的结论为：\nopensips保存的expires为80， 被代理方114机器保存的expires为:outgoing_expires 当软电话的过期时间到了之后，opensips不会再转发请求到114. 当outgoing_expires 比opensips的max_expires较大时： sip信息： 能够看到，opensips内部应该有对被代理方Expires的计数器，当收到软电话的注册信息时，如果被代理方的过期时间还很长，便不会转发请求到被代理方，时间较短时，会把注册请求重新转发给被代理方。\n当outgoing_expires小于max_expires时： 此时可以看到软电话过期时，opensips会转发请求到被代理方。\nmode = 2 当outgoing_expires很大时： 和mode=1 情况一样\n当outgoing_expires大于max_expires时： 114上的坐席过期之后，opensips不会再往114转发请求。\n当outgoing_expires小于max_expires时： sip信息： 此时，被代理方114机器的过期时间到了之后，坐席信息被删除，之后的REGISTER并未再转发到114机器上，导致114机器上一直都没有坐席的信息。\n总结 mode=0 时，被代理方的过期时间和软电话传的一致, opensips的过期时间为max_expires时间。 mode=1 时，被代理方的过期时间和outgoing_expires时间一致，opensips过期时间为max_expires时间。 mode=2 时，opensips不会再转发REGISTER到114机器上，即使被代理方的坐席过期。 ","date":"2025-02-24T11:34:47+08:00","image":"https://QuincyGao.github.io/p/registrar%E5%92%8Cmid_registrar%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/9_hu12160269104167841556.jpg","permalink":"https://QuincyGao.github.io/p/registrar%E5%92%8Cmid_registrar%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","title":"registrar和mid_registrar模块介绍"},{"content":"背景 最近在使用opensips的wss模块，前端使用jssip封装webrtc。\n正式环境中web前端不会开启console打印webrtc交互信令，当需要排查问题时，此时会变得异常困难。\n世面上能用的工具都试过了,不管是sngrep还是wireshark抓包，都无法解析wss信令(wireshark即便是有tls的公私钥,也无法解析)。\nssldump 一方面没有centos的包，需要用容器做镜像(如果感兴趣后续可以介绍)，另一方面，它必须从建立连接时开始抓包，无法抓到建立连接之后的信令。\nopensips的tracer模块，就能很好解决这个问题。官方文档：tracer模块\nopensips的版本信息：\nopensips 3.3.10 (x86_64/linux)\ntrace设置方式 trace_id的设置主要有4个方式： 写DB\nmodparam(\u0026quot;tracer\u0026quot;, \u0026quot;trace_id\u0026quot;,\u0026quot;[tid]uri=mysql://xxxx:xxxx@10.10.10.10/opensips;table=sip_trace;\u0026quot;) 这个会直接把数据插入到数据表sip_trace中,这个opensip的DB默认表已有此表结构。\n写文件\nmodparam(\u0026quot;tracer\u0026quot;, \u0026quot;trace_id\u0026quot;,\u0026quot;[tid]uri=file:/tmp/trace.log\u0026quot;) 这个会直接把数据写入到文件/tmp/trace.log中，需要设置file_mode\n写入hep_server端\nmodparam(\u0026quot;tracer\u0026quot;, \u0026quot;trace_id\u0026quot;,\u0026quot;[tid]uri=hep://10.10.10.10:xxxx\u0026quot;) 或者 modparam(\u0026quot;tracer\u0026quot;, \u0026quot;trace_id\u0026quot;, \u0026quot;[tid]uri=hep:hid\u0026quot;)\n写入syslog\nmodparam(\u0026quot;tracer\u0026quot;, \u0026quot;trace_id\u0026quot;,\u0026quot;[tid]uri=syslog:local0:-1\u0026quot;)\n调用trace功能 官方接口介绍：\n1 trace(trace_id, [scope], [type], [trace_attrs], [flags], [correlation_id]) 主要参数说明：\nscope\n\u0026rsquo;m/M\u0026rsquo; 无状态模式下，追踪消息 \u0026rsquo;t/T\u0026rsquo; tm模块如果没加载，追踪事务，包括 in和out的请求以及内部的回复 \u0026rsquo;d/D\u0026rsquo; 追踪dialog \u0026lsquo;b/B\u0026rsquo; 追踪B2B信息 type\nsip 追踪sip信令 xlog 追踪xlog里的信息(dialog, transaction, B2B) rest 追踪rest 接口信息 实战配置 统一调用方法：\n1 2 3 4 5 6 if (is_method(\u0026#34;REGISTER\u0026#34;)) { trace(\u0026#34;tid\u0026#34;, \u0026#34;t\u0026#34;,\u0026#34;sip\u0026#34;); } if (is_method(\u0026#34;INVITE\u0026#34;) \u0026amp;\u0026amp; !has_totag())) { trace(\u0026#34;tid\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;sip\u0026#34;); } 写DB 配置:\n1 2 3 loadmodule \u0026#34;db_mysql.so\u0026#34; loadmodule \u0026#34;tracer.so\u0026#34; modparam(\u0026#34;tracer\u0026#34;, \u0026#34;trace_id\u0026#34;,\u0026#34;[tid]uri=mysql://opensips:opensipsrw@172.16.3.121:3306/opensips;table=sip_trace;\u0026#34;) 此时就可以在数据表sip_trace中查看到trace信息了。 写文件 配置:\n1 2 3 loadmodule \u0026#34;tracer.so\u0026#34; modparam(\u0026#34;tracer\u0026#34;, \u0026#34;trace_id\u0026#34;,\u0026#34;[tid]uri=file:/tmp/trace.log\u0026#34;) modparam(\u0026#34;tracer\u0026#34;, \u0026#34;file_mode\u0026#34;, \u0026#34;0644\u0026#34;) 此时就可以在/tmp/trace.log文件中查看到trace信息了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 in wss 2025-02-21 11:05:20 172.16.80.21:37885 -\u0026gt; 172.16.4.113:9443 REGISTER sip:172.16.4.113:9443 SIP/2.0 Via: SIP/2.0/WSS n98f6pr114j5.invalid;branch=z9hG4bK1737010 Max-Forwards: 68 To: \u0026lt;sip:88880022@172.16.4.113:9443\u0026gt; From: \u0026#34;88880022\u0026#34; \u0026lt;sip:88880022@172.16.4.113:9443\u0026gt;;tag=v68n10kvr9 Call-ID: l013jm5gns5uk30rlpe8ht CSeq: 18 REGISTER X-SBC: Dinstar Mediant Contact: \u0026lt;sip:88880022@n98f6pr114j5.invalid;transport=ws\u0026gt;;+sip.ice;reg-id=1;+sip.instance=\u0026#34;\u0026lt;urn:uuid:a17d9354-7175-46b9-a17a-d86a73ebb150\u0026gt;\u0026#34;;expires=600 Expires: 600 Authorization: Digest algorithm=MD5, username=\u0026#34;88880022\u0026#34;, realm=\u0026#34;huawei\u0026#34;, nonce=\u0026#34;856ef8e5f85686a917325343ffe6f9bd\u0026#34;, uri=\u0026#34;sip:172.16.4.113:9443\u0026#34;, response=\u0026#34;5b9367e936dcdb9464b2793fdd849bc9\u0026#34; Allow: INVITE,ACK,CANCEL,BYE,UPDATE,MESSAGE,OPTIONS,REFER,INFO,NOTIFY,SUBSCRIBE Supported: path,gruu,outbound User-Agent: Dinstar WebRTC SDK. Simple phone 1.17.0 Chrome/133 Content-Length: 0 out udp 2025-02-21 11:05:20 172.16.4.113:5263 -\u0026gt; 172.16.7.208:5060 REGISTER sip:172.16.7.208:5060 SIP/2.0 Via: SIP/2.0/UDP 172.16.4.113:5263;branch=z9hG4bKaa1c.91292206.0;i=cf637872 Via: SIP/2.0/WSS n98f6pr114j5.invalid;received=172.16.80.21;branch=z9hG4bK1737010 Max-Forwards: 68 To: \u0026lt;sip:88880022@172.16.4.113:9443\u0026gt; From: \u0026#34;88880022\u0026#34; \u0026lt;sip:88880022@172.16.4.113:9443\u0026gt;;tag=v68n10kvr9 Call-ID: l013jm5gns5uk30rlpe8ht CSeq: 18 REGISTER X-SBC: Dinstar Mediant Contact: \u0026lt;sip:88880022@172.16.4.113:5263\u0026gt;;expires=600 Expires: 600 Authorization: Digest algorithm=MD5, username=\u0026#34;88880022\u0026#34;, realm=\u0026#34;huawei\u0026#34;, nonce=\u0026#34;856ef8e5f85686a917325343ffe6f9bd\u0026#34;, uri=\u0026#34;sip:172.16.4.113:9443\u0026#34;, response=\u0026#34;5b9367e936dcdb9464b2793fdd849bc9\u0026#34; Allow: INVITE,ACK,CANCEL,BYE,UPDATE,MESSAGE,OPTIONS,REFER,INFO,NOTIFY,SUBSCRIBE Supported: path,gruu,outbound User-Agent: Dinstar WebRTC SDK. Simple phone 1.17.0 Chrome/133 Content-Length: 0 写入hep_server端 本次测试使用的是 hep-server：hep-connect\nweb前端显示：siphub\n配置:\n1 2 3 4 5 socket=hep_udp:172.16.4.113:6000 loadmodule \u0026#34;tracer.so\u0026#34; loadmodule \u0026#34;proto_hep.so\u0026#34; modparam(\u0026#34;proto_hep\u0026#34;, \u0026#34;hep_id\u0026#34;,\u0026#34;[hid] 172.16.4.111:9060;transport=udp;version=3\u0026#34;) modparam(\u0026#34;tracer\u0026#34;, \u0026#34;trace_id\u0026#34;,\u0026#34;[tid]uri=hep:hid\u0026#34;) socket是opensips 客户端发送proto_hep数据的端口 hep_id是hep_server的监听端口 此时打开siphub的web页面：http://172.0.0.1:3000/ 可以看到: 点击Call-ID 可以看到详细的sip信令信息: 写入syslog 1 2 3 4 5 6 7 8 log_level=3 xlog_level=4 log_stderror=no log_facility=LOG_LOCAL0 loadmodule \u0026#34;tracer.so\u0026#34; modparam(\u0026#34;tracer\u0026#34;, \u0026#34;syslog_default_facility\u0026#34;,\u0026#34;LOG_LOCAL0\u0026#34;) modparam(\u0026#34;tracer\u0026#34;, \u0026#34;syslog_default_level\u0026#34;, 4) modparam(\u0026#34;tracer\u0026#34;, \u0026#34;trace_id\u0026#34;,\u0026#34;[tid]uri=syslog\u0026#34;) 这个功能暂时未测成功，opensips的日志输出到syslog,但是在日志中未看到trace信息。\n总结 通过上述的方法，可以看到很容易跟踪sip信令。\n如果需要对opensips做监控，那么使用hep-server是比较合适的选择。 临时性排查问题，一般的sip传送方式tcp/udp/ws，使用sngrep都能搞定。 针对wss信令，使用trace写文件，可能是比较轻量的选择。 ","date":"2025-02-21T11:33:22+08:00","image":"https://QuincyGao.github.io/p/tracer%E6%A8%A1%E5%9D%97/8_hu14940933373703095982.jpg","permalink":"https://QuincyGao.github.io/p/tracer%E6%A8%A1%E5%9D%97/","title":"tracer模块"},{"content":"NAT 协议 NAT协议参考：RFC 2663\nNAT For TCP: RFC 5382\nNAT For UDP: RFC 4787\n在介绍opensips的这两个模块使用之前，我们需要先了解一下NAT相关的概念。 NAT (Network Address Translation),网络地址转换，是一种网络地址转换技术， 主要是将内部的私有IP地址转换为公共IP地址，使得外部网络能够访问到内部的私有网络。\nNAT 类型 静态NAT 一个公网IP对应一个私网IP，一对一转换，仅支持地址转换，不支持端口映射。 需要维护一个公共的地址池,目前已经不再使用。\nNAPT 目前说的NAT基本上指的就是NAPT了，NAPT使用端口多路复用技术，不但要地址ip转换，还要端口映射。 主要有以下几类：\nFull Cone NAT(完全锥形NAT) 特点：ip和port都不设限. 场景： client 发送数据包给server1, 通过NAT设备完成192.168.0.1:3000\u0026lt;\u0026ndash;\u0026gt;1.2.3.4:6000的映射。\nserver1收到数据包后，可以往1.2.3.4:6000发送数据包，server2也能往1.2.3.4:6000发送数据包。\nRestricted Cone NAT(限制锥形NAT) 特点：ip设限，port不设限. 场景： client 发送数据包给server1, 通过NAT设备完成192.168.0.1:3000\u0026lt;\u0026ndash;\u0026gt;1.2.3.4:6000的映射。\nserver1收到数据包后，往1.2.3.4:6000发送数据包，此时NAT允许该server1通过数据。\n但是client没有往server2发送数据，所以server2不能通过NAT设备1.2.3.4:6000发送数据包。\nPort Restricted Cone NAT(端口限制锥形NAT) 特点：IP和port都受限. 场景： client 发送数据包给server1, 通过NAT设备完成192.168.0.1:3000\u0026lt;\u0026ndash;\u0026gt;1.2.3.4:6000的映射。\nserver1收到数据包后，往1.2.3.4:6000发送数据包，此时NAT允许该server1通过数据。\n但是server1的其他端口(除了4000)，都不允许通过NAT设备发送数据包，server2更不允许。\nSymmetric NAT(对称NAT) 特点:对每个外部主机或端口的会话都会映射为不同的端口 client 发送数据包给server1, 通过NAT设备完成192.168.0.1:3000\u0026lt;\u0026ndash;\u0026gt;1.2.3.4:6000的映射。\nserver1的4000收到数据包后，往1.2.3.4:6000发送数据包，此时NAT允许该server1通过数据。\nclient 发送数据包给server1, 通过NAT设备完成192.168.0.1:3000\u0026lt;\u0026ndash;\u0026gt;1.2.3.4:6001的映射。\nserver1端4001收到数据包后，往1.2.3.4:6001发送数据包，此时NAT允许该server1通过数据\nserver端只有client发送过数据的数据包，NAT才允许通过，并且NAT的端口映射会不一样。\nNAT_TRAVERSAL 和 NATHELPER 介绍 这两个模块都是针对Client的NAT而设计的，一方面是让client知道自己的外网ip和port, 另一方面记录此NAT的ip和port，用于回复信令。\n需要注意的是这两个模块无法让client知道opensips服务端信令和媒体的外网ip和port\nNATHELPER的使用场景比NAT_TRAVERSAL要简单，但是功能更多。\n功能 NATHELPER NAT_TRAVERSAL 支持设置ping间隔 √ √ 支持设置ping方法 √ √ 支持修改ping发出去的端口 √ x 支持tcp方式的ping √ x 修改Register的Contact fix_nated_register fix_contact 修改Invite的Contact fix_nated_contact fix_contact 修改sdp的o=ip fix_nated_sdp x 开始执行ping方法 sipping_bflag / ping_nated_only nat_keepalive 为啥需要ping? 当client通过NAT发送请求到opensips,为了保持连接，需要往NAT链路上发送ping包， 可以是OPTIONS也可以是INFO，能够保证NAT链路一直处于活动状态。\n模块使用示例 opensips版本\nopensips 3.3.10 (x86_64/linux)\nNAT_TRAVERSAL 完整配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 ###### Global Parameters ######### xlog_level=4 #debug_mode=yes log_stderror=yes #stderror_enabled=yes #syslog_facility=LOG_LOCAL0 log_facility=LOG_LOCAL0 advertised_address=116.198.229.200 socket=udp:172.16.0.3:5271 socket=udp:172.16.0.3:5272 ####### Modules Section ######## # set module path mpath=\u0026#34;/usr/local/lib64/sbc/modules/\u0026#34; #### SIGNALING module loadmodule \u0026#34;signaling.so\u0026#34; loadmodule \u0026#34;db_mysql.so\u0026#34; #### StateLess module loadmodule \u0026#34;sl.so\u0026#34; #### Transaction Module loadmodule \u0026#34;tm.so\u0026#34; modparam(\u0026#34;tm\u0026#34;, \u0026#34;fr_timeout\u0026#34;, 5) modparam(\u0026#34;tm\u0026#34;, \u0026#34;fr_inv_timeout\u0026#34;, 30) modparam(\u0026#34;tm\u0026#34;, \u0026#34;restart_fr_on_each_reply\u0026#34;, 0) modparam(\u0026#34;tm\u0026#34;, \u0026#34;onreply_avp_mode\u0026#34;, 1) #### Record Route Module loadmodule \u0026#34;rr.so\u0026#34; modparam(\u0026#34;rr\u0026#34;, \u0026#34;append_fromtag\u0026#34;, 0) #### MAX ForWarD module loadmodule \u0026#34;maxfwd.so\u0026#34; #### SIP MSG OPerationS module loadmodule \u0026#34;sipmsgops.so\u0026#34; #### FIFO Management Interface loadmodule \u0026#34;mi_fifo.so\u0026#34; modparam(\u0026#34;mi_fifo\u0026#34;, \u0026#34;fifo_name\u0026#34;, \u0026#34;/tmp/opensips_fifo\u0026#34;) modparam(\u0026#34;mi_fifo\u0026#34;, \u0026#34;fifo_mode\u0026#34;, 0666) loadmodule \u0026#34;httpd.so\u0026#34; loadmodule \u0026#34;mi_http.so\u0026#34; modparam(\u0026#34;httpd\u0026#34;,\u0026#34;port\u0026#34;,9998) #### USeR LOCation module loadmodule \u0026#34;usrloc.so\u0026#34; modparam(\u0026#34;usrloc\u0026#34;, \u0026#34;nat_bflag\u0026#34;, \u0026#34;NAT\u0026#34;) #### REGISTRAR module loadmodule \u0026#34;registrar.so\u0026#34; #### RTPengine protocol loadmodule \u0026#34;rtpengine.so\u0026#34; modparam(\u0026#34;rtpengine\u0026#34;, \u0026#34;rtpengine_sock\u0026#34;, \u0026#34;udp:172.16.0.3:22222\u0026#34;) #### Nathelper protocol #loadmodule \u0026#34;nathelper.so\u0026#34; #modparam(\u0026#34;registrar|nathelper\u0026#34;, \u0026#34;received_avp\u0026#34;, \u0026#34;$avp(rcv)\u0026#34;) #### UDP protocol loadmodule \u0026#34;proto_udp.so\u0026#34; loadmodule \u0026#34;nat_traversal.so\u0026#34; loadmodule \u0026#34;dialog.so\u0026#34; modparam(\u0026#34;nat_traversal\u0026#34;, \u0026#34;keepalive_interval\u0026#34;, 10) modparam(\u0026#34;nat_traversal\u0026#34;, \u0026#34;keepalive_method\u0026#34;, \u0026#34;OPTIONS\u0026#34;) modparam(\u0026#34;nat_traversal\u0026#34;, \u0026#34;keepalive_from\u0026#34;, \u0026#34;sip:keepalive@my-domain.com\u0026#34;) ####### Routing Logic ######## # main request routing logic route{ if (!mf_process_maxfwd_header(10)) { sl_send_reply(483,\u0026#34;Too Many Hops\u0026#34;); exit; } if (has_totag()) { # sequential requests within a dialog should # take the path determined by record-routing if (loose_route()) { if (is_method(\u0026#34;INVITE\u0026#34;)) { # even if in most of the cases is useless, do RR for # re-INVITEs alos, as some buggy clients do change route set # during the dialog. record_route(); } # route it out to whatever destination was set by loose_route() # in $du (destination URI). route(relay); } else { if ( is_method(\u0026#34;ACK\u0026#34;) ) { if ( t_check_trans() ) { # non loose-route, but stateful ACK; must be an ACK after # a 487 or e.g. 404 from upstream server t_relay(); exit; } else { # ACK without matching transaction -\u0026gt; # ignore and discard exit; } } sl_send_reply(404,\u0026#34;Not here\u0026#34;); } exit; } # CANCEL processing if (is_method(\u0026#34;CANCEL\u0026#34;)) { if (t_check_trans()) t_relay(); exit; } t_check_trans(); #if (!is_method(\u0026#34;REGISTER\u0026#34;)) { #\tif (is_myself(\u0026#34;$fd\u0026#34;)) { #\t# if caller is not local, then called number must be local #\tif (!is_myself(\u0026#34;$rd\u0026#34;)) { #\tsend_reply(403,\u0026#34;Rely forbidden\u0026#34;); #\texit; #\t} #\t} #} # preloaded route checking if (loose_route()) { xlog(\u0026#34;L_ERR\u0026#34;, \u0026#34;Attempt to route with preloaded Route\u0026#39;s [$fu/$tu/$ru/$ci]\u0026#34;); if (!is_method(\u0026#34;ACK\u0026#34;)) sl_send_reply(403,\u0026#34;Preload Route denied\u0026#34;); exit; } # record routing if (!is_method(\u0026#34;REGISTER|MESSAGE\u0026#34;)) record_route(); if (!is_myself(\u0026#34;$rd\u0026#34;)) { append_hf(\u0026#34;P-hint: outbound\\r\\n\u0026#34;); route(relay); } # requests for my domain if (is_method(\u0026#34;PUBLISH|SUBSCRIBE\u0026#34;)) { sl_send_reply(503, \u0026#34;Service Unavailable\u0026#34;); exit; } # check if the clients are using WebSockets or WebSocketSecure if ( $socket_in(proto) == \u0026#34;WS\u0026#34;|| $socket_in(proto) == \u0026#34;WSS\u0026#34;) setflag(\u0026#34;SRC_WS\u0026#34;); # consider the client is behind NAT - always fix the contact #fix_nated_contact(); xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---main-1-:$rm|$rs|$tu|$socket_in(port)|$var(contact)\\n\u0026#34;); if (is_method(\u0026#34;REGISTER\u0026#34;)) { # indicate that the client supports DTLS # so we know when he is called if (isflagset(\u0026#34;SRC_WS\u0026#34;)) setbflag(\u0026#34;DST_WS\u0026#34;); #fix_nated_register(); if (!save(\u0026#34;location\u0026#34;)) sl_reply_error(); exit; } xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---main--:$rm|$rs|$tu|$socket_in(port)|$var(contact)\\n\u0026#34;); if ($rU==NULL) { # request with no Username in RURI sl_send_reply(484,\u0026#34;Address Incomplete\u0026#34;); exit; } # do lookup with method filtering if (!lookup(\u0026#34;location\u0026#34;,\u0026#34;m\u0026#34;)) { t_newtran(); t_reply(404, \u0026#34;Not Found\u0026#34;); exit; } route(relay); } route[relay] { # for INVITEs enable some additional helper routes if (is_method(\u0026#34;INVITE\u0026#34;)) { t_on_branch(\u0026#34;handle_nat\u0026#34;); t_on_reply(\u0026#34;handle_nat\u0026#34;); } else if (is_method(\u0026#34;BYE|CANCEL\u0026#34;)) { rtpengine_delete(); } if (!t_relay()) { send_reply(500,\u0026#34;Internal Error\u0026#34;); }; exit; } branch_route[handle_nat] { if (!is_method(\u0026#34;INVITE\u0026#34;) || !has_body(\u0026#34;application/sdp\u0026#34;)) return; $var(rtp_flag) = \u0026#34;replace-origin \u0026#34;; if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) { #web-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; ICE=force-relay DTLS=passive\u0026#34;; } else if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)){ #web-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; codec-strip-G722 codec-strip-CN codec-strip-red strip-extmap rtcp-mux-demux DTLS=off SDES-off ICE=remove RTP/AVP\u0026#34;; } else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) {#sip-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; rtcp-mux-offer generate-mid DTLS=passive SDES-off ICE=force RTP/SAVPF\u0026#34;; } else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)) #sip-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; DTLS=off SDES-off ICE=remove RTP/AVP\u0026#34;; rtpengine_offer(\u0026#34;$var(rtp_flag)\u0026#34;); } onreply_route[handle_nat] { #fix_nated_contact(); if (!has_body(\u0026#34;application/sdp\u0026#34;)) return; $var(rtp_flag) = \u0026#34;replace-origin \u0026#34;; if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) #web-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; ICE=force-relay DTLS=passive\u0026#34;; else if (isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)) #web-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; codec-strip-G722 codec-strip-CN codec-strip-red codec-strip-opus rtcp-mux-offer generate-mid DTLS=passive SDES-off ICE=force\u0026#34;; else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; isbflagset(\u0026#34;DST_WS\u0026#34;)) #sip-\u0026gt;web $var(rtp_flag) = $var(rtp_flag) + \u0026#34; rtcp-mux-offer generate-mid DTLS=passive SDES-off ICE=remove RTP/AVP\u0026#34;; else if (!isflagset(\u0026#34;SRC_WS\u0026#34;) \u0026amp;\u0026amp; !isbflagset(\u0026#34;DST_WS\u0026#34;)) #sip-\u0026gt;sip $var(rtp_flag) = $var(rtp_flag) + \u0026#34; DTLS=off SDES-off ICE=remove RTP/AVP\u0026#34;; rtpengine_answer(\u0026#34;$var(rtp_flag)\u0026#34;); } 以上的配置并没有开启NAT的ping和fix_contact,它的效果就是：\n使用MicroSIP软电话通过udp:116.198.229.200:5271注册用户1001, 通过opensips-cli客户端执行mi ul_dump, 能够看到注册信息为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { \u0026#34;Domains\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;location\u0026#34;, \u0026#34;hash_size\u0026#34;: 512, \u0026#34;AORs\u0026#34;: [ { \u0026#34;AOR\u0026#34;: \u0026#34;1007\u0026#34;, \u0026#34;Contacts\u0026#34;: [ { \u0026#34;Contact\u0026#34;: \u0026#34;sip:1007@172.16.80.21:58364;ob\u0026#34;, \u0026#34;ContactID\u0026#34;: \u0026#34;3784571799363132468\u0026#34;, \u0026#34;Expires\u0026#34;: 299, \u0026#34;Q\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Callid\u0026#34;: \u0026#34;f3c3991a65404450959d7f899fae1d80\u0026#34;, \u0026#34;Cseq\u0026#34;: 30781, \u0026#34;User-agent\u0026#34;: \u0026#34;MicroSIP/3.21.6\u0026#34;, \u0026#34;State\u0026#34;: \u0026#34;CS_NEW\u0026#34;, \u0026#34;Flags\u0026#34;: 0, \u0026#34;Cflags\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Socket\u0026#34;: \u0026#34;udp:172.16.0.3:5271\u0026#34;, \u0026#34;Methods\u0026#34;: 8063 } ] } ] } ] } 注册的sip为： 可以看到client的NAT是113.104.238.248:2717, 但是opensips保存的contact为sip:1007@172.16.80.21:58364;ob, 这个是软电话的内网ip, 两个不同内网的软电话通过opensips相互拨打，会不通。\nfix_contact() 那么如何修改呢？在save之前，收到Register信令就调用fix_contact(), 具体为：\n1 2 3 4 5 6 7 8 9 10 11 if (is_method(\u0026#34;REGISTER\u0026#34;)) { # indicate that the client supports DTLS # so we know when he is called if (isflagset(\u0026#34;SRC_WS\u0026#34;)) setbflag(\u0026#34;DST_WS\u0026#34;); fix_contact(); #fix_nated_register(); if (!save(\u0026#34;location\u0026#34;)) sl_reply_error(); exit; } 此时，opensips-cli执行mi ul_dump, opensips保存的location为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { \u0026#34;Domains\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;location\u0026#34;, \u0026#34;hash_size\u0026#34;: 512, \u0026#34;AORs\u0026#34;: [ { \u0026#34;AOR\u0026#34;: \u0026#34;1007\u0026#34;, \u0026#34;Contacts\u0026#34;: [ { \u0026#34;Contact\u0026#34;: \u0026#34;sip:1007@113.104.238.248:2717;ob\u0026#34;, \u0026#34;ContactID\u0026#34;: \u0026#34;3784571799363126326\u0026#34;, \u0026#34;Expires\u0026#34;: 297, \u0026#34;Q\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Callid\u0026#34;: \u0026#34;62ec515e2ece4564b3388035343fee32\u0026#34;, \u0026#34;Cseq\u0026#34;: 16774, \u0026#34;User-agent\u0026#34;: \u0026#34;MicroSIP/3.21.6\u0026#34;, \u0026#34;State\u0026#34;: \u0026#34;CS_NEW\u0026#34;, \u0026#34;Flags\u0026#34;: 0, \u0026#34;Cflags\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Socket\u0026#34;: \u0026#34;udp:172.16.0.3:5271\u0026#34;, \u0026#34;Methods\u0026#34;: 8063 } ] } ] } ] } 能够看到Contact信息改为了NAT的IP地址和port\nnat_keepalive 在fix_contact位置添加nat_keepalive();，配置如下:\n1 2 3 4 5 6 7 8 9 10 11 12 if (is_method(\u0026#34;REGISTER\u0026#34;)) { # indicate that the client supports DTLS # so we know when he is called if (isflagset(\u0026#34;SRC_WS\u0026#34;)) setbflag(\u0026#34;DST_WS\u0026#34;); fix_contact(); nat_keepalive(); #fix_nated_register(); if (!save(\u0026#34;location\u0026#34;)) sl_reply_error(); exit; } 重启服务后，能够看到每10s会往client的NAT 发送OPTIONS信令。 本地发出端口用的是.cfg里第一个默认的socket=协议，这块不能更改. 软电话坐席退出，ping还会执行的次数为：4min/keepalive_interval。 这个4分钟 目前没找到哪里配置，是实际测试的结果。\nNATHELPER 配置：\n1 2 3 4 5 6 7 8 9 10 loadmodule \u0026#34;nathelper.so\u0026#34; modparam(\u0026#34;registrar|nathelper\u0026#34;, \u0026#34;received_avp\u0026#34;, \u0026#34;$avp(rcv)\u0026#34;) modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;natping_interval\u0026#34;, 10) modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;ping_threshold\u0026#34;, 10) modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;max_pings_lost\u0026#34;, 5) modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;natping_partitions\u0026#34;, 4) modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;natping_socket\u0026#34;, \u0026#34;172.16.0.3:5272\u0026#34;) #修改发送ping的本地端口 modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;sipping_bflag\u0026#34;, \u0026#34;SIPPING_ENABLE\u0026#34;) modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;sipping_from\u0026#34;, \u0026#34;sip:pinger@siphub.net\u0026#34;) modparam(\u0026#34;nathelper\u0026#34;, \u0026#34;sipping_method\u0026#34;, \u0026#34;OPTIONS\u0026#34;) fix_nated_register() 以Register信令为例, 想要修改Register的Contact信息，在save之前,调用fix_nated_register(), 具体为：\n1 2 3 4 5 6 7 8 9 10 if (is_method(\u0026#34;REGISTER\u0026#34;)) { # indicate that the client supports DTLS # so we know when he is called if (isflagset(\u0026#34;SRC_WS\u0026#34;)) setbflag(\u0026#34;DST_WS\u0026#34;);\tfix_nated_register(); if (!save(\u0026#34;location\u0026#34;)) sl_reply_error();\texit; } 具体效果为：\n保存的用户信息中新增了Received字段存储NAT信息,使用opensips-cli 里的mi ul_dump查看： contact信息并未变化 在给客户端返回200OK的Contact字段中增加received字段， fix_nated_contact() 此时opensips保存的Register里的Contact会被修改成NAT的ip和port. 如何开启ping? nathelper有两种方式：\nping_nated_only 这个参数是：Contact里带有behind_NAT标志，才会ping. 2. sipping_bflag\n以本配置为例,设置的标志为：SIPPING_ENABLE, 那么在Register信令处, 要设置SIPPING_ENABLE标志。\n1 2 3 4 5 6 7 8 9 10 11 12 if (is_method(\u0026#34;REGISTER\u0026#34;)) { # indicate that the client supports DTLS # so we know when he is called if (isflagset(\u0026#34;SRC_WS\u0026#34;)) setbflag(\u0026#34;DST_WS\u0026#34;);\tsetbflag(\u0026#34;SIPPING_ENABLE\u0026#34;); fix_nated_register(); fix_nated_contact(); if (!save(\u0026#34;location\u0026#34;)) sl_reply_error();\texit; } 效果为：\n如果坐席注销，nathelper立即就停止ping,比nat_traversal效果要好。\nfix_nated_sdp() 参数 0x01 - adds “a=direction:active” SDP line; 0x02 - 重写sdp中的c=ip地址为NAT的ip地址; 0x04 - adds “a=nortpproxy:yes” SDP line; 0x08 - 重写sdp中的o=ip地址为NAT的ip地址; 0x10 - 重写所有的媒体ip 在需要修改sdp的Route里，执行此函数即可，sdp参数例子为：\n","date":"2025-02-19T09:24:03+08:00","image":"https://QuincyGao.github.io/p/nat_traversal%E5%92%8Cnathelper%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/7_hu9058017268728565075.jpg","permalink":"https://QuincyGao.github.io/p/nat_traversal%E5%92%8Cnathelper%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","title":"NAT_TRAVERSAL和NATHELPER模块介绍"},{"content":"SDP协议 SDP协议版本 sdp协议最新链接：rfc8866\n历史版本：rfc4566 rfc2327\n特性 RFC 2327 (1998) RFC 4566 (2006) RFC 8866 (2021) IP 支持 仅 IPv4 IPv4 + IPv6 IPv4 + IPv6 安全机制 无 基础（如 k=） 完善(DTLS-SRTP 等) ICE 支持 无 初步属性支持 完整规范 扩展性 有限 新增属性字段 明确的扩展规则 应用场景 传统 VoIP WebRTC 早期 现代 WebRTC/5G 本次以rfc8866为例学习\nsdp 参数解析 session Description 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 v= (protocol version) o= (originator and session identifier) s= (session name) i=* (session information) u=* (URI of description) e=* (email address) p=* (phone number) c=* (connection information -- not required if included in all media descriptions) b=* (zero or more bandwidth information lines) One or more time descriptions: (\u0026#34;t=\u0026#34;, \u0026#34;r=\u0026#34; and \u0026#34;z=\u0026#34; lines; see below) k=* (obsolete) a=* (zero or more session attribute lines) Zero or more media descriptions v=0 版本默认是0\no=\u0026lt;username\u0026gt; \u0026lt;sess-id\u0026gt; \u0026lt;sess-version\u0026gt; \u0026lt;nettype\u0026gt; \u0026lt;addrtype\u0026gt; \u0026lt;unicast-address\u0026gt;\nusername: 用户登录的原始host,默认\u0026rsquo;-'\nsess-id: 会话id，具备唯一性\nsess-version: 会话版本，可和sess-id一致\nnettype: 网络类型，默认为IN\naddrtype: 地址类型，默认为IP4 or IP6\nunicast-address: ip地址\ns=\u0026lt;session name\u0026gt; 必须填写,没有则为\u0026rsquo;s=\u0026rsquo; or \u0026rsquo;s=-' i=\u0026lt;session information\u0026gt; 描述会话信息,可选 u=\u0026lt;uri\u0026gt; 描述会话uri, 可选 e=\u0026lt;email-address\u0026gt; p=\u0026lt;phone number\u0026gt;, 可选 c=\u0026lt;nettype\u0026gt; \u0026lt;addrtype\u0026gt; \u0026lt;connection-address\u0026gt; 连接信息，为\u0026rsquo;IN IP4 xxxx\u0026rsquo;, c可以有多个 b=\u0026lt;bwtype\u0026gt;:\u0026lt;bandwidth\u0026gt; 带宽信息，可选 k=\u0026lt;keytype\u0026gt; \u0026lt;key\u0026gt; 加密信息，可选 Time Description 1 2 3 t= (time the session is active) r=* (zero or more repeat times) z=* (optional time zone offset line) t=\u0026lt;start-time\u0026gt; \u0026lt;stop-time\u0026gt; 会话开始和结束时间戳，可多个，开始和结束时间都为0，会话视为永久 r=\u0026lt;repeat interval\u0026gt; \u0026lt;active duration\u0026gt; \u0026lt;offsets from start-time\u0026gt; 重复时间间隔和持续时间，可选 z=\u0026lt;adjustment time\u0026gt; \u0026lt;offset\u0026gt; \u0026lt;adjustment time\u0026gt; \u0026lt;offset\u0026gt; ... 时区偏移，可选 Media Description 1 2 3 4 5 6 7 m= (media name and transport address) i=* (media title) c=* (connection information -- optional if included at session level) b=* (zero or more bandwidth information lines) k=* (obsolete) a=* (zero or more media attribute lines) m=\u0026lt;media\u0026gt; \u0026lt;port\u0026gt;/\u0026lt;numers of ports\u0026gt; \u0026lt;proto\u0026gt; \u0026lt;fmt\u0026gt; ... 媒体描述，必选. media: audio、video、text、application、message port: 端口号，0-65535，0表示不指定端口, numbers of ports: rtp 会话数选择 proto: 传输协议，udp,RTP/AVP,RTP/SAVP,RTP/SAVPF fmt: 媒体格式，如 0、8、9、97、98、99、101、102、103、104、105等 k=\u0026lt;method\u0026gt; k=\u0026lt;method\u0026gt;:\u0026lt;encryption key\u0026gt; 已过时，不要用 a=\u0026lt;aattribute-name\u0026gt; a=\u0026lt;attribute-name\u0026gt;:\u0026lt;aattribute-value\u0026gt; 扩展sdp信息，可多个 rtpmap: 媒体格式的描述, 要和m=里fmt格式一致 详细示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 v=0 o=jdoe 3724394400 3724394405 IN IP4 198.51.100.1 s=Call to John Smith i=SDP Offer #1 u=http://www.jdoe.example.com/home.html e=Jane Doe \u0026lt;jane@jdoe.example.com\u0026gt; p=+1 617 555-6011 c=IN IP4 198.51.100.1 t=0 0 m=audio 49170 RTP/AVP 0 m=audio 49180 RTP/AVP 0 m=video 51372 RTP/AVP 99 c=IN IP6 2001:db8::2 a=rtpmap:99 h263-1998/90000 RTP协议 RTP协议连接 协议地址：rfc3550\n老协议:rfc1889\nRTP协议结构 1 2 3 4 5 6 7 8 9 10 11 12 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |V=2|P|X| CC |M| PT | sequence number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | timestamp | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | synchronization source (SSRC) identifier | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ | contributing source (CSRC) identifiers | | .... | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ sequence number: 初始值随机不可预测生成，用于标识一个RTP包，每次发送+1 timestamp: 初始值随机时间戳，每次新增采样时钟，比如audio为160 SSRC: 初始值随机，多个源时会有概率冲突，如果一个源修改源地址，那么要使用新SSRC. CSRC: 标识有效负载的贡献源 SSRC 生成算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;sys/types.h\u0026gt; /* u_long */ #include \u0026lt;sys/time.h\u0026gt; /* gettimeofday() */ #include \u0026lt;unistd.h\u0026gt; /* get..() */ #include \u0026lt;stdio.h\u0026gt; /* printf() */ #include \u0026lt;time.h\u0026gt; /* clock() */ #include \u0026lt;sys/utsname.h\u0026gt; /* uname() */ #include \u0026#34;global.h\u0026#34; /* from RFC 1321 */ #include \u0026#34;md5.h\u0026#34; /* from RFC 1321 */ #define MD_CTX MD5_CTX #define MDInit MD5Init #define MDUpdate MD5Update #define MDFinal MD5Final static u_long md_32(char *string, int length) { MD_CTX context; union { char c[16]; u_long x[4]; } digest; u_long r; int i; MDInit (\u0026amp;context); MDUpdate (\u0026amp;context, string, length); MDFinal ((unsigned char *)\u0026amp;digest, \u0026amp;context); r = 0; for (i = 0; i \u0026lt; 3; i++) { r ^= digest.x[i]; } return r; } /* md_32 */ /* * Return random unsigned 32-bit quantity. Use \u0026#39;type\u0026#39; argument if * you need to generate several different values in close succession. */ u_int32 random32(int type) { struct { int type; struct timeval tv; clock_t cpu; pid_t pid; u_long hid; uid_t uid; gid_t gid; struct utsname name; } s; gettimeofday(\u0026amp;s.tv, 0); uname(\u0026amp;s.name); s.type = type; s.cpu = clock(); s.pid = getpid(); s.hid = gethostid(); s.uid = getuid(); s.gid = getgid(); /* also: system uptime */ return md_32((char *)\u0026amp;s, sizeof(s)); } /* random32 */ 在实际使用媒体服务中，有部分服务使用了SSRC来区分数据， 业务表现就是媒体服务只用一个端口来接收RTP数据(比如:jitsi-videobridge)。 好处： 当对接时，可以不需要开通太多端口区间。不足： 并发性能不高。 其余大部分的媒体服务都是使用多个端口来接收RTP数据(比如: rtpengine, rtpproxy, freeswitch)。\n","date":"2025-02-18T09:03:07+08:00","image":"https://QuincyGao.github.io/p/sdp%E5%92%8Crtp%E5%8D%8F%E8%AE%AE/6_hu2046866609988021794.jpg","permalink":"https://QuincyGao.github.io/p/sdp%E5%92%8Crtp%E5%8D%8F%E8%AE%AE/","title":"SDP和RTP协议"},{"content":"sip协议Call Flow Examples sip示例原文:rfc3665\nREGISTER 基础注册流程 sequenceDiagram Bob-\u0026gt;\u0026gt;SIP server: REGISTER SIP server--\u0026gt;\u0026gt;Bob: 401 Unauthorized Note over SIP server: 401 Unauthorized 返回 WWW-Authenticate Bob-\u0026gt;\u0026gt;SIP server: REGISTER Note over Bob: REGISTER 带Authorization SIP server--\u0026gt;\u0026gt;Bob: 200 OK Note over SIP server: 200 OK 返回注册的Contact 查询注册状态 sequenceDiagram Bob-\u0026gt;\u0026gt;SIP server: REGISTER Note over Bob: REGISTER 不带Contact SIP server--\u0026gt;\u0026gt;Bob: 200 OK Note over SIP server: 200 OK 返回注册的Contact 取消注册 sequenceDiagram Bob-\u0026gt;\u0026gt;SIP server: REGISTER Note over Bob: REGISTER 带Expires:0 SIP server--\u0026gt;\u0026gt;Bob: 200 OK Note over SIP server: 200 OK 不带Contact INVITE 基础流程 sequenceDiagram Alice-\u0026gt;\u0026gt;Bob: INVITE Bob--\u0026gt;\u0026gt;Alice: 100 Trying Bob-\u0026gt;\u0026gt;Alice: 180 Ringing Bob-\u0026gt;\u0026gt;Alice: 200 OK Alice-\u0026gt;\u0026gt;Bob: ACK Bob\u0026lt;\u0026lt;-\u0026gt;\u0026gt;Alice: RTP meida Bob-\u0026gt;\u0026gt;Alice: BYE Alice-\u0026gt;\u0026gt;Bob: 200 OK 经过两个代理 注意： 因为时序图不能解析; 所以使用 | 代替;方便显示\nAlice 能请求到proxy1是因为INVITE的Route指向的是proxy1, Requset-URI指向的是proxy2.\nbob 返回180,200 ok 是通过Via 定位路由，bob 发送BYE 是通过 Route 定位路由.\nalice 发送ACK 是通过Route定位路由.\nsequenceDiagram actor Alice as Alice\u0026lt;br/\u0026gt;client.atlanta.example.com participant Proxy1 as Proxy1\u0026lt;br/\u0026gt;ss1.atlanta.example.com participant Proxy2 as Proxy2\u0026lt;br/\u0026gt;ss2.biloxi.example.com actor Bob as Bob \u0026lt;br/\u0026gt;client.biloxi.example.com Alice-\u0026gt;\u0026gt;Proxy1: INVITE Proxy1-\u0026gt;\u0026gt;Alice: SIP/2.0 407 Proxy Authorization Required Alice-\u0026gt;\u0026gt;Proxy1: ACK Alice-\u0026gt;\u0026gt;Proxy1: INVITE Proxy1--\u0026gt;\u0026gt;Alice: 100 Trying Proxy1-\u0026gt;\u0026gt;Proxy2: INVITE Proxy2--\u0026gt;\u0026gt;Proxy1: 100 Trying Proxy2-\u0026gt;\u0026gt;Bob: INVITE Bob--\u0026gt;\u0026gt;Proxy2: 100 Trying Bob-\u0026gt;\u0026gt;Proxy2: 180 Ringing Proxy2-\u0026gt;\u0026gt;Proxy1: 180 Ringing Proxy1-\u0026gt;\u0026gt;Alice: 180 Ringing Bob-\u0026gt;\u0026gt;Proxy2: 200 OK Proxy2-\u0026gt;\u0026gt;Proxy1: 200 OK Proxy1-\u0026gt;\u0026gt;Alice: 200 OK Alice-\u0026gt;\u0026gt;Proxy1: ACK Proxy1-\u0026gt;\u0026gt;Proxy2: ACK Proxy2-\u0026gt;\u0026gt;Bob: ACK Bob\u0026lt;\u0026lt;-\u0026gt;\u0026gt;Alice: RTP meida Bob-\u0026gt;\u0026gt;Proxy2: BYE Proxy2-\u0026gt;\u0026gt;Proxy1: BYE Proxy1-\u0026gt;\u0026gt;Alice: BYE Alice-\u0026gt;\u0026gt;Proxy1: 200 OK Proxy1-\u0026gt;\u0026gt;Proxy2: 200 OK Proxy2-\u0026gt;\u0026gt;Bob: 200 OK 详细的SIP信令\nAlice -\u0026gt; Proxy1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 INVITE sip:bob@biloxi.example.com SIP/2.0 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74b43 Max-Forwards: 70 Route: \u0026lt;sip:ss1.atlanta.example.com;lr\u0026gt; From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt; Call-ID: 3848276298220188511@atlanta.example.com CSeq: 1 INVITE Contact: \u0026lt;sip:alice@client.atlanta.example.com;transport=tcp\u0026gt; Content-Type: application/sdp Content-Length: 151 v=0 o=alice 2890844526 2890844526 IN IP4 client.atlanta.example.com s=- c=IN IP4 192.0.2.101 t=0 0 m=audio 49172 RTP/AVP 0 a=rtpmap:0 PCMU/8000 407 Proxy Authorization Required Proxy 1 -\u0026gt; Alice 1 2 3 4 5 6 7 8 9 10 11 SIP/2.0 407 Proxy Authorization Required Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74b43 ;received=192.0.2.101 From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=3flal12sf Call-ID: 3848276298220188511@atlanta.example.com CSeq: 1 INVITE Proxy-Authenticate: Digest realm=\u0026#34;atlanta.example.com\u0026#34;, qop=\u0026#34;auth\u0026#34;, nonce=\u0026#34;f84f1cec41e6cbe5aea9c8e88d359\u0026#34;, opaque=\u0026#34;\u0026#34;, stale=FALSE, algorithm=MD5 Content-Length: 0 ACK Alice -\u0026gt; Proxy1 1 2 3 4 5 6 7 8 ACK sip:bob@biloxi.example.com SIP/2.0 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74b43 Max-Forwards: 70 From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=3flal12sf Call-ID: 3848276298220188511@atlanta.example.com CSeq: 1 ACK Content-Length: 0 INVITE Alice -\u0026gt; Proxy1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 INVITE sip:bob@biloxi.example.com SIP/2.0 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 Max-Forwards: 70 Route: \u0026lt;sip:ss1.atlanta.example.com;lr\u0026gt; From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt; Call-ID: 3848276298220188511@atlanta.example.com CSeq: 2 INVITE Contact: \u0026lt;sip:alice@client.atlanta.example.com;transport=tcp\u0026gt; Proxy-Authorization: Digest username=\u0026#34;alice\u0026#34;, realm=\u0026#34;atlanta.example.com\u0026#34;, nonce=\u0026#34;wf84f1ceczx41ae6cbe5aea9c8e88d359\u0026#34;, opaque=\u0026#34;\u0026#34;, uri=\u0026#34;sip:bob@biloxi.example.com\u0026#34;, response=\u0026#34;42ce3cef44b22f50c6a6071bc8\u0026#34; Content-Type: application/sdp Content-Length: 151 v=0 o=alice 2890844526 2890844526 IN IP4 client.atlanta.example.com s=- c=IN IP4 192.0.2.101 t=0 0 m=audio 49172 RTP/AVP 0 a=rtpmap:0 PCMU/8000 100 Trying Proxy1 -\u0026gt; Alice 1 2 3 4 5 6 7 8 SIP/2.0 100 Trying Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt; Call-ID: 3848276298220188511@atlanta.example.com CSeq: 2 INVITE Content-Length: 0 INVITE Proxy1 -\u0026gt; Proxy2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 INVITE sip:bob@biloxi.example.com SIP/2.0 Via: SIP/2.0/TCP ss1.atlanta.example.com:5060;branch=z9hG4bK2d4790.1 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 Max-Forwards: 69 Record-Route: \u0026lt;sip:ss1.atlanta.example.com;lr\u0026gt; From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt; Call-ID: 3848276298220188511@atlanta.example.com CSeq: 2 INVITE Contact: \u0026lt;sip:alice@client.atlanta.example.com;transport=tcp\u0026gt; Content-Type: application/sdp Content-Length: 151 v=0 o=alice 2890844526 2890844526 IN IP4 client.atlanta.example.com s=- c=IN IP4 192.0.2.101 t=0 0 m=audio 49172 RTP/AVP 0 a=rtpmap:0 PCMU/8000 100 Trying Proxy2 -\u0026gt; Proxy1 1 2 3 4 5 6 7 8 9 10 SIP/2.0 100 Trying Via: SIP/2.0/TCP ss1.atlanta.example.com:5060;branch=z9hG4bK2d4790.1 ;received=192.0.2.111 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt; Call-ID: 3848276298220188511@atlanta.example.com CSeq: 2 INVITE Content-Length: 0 INVITE Proxy2 -\u0026gt; Bob 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 INVITE sip:bob@client.biloxi.example.com SIP/2.0 Via: SIP/2.0/TCP ss2.biloxi.example.com:5060;branch=z9hG4bK721e4.1 Via: SIP/2.0/TCP ss1.atlanta.example.com:5060;branch=z9hG4bK2d4790.1 ;received=192.0.2.111 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 Max-Forwards: 68 Record-Route: \u0026lt;sip:ss2.biloxi.example.com;lr\u0026gt;, \u0026lt;sip:ss1.atlanta.example.com;lr\u0026gt; From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt; Call-ID: 3848276298220188511@atlanta.example.com CSeq: 2 INVITE Contact: \u0026lt;sip:alice@client.atlanta.example.com;transport=tcp\u0026gt; Content-Type: application/sdp Content-Length: 151 v=0 o=alice 2890844526 2890844526 IN IP4 client.atlanta.example.com s=- c=IN IP4 192.0.2.101 t=0 0 m=audio 49172 RTP/AVP 0 a=rtpmap:0 PCMU/8000 180 Ringing Bob -\u0026gt; Proxy2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 SIP/2.0 180 Ringing Via: SIP/2.0/TCP ss2.biloxi.example.com:5060;branch=z9hG4bK721e4.1 ;received=192.0.2.222 Via: SIP/2.0/TCP ss1.atlanta.example.com:5060;branch=z9hG4bK2d4790.1 ;received=192.0.2.111 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 Record-Route: \u0026lt;sip:ss2.biloxi.example.com;lr\u0026gt;, \u0026lt;sip:ss1.atlanta.example.com;lr\u0026gt; From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 3848276298220188511@atlanta.example.com Contact: \u0026lt;sip:bob@client.biloxi.example.com;transport=tcp\u0026gt; CSeq: 2 INVITE Content-Length: 0 180 Ringing Proxy2 -\u0026gt; Proxy1 1 2 3 4 5 6 7 8 9 10 11 12 13 SIP/2.0 180 Ringing Via: SIP/2.0/TCP ss1.atlanta.example.com:5060;branch=z9hG4bK2d4790.1 ;received=192.0.2.111 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 Record-Route: \u0026lt;sip:ss2.biloxi.example.com;lr\u0026gt;, \u0026lt;sip:ss1.atlanta.example.com;lr\u0026gt; From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 3848276298220188511@atlanta.example.com Contact: \u0026lt;sip:bob@client.biloxi.example.com;transport=tcp\u0026gt; CSeq: 2 INVITE Content-Length: 0 180 Ringing Proxy1 -\u0026gt; Alice 1 2 3 4 5 6 7 8 9 10 11 SIP/2.0 180 Ringing Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 Record-Route: \u0026lt;sip:ss2.biloxi.example.com;lr\u0026gt;, \u0026lt;sip:ss1.atlanta.example.com;lr\u0026gt; From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 3848276298220188511@atlanta.example.com Contact: \u0026lt;sip:bob@client.biloxi.example.com;transport=tcp\u0026gt; CSeq: 2 INVITE Content-Length: 0 200 OK Bob -\u0026gt; Proxy2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 SIP/2.0 200 OK Via: SIP/2.0/TCP ss2.biloxi.example.com:5060;branch=z9hG4bK721e4.1 ;received=192.0.2.222 Via: SIP/2.0/TCP ss1.atlanta.example.com:5060;branch=z9hG4bK2d4790.1 ;received=192.0.2.111 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 Record-Route: \u0026lt;sip:ss2.biloxi.example.com;lr\u0026gt;, \u0026lt;sip:ss1.atlanta.example.com;lr\u0026gt; From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 3848276298220188511@atlanta.example.com CSeq: 2 INVITE Contact: \u0026lt;sip:bob@client.biloxi.example.com;transport=tcp\u0026gt; Content-Type: application/sdp Content-Length: 147 v=0 o=bob 2890844527 2890844527 IN IP4 client.biloxi.example.com s=- c=IN IP4 192.0.2.201 t=0 0 m=audio 3456 RTP/AVP 0 a=rtpmap:0 PCMU/8000 200 OK Proxy2 -\u0026gt; Proxy1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 SIP/2.0 200 OK Via: SIP/2.0/TCP ss1.atlanta.example.com:5060;branch=z9hG4bK2d4790.1 ;received=192.0.2.111 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 Record-Route: \u0026lt;sip:ss2.biloxi.example.com;lr\u0026gt;, \u0026lt;sip:ss1.atlanta.example.com;lr\u0026gt; From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 3848276298220188511@atlanta.example.com CSeq: 2 INVITE Contact: \u0026lt;sip:bob@client.biloxi.example.com;transport=tcp\u0026gt; Content-Type: application/sdp Content-Length: 147 v=0 o=bob 2890844527 2890844527 IN IP4 client.biloxi.example.com s=- c=IN IP4 192.0.2.201 t=0 0 m=audio 3456 RTP/AVP 0 a=rtpmap:0 PCMU/8000 200 OK Proxy1 -\u0026gt; Alice 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 SIP/2.0 200 OK Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 Record-Route: \u0026lt;sip:ss2.biloxi.example.com;lr\u0026gt;, \u0026lt;sip:ss1.atlanta.example.com;lr\u0026gt; From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 3848276298220188511@atlanta.example.com CSeq: 2 INVITE Contact: \u0026lt;sip:bob@client.biloxi.example.com;transport=tcp\u0026gt; Content-Type: application/sdp Content-Length: 147 v=0 o=bob 2890844527 2890844527 IN IP4 client.biloxi.example.com s=- c=IN IP4 192.0.2.201 t=0 0 m=audio 3456 RTP/AVP 0 a=rtpmap:0 PCMU/8000 ACK Alice -\u0026gt; Proxy1 1 2 3 4 5 6 7 8 9 10 ACK sip:bob@client.biloxi.example.com SIP/2.0 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74b76 Max-Forwards: 70 Route: \u0026lt;sip:ss1.atlanta.example.com;lr\u0026gt;, \u0026lt;sip:ss2.biloxi.example.com;lr\u0026gt; From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 3848276298220188511@atlanta.example.com CSeq: 2 ACK Content-Length: 0 ACK Proxy1 -\u0026gt; Proxy2 1 2 3 4 5 6 7 8 9 10 11 ACK sip:bob@client.biloxi.example.com SIP/2.0 Via: SIP/2.0/TCP ss1.atlanta.example.com:5060;branch=z9hG4bK2d4790.1 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74b76 ;received=192.0.2.101 Max-Forwards: 69 Route: \u0026lt;sip:ss2.biloxi.example.com;lr\u0026gt; From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 3848276298220188511@atlanta.example.com CSeq: 2 ACK Content-Length: 0 ACK Proxy2 -\u0026gt; Bob 1 2 3 4 5 6 7 8 9 10 11 12 ACK sip:bob@client.biloxi.example.com SIP/2.0 Via: SIP/2.0/TCP ss2.biloxi.example.com:5060;branch=z9hG4bK721e4.1 Via: SIP/2.0/TCP ss1.atlanta.example.com:5060;branch=z9hG4bK2d4790.1 ;received=192.0.2.111 Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74b76 ;received=192.0.2.101 Max-Forwards: 68 From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 3848276298220188511@atlanta.example.com CSeq: 2 ACK Content-Length: 0 BYE Bob -\u0026gt; Proxy2 1 2 3 4 5 6 7 8 9 10 BYE sip:alice@client.atlanta.example.com SIP/2.0 Via: SIP/2.0/TCP client.biloxi.example.com:5060;branch=z9hG4bKnashds7 Max-Forwards: 70 Route: \u0026lt;sip:ss2.biloxi.example.com;lr\u0026gt;, \u0026lt;sip:ss1.atlanta.example.com;lr\u0026gt; From: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 To: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl Call-ID: 3848276298220188511@atlanta.example.com CSeq: 1 BYE Content-Length: 0 BYE Proxy2 -\u0026gt; Proxy1 1 2 3 4 5 6 7 8 9 10 11 BYE sip:alice@client.atlanta.example.com SIP/2.0 Via: SIP/2.0/TCP ss2.biloxi.example.com:5060;branch=z9hG4bK721e4.1 Via: SIP/2.0/TCP client.biloxi.example.com:5060;branch=z9hG4bKnashds7 ;received=192.0.2.201 Max-Forwards: 69 Route: \u0026lt;sip:ss1.atlanta.example.com;lr\u0026gt; From: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 To: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl Call-ID: 3848276298220188511@atlanta.example.com CSeq: 1 BYE Content-Length: 0 BYE Proxy1 -\u0026gt; Alice 1 2 3 4 5 6 7 8 9 10 11 12 BYE sip:alice@client.atlanta.example.com SIP/2.0 Via: SIP/2.0/TCP ss1.atlanta.example.com:5060;branch=z9hG4bK2d4790.1 Via: SIP/2.0/TCP ss2.biloxi.example.com:5060;branch=z9hG4bK721e4.1 ;received=192.0.2.222 Via: SIP/2.0/TCP client.biloxi.example.com:5060;branch=z9hG4bKnashds7 ;received=192.0.2.201 Max-Forwards: 68 From: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 To: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl Call-ID: 3848276298220188511@atlanta.example.com CSeq: 1 BYE Content-Length: 0 200 OK Alice -\u0026gt; Proxy1 1 2 3 4 5 6 7 8 9 10 11 12 SIP/2.0 200 OK Via: SIP/2.0/TCP ss1.atlanta.example.com:5060;branch=z9hG4bK2d4790.1 ;received=192.0.2.111 Via: SIP/2.0/TCP ss2.biloxi.example.com:5060;branch=z9hG4bK721e4.1 ;received=192.0.2.222 Via: SIP/2.0/TCP client.biloxi.example.com:5060;branch=z9hG4bKnashds7 ;received=192.0.2.201 From: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 To: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl Call-ID: 3848276298220188511@atlanta.example.com CSeq: 1 BYE Content-Length: 0 200 OK Proxy1 -\u0026gt; Proxy2 1 2 3 4 5 6 7 8 9 10 11 SIP/2.0 200 OK Via: SIP/2.0/TCP ss2.biloxi.example.com:5060;branch=z9hG4bK721e4.1 ;received=192.0.2.222 Via: SIP/2.0/TCP client.biloxi.example.com:5060;branch=z9hG4bKnashds7 ;received=192.0.2.101 From: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 To: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl Call-ID: 3848276298220188511@atlanta.example.com CSeq: 1 BYE Content-Length: 0 200 OK Proxy2 -\u0026gt; Bob 1 2 3 4 5 6 7 8 SIP/2.0 200 OK Via: SIP/2.0/TCP client.biloxi.example.com:5060;branch=z9hG4bKnashds7 ;received=192.0.2.201 From: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 To: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl Call-ID: 3848276298220188511@atlanta.example.com CSeq: 1 BYE Content-Length: 0 RE-INVITE 在此例中，Alice的ACK直接发给了Bob，是因为Proxy2到Alice的200 OK里没有Record-Route.\nBob的Re-INVITE直接发给了Alice,是因为Proxy2到Bob的INVITE没带Record-Route.\nsequenceDiagram actor Alice as Alice\u0026lt;br/\u0026gt;client.atlanta.example.com participant Proxy2 as Proxy2\u0026lt;br/\u0026gt;ss2.biloxi.example.com actor Bob as Bob\u0026lt;br/\u0026gt;client.biloxi.example.com Alice-\u0026gt;\u0026gt;Proxy2: INVITE Proxy2--\u0026gt;\u0026gt;Alice: 100 Trying Proxy2-\u0026gt;\u0026gt;Bob: INVITE Bob--\u0026gt;\u0026gt;Proxy2: 100 Trying Bob-\u0026gt;\u0026gt;Proxy2: 180 Ringing Proxy2-\u0026gt;\u0026gt;Alice: 180 Ringing Bob-\u0026gt;\u0026gt;Proxy2: 200 OK Proxy2-\u0026gt;\u0026gt;Alice: 200 OK Alice-\u0026gt;\u0026gt;Bob: ACK Alice\u0026lt;\u0026lt;-\u0026gt;\u0026gt;Bob: RTP Media Bob-\u0026gt;\u0026gt;Alice: INVITE Alice-\u0026gt;\u0026gt;Bob: 200 OK Bob-\u0026gt;\u0026gt;Alice: ACK Bob\u0026lt;\u0026lt;-\u0026gt;\u0026gt;Alice: New RTP Media Alice-\u0026gt;\u0026gt;Bob: BYE Bob-\u0026gt;\u0026gt;Alice: 200 OK Alice sends an INVITE to Proxy2. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 INVITE sip:bob@biloxi.example.com SIP/2.0 Via: SIP/2.0/UDP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 Max-Forwards: 70 From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt; Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com CSeq: 1 INVITE Contact: \u0026lt;sip:alice@client.atlanta.example.com\u0026gt; Content-Type: application/sdp Content-Length: 151 v=0 o=alice 2890844526 2890844526 IN IP4 client.atlanta.example.com s=- c=IN IP4 192.0.2.101 t=0 0 m=audio 49172 RTP/AVP 0 a=rtpmap:0 PCMU/8000 100 Trying Alice -\u0026gt; Proxy2 1 2 3 4 5 6 7 8 SIP/2.0 100 Trying Via: SIP/2.0/UDP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt; Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com CSeq: 1 INVITE Content-Length: 0 INVITE Proxy2 -\u0026gt; Bob 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 INVITE sip:bob@client.biloxi.example.com SIP/2.0 Via: SIP/2.0/UDP ss2.biloxi.example.com:5060;branch=z9hG4bK2d4790.1 Via: SIP/2.0/UDP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 Max-Forwards: 69 From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt; Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com CSeq: 1 INVITE Contact: \u0026lt;sip:alice@client.atlanta.example.com\u0026gt; Content-Type: application/sdp Content-Length: 151 v=0 o=alice 2890844526 2890844526 IN IP4 client.atlanta.example.com s=- c=IN IP4 192.0.2.101 t=0 0 m=audio 49172 RTP/AVP 0 a=rtpmap:0 PCMU/8000 180 Ringing Bob -\u0026gt; Proxy2 1 2 3 4 5 6 7 8 9 10 11 SIP/2.0 180 Ringing Via: SIP/2.0/UDP ss2.biloxi.example.com:5060;branch=z9hG4bK2d4790.1 ;received=192.0.2.222 Via: SIP/2.0/UDP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com CSeq: 1 INVITE Contact: \u0026lt;sip:bob@client.biloxi.example.com\u0026gt; Content-Length: 0 180 Ringing Proxy2 -\u0026gt; Alice 1 2 3 4 5 6 7 8 9 SIP/2.0 180 Ringing Via: SIP/2.0/UDP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com CSeq: 1 INVITE Contact: \u0026lt;sip:bob@client.biloxi.example.com\u0026gt; Content-Length: 0 200 OK Bob -\u0026gt; Proxy2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 SIP/2.0 200 OK Via: SIP/2.0/UDP ss2.biloxi.example.com:5060;branch=z9hG4bK2d4790.1 ;received=192.0.2.222 Via: SIP/2.0/UDP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com CSeq: 1 INVITE Contact: \u0026lt;sip:bob@client.biloxi.example.com\u0026gt; Content-Type: application/sdp Content-Length: 147 v=0 o=bob 2890844527 2890844527 IN IP4 client.biloxi.example.com s=- c=IN IP4 192.0.2.201 t=0 0 m=audio 3456 RTP/AVP 0 a=rtpmap:0 PCMU/8000 200 OK Proxy2 -\u0026gt; Alice 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 SIP/2.0 200 OK Via: SIP/2.0/UDP client.atlanta.example.com:5060;branch=z9hG4bK74bf9 ;received=192.0.2.101 From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com CSeq: 1 INVITE Contact: \u0026lt;sip:bob@client.biloxi.example.com\u0026gt; Content-Type: application/sdp Content-Length: 147 v=0 o=bob 2890844527 2890844527 IN IP4 client.biloxi.example.com s=- c=IN IP4 192.0.2.201 t=0 0 m=audio 3456 RTP/AVP 0 a=rtpmap:0 PCMU/8000 ACK Alice -\u0026gt; Bob 1 2 3 4 5 6 7 8 ACK sip:bob@client.biloxi.example.com SIP/2.0 Via: SIP/2.0/UDP client.atlanta.example.com:5060;branch=z9hG4bK74b7b Max-Forwards: 70 From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com CSeq: 1 ACK Content-Length: 0 INVITE Bob -\u0026gt; Alice 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 INVITE sip:alice@client.atlanta.example.com SIP/2.0 Via: SIP/2.0/UDP client.chicago.example.com:5060;branch=z9hG4bKlkld5l Max-Forwards: 70 From: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 To: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com CSeq: 14 INVITE Contact: \u0026lt;sip:bob@client.chicago.example.com\u0026gt; Content-Type: application/sdp Content-Length: 149 v=0 o=bob 2890844527 2890844528 IN IP4 client.chicago.example.com s=- c=IN IP4 192.0.2.100 t=0 0 m=audio 47172 RTP/AVP 0 a=rtpmap:0 PCMU/8000 200 OK Alice -\u0026gt; Bob 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 SIP/2.0 200 OK Via: SIP/2.0/UDP client.chicago.example.com:5060;branch=z9hG4bKlkld5l ;received=192.0.2.100 Max-Forwards: 70 From: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 To: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com CSeq: 14 INVITE Contact: \u0026lt;sip:alice@client.atlanta.example.com\u0026gt; Content-Type: application/sdp Content-Length: 150 v=0 o=alice 2890844526 2890844526 IN IP4 client.atlanta.example.com s=- c=IN IP4 192.0.2.101 t=0 0 m=audio 1000 RTP/AVP 0 a=rtpmap:0 PCMU/8000 ACK Alice -\u0026gt; Bob 1 2 3 4 5 6 7 8 ACK sip:alice@client.atlanta.example.com SIP/2.0 Via: SIP/2.0/UDP client.chicago.example.com:5060;branch=z9hG4bKlkldcc Max-Forwards: 70 From: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 To: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com CSeq: 14 ACK Content-Length: 0 BYE Alice -\u0026gt; Bob 1 2 3 4 5 6 7 8 BYE sip:bob@client.chicago.example.com SIP/2.0 Via: SIP/2.0/UDP client.atlanta.example.com:5060;branch=z9hG4bK74bo4 Max-Forwards: 70 From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com CSeq: 2 BYE Content-Length: 0 200 OK Bob -\u0026gt; Alice 1 2 3 4 5 6 7 8 9 SIP/2.0 200 OK Via: SIP/2.0/UDP client.atlanta.example.com:5060;branch=z9hG4bK74bo4 ;received=192.0.2.101 Max-Forwards: 70 From: Alice \u0026lt;sip:alice@atlanta.example.com\u0026gt;;tag=9fxced76sl To: Bob \u0026lt;sip:bob@biloxi.example.com\u0026gt;;tag=314159 Call-ID: 2xTb9vxSit55XU7p8@atlanta.example.com CSeq: 2 BYE Content-Length: 0 ","date":"2025-02-13T14:17:05+08:00","image":"https://QuincyGao.github.io/p/sip%E5%8D%8F%E8%AE%AErfc2361%E8%A6%81%E7%82%B9%E7%AC%94%E8%AE%B0%E4%BA%8C/5_hu15837114208695042845.jpg","permalink":"https://QuincyGao.github.io/p/sip%E5%8D%8F%E8%AE%AErfc2361%E8%A6%81%E7%82%B9%E7%AC%94%E8%AE%B0%E4%BA%8C/","title":"sip协议(rfc2361)要点笔记(二)"},{"content":"sip协议(rfc2361)原文 sip协议原文:rfc2361\n旧版sip协议原文:rfc2543\n基础要点 request line的格式为： Method SP Request-URI SP SIP-Version CRLF\nSP 是空格，Request-URI 是请求的资源，SIP-Version 是sip协议版本号，CRLF 是回车换行。 信令主要有：REGISTER,INVITE,ACK,CANCEL,BYE,OPTIONS,INFO,SUBSCRIBE,NOTIFY,REFER,MESSAGE\nuri完整格式:\nsip:user:password@host:port;uri-parameters?headers\nresponse line的格式为： SIP-Version SP Status-Code SP Reason-Phrase CRLF\nSIP-Version 是sip协议版本号，Status-Code 是响应码，Reason-Phrase 是响应短语，CRLF 是回车换行。\nHeader字段 格式:field-name: field-value 1 2 3 4 Subject: lunch Subject : lunch Subject :lunch Subject: lunch 以上都是正确的格式，但是Subject:lunch是最好的格式。\nfield-name相同的可以有多个，以下都是等价的 1 2 3 4 Route: \u0026lt;sip:alice@atlanta.com\u0026gt; Subject: Lunch Route: \u0026lt;sip:bob@biloxi.com\u0026gt; Route: \u0026lt;sip:carol@chicago.com\u0026gt; 1 2 3 Route: \u0026lt;sip:alice@atlanta.com\u0026gt;, \u0026lt;sip:bob@biloxi.com\u0026gt; Route: \u0026lt;sip:carol@chicago.com\u0026gt; Subject: Lunch 1 2 3 Subject: Lunch Route: \u0026lt;sip:alice@atlanta.com\u0026gt;, \u0026lt;sip:bob@biloxi.com\u0026gt;, \u0026lt;sip:carol@chicago.com\u0026gt; Route是有顺序的，以下两个是不等价的\n1 2 3 Route: \u0026lt;sip:alice@atlanta.com\u0026gt; Route: \u0026lt;sip:bob@biloxi.com\u0026gt; Route: \u0026lt;sip:carol@chicago.com\u0026gt; 1 2 3 Route: \u0026lt;sip:bob@biloxi.com\u0026gt; Route: \u0026lt;sip:alice@atlanta.com\u0026gt; Route: \u0026lt;sip:carol@chicago.com\u0026gt; field-name 是没有大小写区分的，但是field-value 是区分大小写的。 field-name 可以缩写，避免超过MTU. Header缩写表 field-name 简写 Call-ID i Contact m Content-Encoding e Content-Length l Content-Type c From f Subject s Supported k To t Via v UAC 请求头必须有六要素:From, To, Call-ID, CSeq, Via, Max-Forwards\nresponse头里的From,Call-ID,CSeq必须和request头里的相同。response的Via包含request的Via\n如果request头里To没有tag,response的To里的URL必须和request的To的URL一样。\n如何request头里To有tag,response的To必须和request的To一样。\n无状态的UAS 1 2 3 4 不会发送(1xx)response 不会重传response 忽略ACK request 忽略CANCEL request CANCEL 最好只对INVITE 请求使用,不能包括RequireorProxy-Require头 REGISTER response 带有Date字段，会通知client校准本地时间 response 不能带Record-Route字段,如果request带Record-Route字段, UAS要忽略掉。 expires的优先级高于Expires字段 200（OK）response必带Contact字段，以及expires参数 dialog 如果response没有收到route，UAC 必须把remote target uri 放到Request-URI里，然后请求不能加Route头 如果reponse收到route,并且route里的第一个uri包含lr字段， uac必须把remote target uri 放到Request-URI里， 然后请求添加Route头，把respose的route放到Route头里。 如果response收到route,并且route里的第一个uri不包含lr字段， uac必须把route里的第一个uri去掉其他的参数放到Request-URI里， 然后请求头添加Route,response的route放到Route头里。 把remote target uri 放到``Route`最后。 例子：remote target is sip:user@remoteua and the route set contains: \u0026lt;sip:proxy1\u0026gt;,\u0026lt;sip:proxy2\u0026gt;,\u0026lt;sip:proxy3;lr\u0026gt;,\u0026lt;sip:proxy4\u0026gt;\n那么请求为:\n1 2 METHOD sip:proxy1 Route: \u0026lt;sip:proxy2\u0026gt;,\u0026lt;sip:proxy3;lr\u0026gt;,\u0026lt;sip:proxy4\u0026gt;,\u0026lt;sip:user@remoteua\u0026gt; 如果uac收到2xx repsonse, 那么uac 必须使用response的Contact 作为remote target uri\n如果uas收到request时，那么uas 必须把request的Contact作为 remote target uri来发送请求\nuac 必须生成ACK request 为 2xx response, ACK的CSeq number和INVITE的CSeq number相同\nuas 收到INVITE 没有SDP信息时，uas必须返回2xx response 带有SDP信息,这个就是（UPDATE）\nProxy流转 注意： mermaid不支持;目前使用|代替\n基础流程 sequenceDiagram actor U1 as U1\u0026lt;br/\u0026gt;u1.example.com participant P1 as P1\u0026lt;br/\u0026gt;example.com participant P2 as P2\u0026lt;br/\u0026gt;domain.com actor U2 as U2\u0026lt;br/\u0026gt;u2.domain.com U1-\u0026gt;\u0026gt;P1: INVITE sip:callee@domain.com SIP/2.0\u0026lt;br/\u0026gt; Contact: sip:caller@u1.example.com P1-\u0026gt;\u0026gt;P2: INVITE sip:callee@domain.com SIP/2.0 \u0026lt;br/\u0026gt; Contact: sip:caller@u1.example.com \u0026lt;br/\u0026gt; Record-Route: \u0026lt;sip:p1.example.com|lr\u0026gt; P2-\u0026gt;\u0026gt;U2: INVITE sip:callee@u2.domain.com SIP/2.0 \u0026lt;br/\u0026gt; Contact: sip:caller@u1.example.com \u0026lt;br/\u0026gt; Record-Route: \u0026lt;sip:p2.example.com|lr\u0026gt; \u0026lt;br/\u0026gt; Record-Route:\u0026lt;sip:p1.example.com|lr\u0026gt; U2-\u0026gt;\u0026gt;P2: SIP/2.0 200 OK \u0026lt;br/\u0026gt; Contact: sip:callee@u2.domain.com \u0026lt;br/\u0026gt; Record-Route: \u0026lt;sip:p2.domain.com|lr\u0026gt; \u0026lt;br/\u0026gt; Record-Route: \u0026lt;sip:p1.example.com|lr\u0026gt; P2-\u0026gt;\u0026gt;P1: SIP/2.0 200 OK \u0026lt;br/\u0026gt; Contact: sip:callee@u2.domain.com \u0026lt;br/\u0026gt; Record-Route: \u0026lt;sip:p2.domain.com|lr\u0026gt; \u0026lt;br/\u0026gt; Record-Route: \u0026lt;sip:p1.example.com|lr\u0026gt; P1-\u0026gt;\u0026gt;U1: SIP/2.0 200 OK \u0026lt;br/\u0026gt; Contact: sip:callee@u2.domain.com \u0026lt;br/\u0026gt; Record-Route: \u0026lt;sip:p2.domain.com|lr\u0026gt; \u0026lt;br/\u0026gt; Record-Route: \u0026lt;sip:p1.example.com|lr\u0026gt; U1-\u0026gt;\u0026gt;P1: BYE sip:callee@u2.domain.com SIP/2.0 \u0026lt;br/\u0026gt; Route: \u0026lt;sip:p1.example.com|lr\u0026gt; \u0026lt;br/\u0026gt; Route:\u0026lt;sip:p2.domain.com|lr\u0026gt; P1-\u0026gt;\u0026gt;P2: BYE sip:callee@u2.domain.com SIP/2.0 \u0026lt;br/\u0026gt; Route:\u0026lt;sip:p2.domain.com|lr\u0026gt; P2-\u0026gt;\u0026gt;U2: BYE sip:callee@u2.domain.com SIP/2.0 严格路由流程 这是U1请求U2,但是经过中间P1,P2,P3,P4转发 sequenceDiagram actor U1 as U1\u0026lt;br/\u0026gt;u1.example.com participant P1 as P1\u0026lt;br/\u0026gt;example.com participant P2 as P2\u0026lt;br/\u0026gt;example.com participant P3 as P3\u0026lt;br/\u0026gt;middle.com participant P4 as P4\u0026lt;br/\u0026gt;domain.com actor U2 as U2\u0026lt;br/\u0026gt;u2.domain.com U1-\u0026gt;\u0026gt;P1: INVITE sip:callee@domain.com SIP/2.0\u0026lt;br/\u0026gt; Contact: sip:caller@u1.example.com P1-\u0026gt;\u0026gt;P2: INVITE sip:callee@domain.com SIP/2.0 \u0026lt;br/\u0026gt; Contact: sip:caller@u1.example.com \u0026lt;br/\u0026gt; Record-Route: \u0026lt;sip:p1.example.com|lr\u0026gt; P2-\u0026gt;\u0026gt;P3: INVITE sip:callee@domain.com SIP/2.0 \u0026lt;br/\u0026gt; Contact: sip:caller@u1.example.com \u0026lt;br/\u0026gt; Record-Route: \u0026lt;sip:p2.example.com|lr\u0026gt; \u0026lt;br/\u0026gt; Record-Route:\u0026lt;sip:p1.example.com|lr\u0026gt; P3-\u0026gt;\u0026gt;P4: INVITE sip:callee@domain.com SIP/2.0 \u0026lt;br/\u0026gt; Contact: sip:caller@u1.example.com \u0026lt;br/\u0026gt; Record-Route: \u0026lt;sip:p3.middle.com\u0026gt; \u0026lt;br/\u0026gt; Record-Route:\u0026lt;sip:p2.example.com|lr\u0026gt; \u0026lt;br/\u0026gt; Record-Route:\u0026lt;sip:p1.example.com|lr\u0026gt; P4-\u0026gt;\u0026gt;U2: INVITE sip:callee@u2.domain.com SIP/2.0 \u0026lt;br/\u0026gt; Contact: sip:caller@u1.example.com \u0026lt;br/\u0026gt; Record-Route: \u0026lt;sip:p4.domain.com|lr\u0026gt; \u0026lt;br/\u0026gt; Record-Route:\u0026lt;sip:p3.middle.com\u0026gt; \u0026lt;br/\u0026gt; Record-Route:\u0026lt;sip:p2.example.com|lr\u0026gt; \u0026lt;br/\u0026gt; Record-Route:\u0026lt;sip:p1.example.com|lr\u0026gt; U2-\u0026gt;\u0026gt;P4: BYE sip:caller@u1.example.com SIP/2.0 \u0026lt;br/\u0026gt; Route: \u0026lt;sip:p4.domain.com|lr\u0026gt; \u0026lt;br/\u0026gt; Route:\u0026lt;sip:p3.middle.com\u0026gt; \u0026lt;br/\u0026gt; Route:\u0026lt;sip:p2.example.com|lr\u0026gt; \u0026lt;br/\u0026gt; Route:\u0026lt;sip:p1.example.com|lr\u0026gt; P4-\u0026gt;\u0026gt;P3: BYE sip:p3.middle.com SIP/2.0 \u0026lt;br/\u0026gt; Route:\u0026lt;sip:p2.example.com|lr\u0026gt; \u0026lt;br/\u0026gt; Route:\u0026lt;sip:p1.example.com|lr\u0026gt; \u0026lt;br/\u0026gt; Route:\u0026lt;sip:caller@u1.example.com\u0026gt; P3-\u0026gt;\u0026gt;P2: BYE sip:p2.example.com|lr SIP/2.0 \u0026lt;br/\u0026gt; Route:\u0026lt;sip:p1.example.com|lr\u0026gt; \u0026lt;br/\u0026gt; Route:\u0026lt;sip:caller@u1.example.com\u0026gt; P2-\u0026gt;\u0026gt;P1: BYE sip:caller@u1.example.com SIP/2.0 \u0026lt;br/\u0026gt; Route:\u0026lt;sip:p1.example.com|lr\u0026gt; P1-\u0026gt;\u0026gt;U1: BYE sip:caller@u1.example.com SIP/2.0 U1请求P1,P1转发U2 sequenceDiagram actor U1 as U1\u0026lt;br/\u0026gt;u1.example.com participant P1 as P1\u0026lt;br/\u0026gt;p1.middle.com actor U2 as U2\u0026lt;br/\u0026gt;u2.domain.com U1-\u0026gt;\u0026gt;P1: INVITE sip:callee@middle.com SIP/2.0\u0026lt;br/\u0026gt; Contact: \u0026lt;sip:caller@u1.example.com\u0026gt; P1-\u0026gt;\u0026gt;U2: INVITE sip:callee@u2.domain.com SIP/2.0 \u0026lt;br/\u0026gt; Contact: \u0026lt;sip:caller@u1.example.com\u0026gt; \u0026lt;br/\u0026gt; Record-Route: \u0026lt;sip:p1.middle.com|lr\u0026gt; U2-\u0026gt;\u0026gt;P1: SIP/2.0 200 OK \u0026lt;br/\u0026gt; Contact: \u0026lt;sip:callee@u2.domain.com\u0026gt; \u0026lt;br/\u0026gt; Record-Route: \u0026lt;sip:p1.middle.com|lr\u0026gt; P1-\u0026gt;\u0026gt;U1: SIP/2.0 200 OK \u0026lt;br/\u0026gt; Contact: \u0026lt;sip:callee@u2.domain.com\u0026gt; \u0026lt;br/\u0026gt; Record-Route: \u0026lt;sip:p1.middle.com|lr\u0026gt; U1-\u0026gt;\u0026gt;P1: BYE sip:callee@u2.domain.com SIP/2.0 \u0026lt;br/\u0026gt; Route: \u0026lt;sip:p1.middle.com|lr\u0026gt; P1-\u0026gt;\u0026gt;U2: BYE sip:callee@u2.domain.com SIP/2.0 ","date":"2025-02-12T11:38:46+08:00","image":"https://QuincyGao.github.io/p/sip%E5%8D%8F%E8%AE%AErfc2361%E8%A6%81%E7%82%B9%E7%AC%94%E8%AE%B0%E4%B8%80/4_hu15279133479520789145.jpg","permalink":"https://QuincyGao.github.io/p/sip%E5%8D%8F%E8%AE%AErfc2361%E8%A6%81%E7%82%B9%E7%AC%94%E8%AE%B0%E4%B8%80/","title":"sip协议(rfc2361)要点笔记(一)"},{"content":"支持时序图 技术文档中常会用到时序图，hugo 默认不支持时序图，需要安装 mermaid.js.\n参考: hugo-mermaid\n我使用的hugo主题是: hugo-theme-stack\n使用方法 在路径layouts/_default/_markup/下新建一个文件render-codeblock-mermaid.html,内容为：\n1 2 3 4 5 \u0026lt;pre class=\u0026#34;mermaid\u0026#34;\u0026gt; {{ .Inner | htmlEscape | safeHTML }} \u0026lt;/pre\u0026gt; {{ .Page.Store.Set \u0026#34;hasMermaid\u0026#34; true }} 然后在layouts/partials/article/content.html最后面添加如下代码：\n1 2 3 4 5 6 {{ if .Store.Get \u0026#34;hasMermaid\u0026#34; }} \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import mermaid from \u0026#39;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs\u0026#39;; mermaid.initialize({ startOnLoad: true }); \u0026lt;/script\u0026gt; {{ end }} 这样就可以了，hugo server -D 运行看看效果\n示例 1 2 3 4 5 6 7 8 9 10 11 12 ```mermaid sequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail! John--\u0026gt;\u0026gt;Alice: Great! John-\u0026gt;\u0026gt;Bob: How about you? Bob--\u0026gt;\u0026gt;John: Jolly good! 效果 sequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail! John--\u0026gt;\u0026gt;Alice: Great! John-\u0026gt;\u0026gt;Bob: How about you? Bob--\u0026gt;\u0026gt;John: Jolly good! ","date":"2025-02-11T14:54:27+08:00","image":"https://QuincyGao.github.io/p/hugo-%E5%B0%8F%E6%8A%80%E5%B7%A7/2_hu18083178838280766805.jpg","permalink":"https://QuincyGao.github.io/p/hugo-%E5%B0%8F%E6%8A%80%E5%B7%A7/","title":"hugo 小技巧"},{"content":"b2b_logic模块介绍 b2b_logic 官方使用场景介绍:https://www.opensips.org/Documentation/Tutorials-B2BUA-3-2\n本次测试的opensips版本为：\nopensips 3.3.10 (x86_64/linux)\nb2b_logic 实战 配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 loadmodule \u0026#34;b2b_entities.so\u0026#34; loadmodule \u0026#34;rtp_relay.so\u0026#34; loadmodule \u0026#34;dialog.so\u0026#34; loadmodule \u0026#34;b2b_logic.so\u0026#34; modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;hash_size\u0026#34;, 10) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;script_req_route\u0026#34;, \u0026#34;b2b_logic_request\u0026#34;) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;script_reply_route\u0026#34;, \u0026#34;b2b_logic_reply\u0026#34;) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;cleanup_period\u0026#34;, 60) #modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;db_url\u0026#34;, \u0026#34;mysql://opensips:opensipsrw@172.16.4.111/opensips\u0026#34;) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;update_period\u0026#34;, 60) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;max_duration\u0026#34;, 7200) #modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;contact_user\u0026#34;, 1) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;server_address\u0026#34;, \u0026#34;sip:$fU@172.16.4.111:5360\u0026#34;) #modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;db_mode\u0026#34;, 1) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;b2bl_th_init_timeout\u0026#34;, 60) modparam(\u0026#34;b2b_logic\u0026#34;, \u0026#34;b2bl_early_update\u0026#34;, 1) 在 route主请求中添加：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 if(is_method(\u0026#34;INVITE\u0026#34;) \u0026amp;\u0026amp; !has_totag()) { xlog(\u0026#34;L_DBG\u0026#34;,\u0026#34;[$cfg_line][$ci]---b2b-server_new--:$rm|$rs|$tu|$socket_in(port)|$var(contact)\\n\u0026#34;); b2b_server_new(\u0026#34;caller\u0026#34;); create_dialog(\u0026#34;B\u0026#34;); rtp_relay_engage(\u0026#34;rtpengine\u0026#34;,0); #$avp(route)=\u0026#34;Record-Route\u0026#34;; #$avp(route-content)=\u0026#34;\u0026lt;sip:172.16.4.111:5360;lr\u0026gt;\u0026#34;; #b2b_client_new(\u0026#34;callee\u0026#34;, \u0026#34;sip:$tU@172.16.4.114:5080\u0026#34;,,,$ct); b2b_client_new(\u0026#34;callee\u0026#34;, \u0026#34;sip:$tU@172.16.4.114:5080\u0026#34;); #record_route(); #b2b_client_new(\u0026#34;callee\u0026#34;, \u0026#34;sip:$tU@172.16.4.114:5080\u0026#34;,,,$ct,$avp(route),$avp(route-content)); # initialize B2B session b2b_init_request(\u0026#34;prepaid\u0026#34;); exit; } route[b2b_logic_reply] { xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;[$fU $tU $ci $rm] B2B_Reply Received from $si:$sp User-Agent:$ua\\n\u0026#34;); xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;[$fU $tU $ci $rm] B2B_Reply message $rs:$rr received \\n\u0026#34;); b2b_handle_reply(); exit; } route[b2b_logic_request] { xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;[$fU $tU $ci $rm] B2B_Request Received from $si:$sp User-Agent:$ua\\n\u0026#34;); xlog(\u0026#34;L_INFO\u0026#34;,\u0026#34;[$fU $tU $ci $rm] B2B_Request message $rs:$rr received \\n\u0026#34;); b2b_pass_request(); exit; } 需要注意的是， b2b_logic中媒体服务使用的是rtp_relay,通过rtp_relay来选择媒体代理。 通过b2b_logic 转发的INVITE的Call-ID是新生成的（例如:B2B.377.4269969.1739239153）和主叫的INVITE的Call-ID不同。\n目前发现，被叫挂断时b2b_logic会多发送一个Bye给自己，这个应该是invite的Contact被修改成了111机器的缘故。\n主叫挂断的sip流程图：\n被叫挂断的sip流程图：\n","date":"2025-02-11T08:49:22+08:00","image":"https://QuincyGao.github.io/p/b2b_logic%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/2_hu2473336972660618009.jpg","permalink":"https://QuincyGao.github.io/p/b2b_logic%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","title":"b2b_logic模块介绍"},{"content":"介绍 uac_registant模块是把自己作为uac注册到第三方sip服务，必须使用数据库来存储自己的注册信息。 使用的表为: registrant\n本次测试的opensips版本为:\nopensips 3.5.3 (x86_64/linux)\n配置添加 1 2 3 4 5 6 7 loadmodule \u0026#34;db_mysql.so\u0026#34; loadmodule \u0026#34;uac_auth.so\u0026#34; loadmodule \u0026#34;uac_registrant.so\u0026#34; modparam(\u0026#34;uac_registrant\u0026#34;, \u0026#34;hash_size\u0026#34;, 4) modparam(\u0026#34;uac_registrant\u0026#34;, \u0026#34;timer_interval\u0026#34;, 30) modparam(\u0026#34;uac_registrant\u0026#34;, \u0026#34;failure_retry_interval\u0026#34;, 60) modparam(\u0026#34;uac_registrant\u0026#34;, \u0026#34;db_url\u0026#34;, \u0026#34;mysql://opensips:opensipsrw@172.16.3.102/opensips\u0026#34;) 需要注意的是: timer_interval 要小于registrant表里的expiry字段时间，否则服务启动时报错：\nERROR:uac_registrant:load_reg_info_from_db: Please decrease timer_interval=[120] - requested expires=[100] to small for AOR=[sip:1001@172.16.4.114]\n添加数据库 1 insert into registrant (registrar, aor, username, password, binding_URI, expiry, forced_socket)values(\u0026#34;sip:172.16.4.114:5060\u0026#34;,\u0026#34;sip:1001@172.16.4.111\u0026#34;,\u0026#34;1001\u0026#34;,\u0026#34;1234\u0026#34;,\u0026#34;sip:1001@172.16.4.111\u0026#34;,300,\u0026#34;udp:172.16.4.111:5361\u0026#34;); registrar: 注册的sip服务地址\naor: From, to 字段的uri\nusername,password: 用户名密码\nbinding_URI: contact 字段\nexpiry: 过期时间\nforced_socket: opensips发送register请求的socket地址\n测试结果 opensips启动30s后,跟踪sip信令,能够看到以下信息 总结 该模块只是把opensips以配置的用户名密码注册到第三方sip，使用场景有限，能够使用的场景有：\n检测第三方sip服务是否正常 维持 NAT/防火墙穿透 ","date":"2025-02-08T09:56:29+08:00","image":"https://QuincyGao.github.io/p/uac_registant%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/2_hu11294429585031955147.jpg","permalink":"https://QuincyGao.github.io/p/uac_registant%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","title":"uac_registant模块介绍"},{"content":"背景介绍 自从使用opensips和rtpengine做sbc以来，一直对其所能支撑的并发数有所怀疑，正好最近项目不多，就申请了三台阿里云机器来做压测，共耗时一个月。\n本次压测的功能：把opensips用作注册代理转发，现对压测结果做个总结。\n压测模型 压测场景 坐席A和B使用udp通过opensips注册到uas，坐席A通过opensips拨打电话到坐席B, 坐席B接通电话后，坐席A和B通过opensips进行2分钟通话，然后坐席A挂断电话。\n版本信息 1 2 3 opensips: 3.3.10 rtpengine: 13.1.0.0+0~mr13.1.0.0 opensips和rtpengine 分别用host模式docker容器运行。 opensips和rtpengine使用docker部署的好处就是使用docker stats 能够获取容器是实际占用内存和cpu使用率\n监控指标 1 2 3 4 5 6 cpu使用率 负载 内存使用率 网络带宽 tcp 连接数 通话数 监控工具 1 2 3 阿里云的资源监控 opensips-cli docker stats 命令 压测注意问题 1. 压测的cps和通话时长要合适 压测目的是保持稳定并发数时的资源使用情况\n如果通话时长太短比如:1分钟以内，在高并发的情况下(1000往上)，无法稳定保持并发数。 如果cps太大，此时网络带宽会有比较大的波动，高并发数情况下，opensips和uas会出现丢包情况。 合理的cps计算方式为: 并发数/通话时长(s),如果是小数可以适当向上取整。 比如: 1000并发数，通话时长为2分钟，那么cps为1000/120=8.3约等于9。 对应的sipp 命令为: -r 9 -rp 1s\n2. 如何确定总压测时长 压测时长2小时，实际的sipp压测脚本参数并没有总通话时长，但sipp中有总压测数参数，那么应该如何确定压测时长呢？\n总压测数=并发数*压测时长(分钟)/通话时长(分钟)\n对于此压测场景，总压测数=1000*120/2=60000,对应的sipp命令为: -m 60000\n注意：实际压测中并不是并发数1000，sipp的-l 就是1000，可能会比1000多几个，按照实际压测来调整.\n3. 完整的uac sipp命令 以1000路为例:\n1 ./sipp -r 9 -rp 1s -i 172.16.4.115 -p 5667 -sf register.xml -inf $csvfile 172.20.231.4:5261 -l 1019 -m 61140 -aa -trace_err -error_file ./reg_error.log -bg 可以看到-l 1019,如果想要dialog能稳定到1000路，需要把-l参数调整到1019。\n压测结果分析 opensips和rtpengine的内存未释放？ 在udp压测时，opensips的运行参数为: -m 2048 -M 100 意思为:共享内存为2048MB,pkg内存100MB, udp_workers=32 tcp_workers=8。 在实际压测过程中，阿里云的监控能够看到，内存使用率一直都是2G，变化较少。但是通过docker stats分别在压测开始和结束统计,能够看到opensips和rtpengine的实际占用内存是有变化的。以1000路为例:\nopensips:959.4MiB-\u0026gt;982MiB | rtpengine: 23.89MiB-\u0026gt;87.73MiB\n压测停止6小时之后，opensips和rtpengine的docker实际占用内存并没有减少，一开始我以为是内存泄露，调整opensips.cfg添加memdump=2开启内存打印。\n在压测结束后， 通过opensips-cli执行mi mem_shm_dump,参考：opensips内存泄漏排查，并没有发现有相似的dumping all alloc'ed. fragments。 而且压测结束后，查看rtpengine的端口占用情况，rtp端口都被释放了。\n值得注意的是：并发数减少，opensips和rtpengin的内存占用不会变，并发数增加，它们的内存会往上升。之后一直维持该内存大小不再增加。\n个人猜测： opensips和rtpengine的占用内存是动态扩展的，当并发数增加，内存会自动扩展，当并发数减少，占用的内存不会自动释放。\n压测极限 监测数据 本次使用的是opensips-cli\n1 2 3 mi get_statistics dialog active_dialogs 可以查看实时通话量 mi get_statistics dialog processed_dialogs 可以查看通话总数 mi get_statistics all 可以查看所有统计数据 实际压测2小时数据 1700路 cpu使用率 cpu负载 内存使用率 带宽: 通话量: 内存增长:\nopensips:959.4MiB-\u0026gt;989MiB=29.6MiB | rtpengine: 24.46MiB-\u0026gt;118.9MiB=94.44MiB\n1800路 cpu使用率 cpu负载 内存使用率 带宽: 通话量: 内存增长:\nopensips:959.4MiB-\u0026gt;990.4MiB=31MiB | rtpengine: 23.89MiB-\u0026gt;123.1MiB=99.21MiB\n通过对比:1600-1700路和1700-1800路的带宽增长情况,发现1700路-\u0026gt;1800路的带宽增长迟缓,没有达到理论值。\n所以,8C8G压测的极限是1700路，此极限是rtpengine的极限,推测:cpu负载大，导致rtpengine出流较慢，udp数据包减少,影响了通话质量。opensips其实并未到极限。\n压测结束后，通过opensips-cli执行mi get_statistics all 能够看到实际占用的内存很少，还有大量的内存空闲。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026#34;shmem:total_size\u0026#34;: 2147483648, \u0026#34;shmem:max_used_size\u0026#34;: 15768384, \u0026#34;shmem:free_size\u0026#34;: 2142524128, \u0026#34;shmem:used_size\u0026#34;: 4708928, \u0026#34;shmem:real_used_size\u0026#34;: 4959520, \u0026#34;shmem:fragments\u0026#34;: 3871, \u0026#34;rpmem:rpm_total_size\u0026#34;: 0, \u0026#34;rpmem:rpm_used_size\u0026#34;: 0, \u0026#34;rpmem:rpm_real_used_size\u0026#34;: 0, \u0026#34;rpmem:rpm_fragments\u0026#34;: 0, \u0026#34;rpmem:rpm_max_used_size\u0026#34;: 0, \u0026#34;rpmem:rpm_free_size\u0026#34;: 0, sip 使用tcp通信 场景：\nuac\u0026ndash;tcp\u0026mdash;-\u0026gt;opensips\u0026mdash;-tcp\u0026mdash;-\u0026gt;uas\n1600路 1800路 uac和opensips使用tcp通信，uac是多个tcp连接到opensips的同一个端口. 在opensips和uas使用tcp通信时，原本以为会是多个tcp和uas连接，结果只用了一个tcp连接，所有的请求都是复用这个tcp连接。 tcp的性能比udp性能要高，tcp连接方式并发能到1800路。 总结 opensips-cli只能获取实时数据，无法获取历史数据。可以考虑使用opensips-cp监控。 rtpengine在高并发情况下，为啥会出流慢，目前还未找到原因，rtpengine的日志也没有报错。 ","date":"2025-01-14T08:59:33+08:00","image":"https://QuincyGao.github.io/p/opensips-%E5%8E%8B%E6%B5%8B%E4%BB%8B%E7%BB%8D/backup_hu11264033365958483853.jpg","permalink":"https://QuincyGao.github.io/p/opensips-%E5%8E%8B%E6%B5%8B%E4%BB%8B%E7%BB%8D/","title":"opensips 压测介绍"}]